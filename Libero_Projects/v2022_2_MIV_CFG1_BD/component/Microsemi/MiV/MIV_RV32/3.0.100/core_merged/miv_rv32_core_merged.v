// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   common_buffer_0delay.sv
//
//   Purpose:

//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none


module  miv_rv32_common_buffer_behav
//********************************************************************************
// Parameter description

  #(
    parameter BUFF_WIDTH = 32,
    parameter BUFF_SIZE = 2,
    parameter PTR_SIZE = 1
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    input wire                               resetn,
    input wire                               clk,
    
    input wire                               valid_in,
    output wire                              ready_in,
    input wire [BUFF_WIDTH-1:0]              data_in,
    
    output wire [BUFF_WIDTH-1:0]             data_out,
    output wire                              valid_out,    
    input wire                               ready_out
    
 
    
  );

//********************************************************************************
// localparams
  localparam BUFF_MAX = BUFF_SIZE-1;

// Declarations

  reg  [PTR_SIZE-1:0]              buff_wr_ptr;
  reg  [PTR_SIZE-1:0]              buff_rd_ptr;
  wire [PTR_SIZE-1:0]              next_buff_wr_ptr;
  wire [PTR_SIZE-1:0]              next_buff_rd_ptr;
  
  wire [BUFF_SIZE-1:0]             buff_wr_strb;
  wire [BUFF_SIZE-1:0]             buff_rd_strb;
  wire [BUFF_SIZE-1:0]             next_alloc;
  
  reg [BUFF_SIZE-1:0]              buff_valid;
  wire [BUFF_SIZE-1:0]             next_buff_valid;
  reg [BUFF_WIDTH-1:0]             buff_data[BUFF_SIZE-1:0]; 
  
  wire                             rd_data;
  wire                             wr_data;
  
  wire                             full;
  wire                             empty;
  
  reg [(BUFF_SIZE*BUFF_WIDTH)-1:0] data_out_pkd_reg;
  reg [BUFF_SIZE-1:0]              valid_out_pkd_reg;
  
  wire                             next_buff_ready;
  reg                              buff_ready_reg;

  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  assign full     = &buff_valid;
  assign empty    = ~(|buff_valid);
  assign wr_data  = valid_in & buff_ready_reg;
  assign rd_data  = ready_out & valid_out;
  
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_rd_ptr <= {PTR_SIZE{1'b0}};
    else
      if(rd_data)
        buff_rd_ptr <= next_buff_rd_ptr;        
  end 
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_wr_ptr <= {PTR_SIZE{1'b0}};
    else
      if(wr_data)
        buff_wr_ptr <= next_buff_wr_ptr;
  end
  
  assign next_buff_wr_ptr = (buff_wr_ptr == BUFF_MAX) ? {PTR_SIZE{1'b0}} : buff_wr_ptr+1;
  assign next_buff_rd_ptr = (buff_rd_ptr == BUFF_MAX) ? {PTR_SIZE{1'b0}} : buff_rd_ptr+1;
  
  
  
  generate
  genvar gen_buff;
  for(gen_buff = 0; gen_buff<BUFF_SIZE; gen_buff=gen_buff+1)
  begin : gen_buff_loop
  
    assign buff_wr_strb[gen_buff] = wr_data & (buff_wr_ptr == gen_buff[PTR_SIZE-1:0]);
    assign next_alloc[gen_buff] = (buff_wr_ptr == gen_buff[PTR_SIZE-1:0]);
    assign buff_rd_strb[gen_buff] = rd_data & (buff_rd_ptr == gen_buff[PTR_SIZE-1:0]);
  
    // Data not reset
    always @(posedge clk)
    begin    
      begin
        if(buff_wr_strb[gen_buff])
        begin
          buff_data[gen_buff] <= data_in;
        end
      end
    end
  
  
    assign next_buff_valid[gen_buff] = (buff_valid[gen_buff] | buff_wr_strb[gen_buff]) & ~buff_rd_strb[gen_buff];
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        buff_valid[gen_buff]  <=  1'b0;
      else
        buff_valid[gen_buff]  <= next_buff_valid[gen_buff]; 
    end  
    
  end
  endgenerate
  
  assign data_out  = !(|buff_valid) ? data_in : buff_data[buff_rd_ptr];
  assign valid_out = !(|buff_valid) ? valid_in : buff_valid[buff_rd_ptr];
  
  assign next_buff_ready = ~(&next_buff_valid);
  
 
  
  assign ready_in = next_buff_ready;


  
  


endmodule


`default_nettype wire
// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_bcu.sv
//
//   Purpose:
//   Branch Computation Unit for Core
//   Computes all program addresses for branches, trap, reset, and sequential execution
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module  miv_rv32_bcu
//********************************************************************************
// Parameter description

  #(
    parameter USE_FORMAL = 1,
    parameter USE_SIM = 1
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    
    input wire  logic                         clk,
    input wire  logic                         resetn,
    // controls                
    input wire  t_exu_bcu_operand0_sel        bcu_operand0_mux_sel,             
    input wire  t_exu_bcu_operand1_sel        bcu_operand1_mux_sel,             
    input wire  t_exu_bcu_op_sel              bcu_op_sel,  
//    input wire  logic                         bcu_op_valid,  
    output      logic                         bcu_op_ready,           
      //operands
    input wire  logic [L_XLEN-1:0]            bcu_operand_pc,                 
    input wire  logic                         bcu_operand_pc_valid,  
    input wire  logic [L_XLEN-1:0]            bcu_operand_gpr_rs1,            
    input wire  logic                         bcu_operand_gpr_rs1_valid, 
    input wire  logic [L_XLEN-1:0]            bcu_operand_trap_cause,  
    input wire  logic                         bcu_operand_trap_cause_valid, 
    input wire  logic [L_XLEN-1:0]            bcu_operand_immediate,          
    input wire  logic                         bcu_operand_immediate_valid,     
    input wire  logic [L_XLEN-1:0]            bcu_operand_epc,                
    input wire  logic                         bcu_operand_epc_valid,      
    input wire  logic [L_XLEN-1:0]            bcu_operand_dpc,                
    input wire  logic                         bcu_operand_dpc_valid,    
    input wire  logic [L_XLEN-1:0]            bcu_operand_trap_vec, 
    input wire  logic                         bcu_operand_trap_vec_valid,   
    input wire  logic [L_XLEN-1:0]            bcu_operand_reset_vec, 
    input wire  logic                         bcu_operand_reset_vec_valid,                   
      // result               
    output      logic [L_XLEN-1:0]            bcu_result,
    output      logic                         bcu_result_valid,
    input wire  logic                         bcu_result_ready

  );

//********************************************************************************
// localparams


// Declarations

  logic [L_XLEN-1:0]            bcu_add_result;
  logic [L_XLEN-1:0]            bcu_operand0;      
  logic                         bcu_operand0_valid;
  logic [L_XLEN-1:0]            bcu_operand1;      
  logic                         bcu_operand1_valid;  
  

  
  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  


    // bcu_operand0  
  always @*
  begin
    case(bcu_operand0_mux_sel)
      bcu_operand0_pc :
      begin
        bcu_operand0        = bcu_operand_pc;      
        bcu_operand0_valid  = bcu_operand_pc_valid;
      end
      bcu_operand0_rs1 :
      begin
        bcu_operand0        = bcu_operand_gpr_rs1;      
        bcu_operand0_valid  = bcu_operand_gpr_rs1_valid;
      end
      bcu_operand0_trap_cause :
      begin
        bcu_operand0        = bcu_operand_trap_cause;
        bcu_operand0_valid  = bcu_operand_trap_cause_valid;
      end
      default :
      begin
        bcu_operand0        = {L_XLEN{1'b0}};
        bcu_operand0_valid  = 1'b0;
      end
    endcase
  end
  
    // bcu_operand1
  always @*
  begin
    case(bcu_operand1_mux_sel)
      bcu_operand1_imm :
      begin
        bcu_operand1        = bcu_operand_immediate;      
        bcu_operand1_valid  = bcu_operand_immediate_valid;
      end
      bcu_operand1_epc :
      begin
        bcu_operand1        = bcu_operand_epc;      
        bcu_operand1_valid  = bcu_operand_epc_valid;
      end
      bcu_operand1_dpc :
      begin
        bcu_operand1        = bcu_operand_dpc;      
        bcu_operand1_valid  = bcu_operand_dpc_valid;
      end
      bcu_operand1_exvec :
      begin
        bcu_operand1        = bcu_operand_trap_vec;
        bcu_operand1_valid  = bcu_operand_trap_vec_valid;
      end
      bcu_operand1_resetvec :
      begin
        bcu_operand1        = bcu_operand_reset_vec;
        bcu_operand1_valid  = bcu_operand_reset_vec_valid;
      end
      default :
      begin
        bcu_operand1        = {L_XLEN{1'b0}};
        bcu_operand1_valid  = 1'b0;
      end
    endcase
  end
  

  // BCU

  assign bcu_add_result = (bcu_operand0 + bcu_operand1);
  
  always @*
  begin
    case(bcu_op_sel)
      bcu_op_none :     
      begin
        bcu_result        = bcu_add_result;
        bcu_result_valid  = 1'b0;
      end
      bcu_op_add :
      begin
        bcu_result        = bcu_add_result; //{bcu_add_result[L_XLEN-1:1],1'b0};
        bcu_result_valid  = bcu_operand0_valid & bcu_operand1_valid; // & bcu_op_valid;
      end
      default :
      begin
        bcu_result        = {L_XLEN{1'b0}};
        bcu_result_valid  = 1'b0;
      end
    endcase
  end
  
  // BCU is currently purealy combinational, therefore can accept new operation when result is acceptable
  assign bcu_op_ready = bcu_result_ready;

  



endmodule


`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_core.sv
//
//   Purpose: core core
//            Contains the main blocks of the core including:
//              - Instruction Fetch Unit
//              - Load Store Unit
//              - Memory Management Unit
//              - Execution Pipeline Unit
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_core_cfg_pkg::*;

module miv_rv32_core
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH          = 32,
    parameter D_ADDR_WIDTH          = 32,
    parameter I_DATA_BYTES          = 4,
    parameter D_DATA_BYTES          = 4,
	parameter l_core_cfg_hw_debug           = 0,
    parameter l_core_cfg_num_triggers       = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_compressed      = 0,
	parameter l_core_reset_vector           = 32'h6000_0000,
    parameter l_core_static_mtvec_base      = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base  = 0,
    parameter l_core_cfg_static_mtvec_mode  = 0,
    parameter l_core_static_mtvec_mode      = 0,
	parameter l_core_num_sys_ext_irqs       = 7,
	parameter l_core_cfg_hw_macc_multiplier = 0,
	parameter l_core_cfg_time_count_width   = 0,
    parameter l_core_cfg_lsu_fwd            = 1'b0,
    parameter l_core_cfg_csr_fwd            = 1'b1,
    parameter l_core_cfg_exu_fwd            = 1'b1,
	parameter l_core_cfg_gpr_type           = 1,
	parameter ECC_ENABLE                         = 0
	
   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                core_soft_reset, 
  input  wire logic                                parity_en,   
  output      logic                                gpr_uncorrectable_ecc_error,
  input  wire logic [(L_XLEN*2)-1:0]               time_count, 
  input  wire logic [L_XLEN-1:0]                   hart_id,
  
  
  // Fetch Unit External Memory Interface
 
  output      logic                                ifu_emi_req_valid,
  input wire  logic                                ifu_emi_req_ready,
  output      logic [3:0]                          ifu_emi_req_rd_byte_en, 
  output      logic[I_ADDR_WIDTH-1:0]              ifu_emi_req_addr,  
  output      logic                                ifu_emi_req_addr_p,
  input wire  logic                                ifu_emi_resp_valid,
  output      logic                                ifu_emi_resp_ready,
  input wire  logic [31:0]                         ifu_emi_resp_data,
  input wire  logic [3:0]                          ifu_emi_resp_data_p,
  input wire  logic                                ifu_emi_resp_error,    
  
  // Load-Store Unit External Memory Interface

  output      logic                                lsu_emi_req_valid,
  input wire  logic                                lsu_emi_req_ready, 
  output      logic [3:0]                          lsu_emi_req_rd_byte_en,  
  output      logic [3:0]                          lsu_emi_req_wr_byte_en,
  output      logic [31:0]                         lsu_emi_req_addr,
  output      logic                                lsu_emi_req_addr_p,
  output      logic                                lsu_emi_req_fence,
  output      logic                                lsu_emi_req_read,
  output      logic                                lsu_emi_req_write,
  output      logic [31:0]                         lsu_emi_req_wr_data,
  output      logic [3:0]                          lsu_emi_req_wr_data_p,
  input wire  logic                                lsu_emi_resp_valid,
  output      logic                                lsu_emi_resp_ready,
  input wire  logic                                lsu_emi_resp_error,
  input wire  logic [31:0]                         lsu_emi_resp_rd_data,  
  input wire  logic [3:0]                          lsu_emi_resp_rd_data_p,       
  
  // Debug Unit Interface 
  input  wire  logic                               debug_reset,  
  input  wire  logic                               debug_core_reset,
  input  wire  logic                               debug_active,
  input  wire  logic [L_XLEN-1:0]                  debug_csr_gpr_req_wr_data, 
  input  wire  logic                               debug_csr_req_valid,          
  output logic                                     debug_csr_req_ready, 
  input  wire  logic                               debug_csr_req_wr_en, 
  input  wire  logic                               debug_csr_req_rd_en, 
  input  wire logic [11:0]                         debug_csr_req_addr,        
  output logic [L_XLEN-1:0]                        debug_csr_resp_rd_data,   
  output logic                                     debug_csr_resp_valid,
  input  wire  logic                               debug_csr_resp_ready,
  input  wire  logic                               debug_gpr_req_valid,          
  output logic                                     debug_gpr_req_ready, 
  input  wire  logic                               debug_gpr_req_wr_en, 
  input  wire  logic                               debug_gpr_req_rd_en, 
  input  wire logic [4:0]                          debug_gpr_req_addr,     
  output logic [L_XLEN-1:0]                        debug_gpr_resp_rd_data,   
  output logic                                     debug_gpr_resp_valid,
  input  wire  logic                               debug_gpr_resp_ready, 
  input  wire logic                                debug_halt_req,   
  output logic                                     debug_halt_ack, 
  input  wire logic                                debug_resethalt_req,   
  output logic                                     debug_resethalt_ack,  
  input  wire logic                                debug_resume_req,   
  output logic                                     debug_resume_ack,
  output logic                                     debug_mode,
  
  // Interrupt (LIC) Interface     
  
  input wire  logic                                m_sw_irq,
  input wire  logic                                m_timer_irq,
  input wire  logic                                m_external_irq,      
  input wire  logic [7:0]                          sys_ext_irq_src, 
  
  // Direct State Inmterface
  
  // Formal Trace Interface
  
  output logic [L_XLEN-1:0]                        formal_trace_instr,
  output logic [L_XLEN-1:0]                        formal_trace_pc,  
  output logic                                     formal_trace_reset_taken, 
  output logic                                     formal_trace_instr_retire

  );
   


  
//******************************************************************************
// Declarations
  logic                                ifu_expipe_fetch_en_net;
  logic                                ifu_expipe_req_branch_excpt_req_valid_net;
  logic                                ifu_expipe_req_branch_excpt_req_fenci_net;
  logic                                ifu_expipe_req_fenci_proceed_net;         
  logic                                ifu_expipe_req_branch_excpt_req_ready_net;          
  logic                                ifu_expipe_req_branch_excpt_taken_net;
  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr_net; 
  logic [1:0]                          ifu_expipe_req_priv_net; 
  logic                                ifu_expipe_req_flush_net;
  logic                                ifu_expipe_resp_valid_net;
  logic                                ifu_expipe_resp_ready_net;
  logic [31:0]                         ifu_expipe_resp_ireg_net;
  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr_net;
  logic                                ifu_expipe_resp_ireg_vaddr_valid_net;
  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_next_vaddr_net;
  logic                                ifu_expipe_resp_compressed_net;
  logic                                ifu_expipe_resp_access_fault_net;  
  logic                                ifu_expipe_resp_access_mem_error_net;
  logic                                ifu_expipe_resp_access_parity_error_net;
  logic                                ifu_expipe_resp_access_misalign_error_net;
  logic                                ifu_expipe_resp_access_aborted_net;  
  
  logic                                lsu_flush_net;
  logic                                lsu_op_os_net;
  logic                                lsu_load_os_net;
  logic                                lsu_fence_os_net;
  logic                                lsu_expipe_req_valid_net;  
  logic                                lsu_expipe_req_ready_net;  
  logic[D_ADDR_WIDTH-1:0]              lsu_expipe_req_addr_net;
  logic                                lsu_expipe_req_addr_valid_net; 
  logic [31:0]                         lsu_expipe_req_wr_data_net;
  logic                                lsu_expipe_req_wr_data_valid_net;  
  t_lsu_op                             lsu_expipe_req_op_net;   
  logic                                lsu_expipe_resp_valid_net;
  logic                                lsu_expipe_resp_ready_net;       
  logic [31:0]                         lsu_expipe_resp_rd_data_net;
  logic                                lsu_expipe_resp_ld_addr_misalign_net;
  logic                                lsu_expipe_resp_ld_access_fault_net;
  logic                                lsu_expipe_resp_str_amo_addr_misalign_net;
  logic                                lsu_expipe_resp_str_amo_access_fault_net;
  logic                                lsu_expipe_resp_access_mem_error_net;
  logic                                lsu_expipe_resp_access_parity_error_net;
  logic                                lsu_expipe_resp_access_aborted_net;
 
  //gpr ram init done signal to hold cpu in soft reset while init takes place
  logic                                gpr_ram_init_done;
  
  
//******************************************************************************
// Main code

 

  

  //--------------------------------------------------------
  // Instruction Fetch Unit
  //--------------------------------------------------------
  
   miv_rv32_fetch_unit
   #(
      .I_ADDR_WIDTH                     (I_ADDR_WIDTH                        )  ,
      .l_core_reset_vector              (l_core_reset_vector                 )
    )
    u_fetch_unit_0
    (
      .clk                                   (clk                                      ),
      .resetn                                (resetn & gpr_ram_init_done               ),
      .parity_en                             (parity_en                                ),
      .ifu_emi_req_valid                     (ifu_emi_req_valid                        ),
      .ifu_emi_req_ready                     (ifu_emi_req_ready                        ),
      .ifu_emi_req_rd_byte_en                (ifu_emi_req_rd_byte_en                   ),
      .ifu_emi_req_addr                      (ifu_emi_req_addr                         ),
      .ifu_emi_req_addr_p                    (ifu_emi_req_addr_p                       ),
      .ifu_emi_resp_valid                    (ifu_emi_resp_valid                       ),
      .ifu_emi_resp_ready                    (ifu_emi_resp_ready                       ),
      .ifu_emi_resp_data                     (ifu_emi_resp_data                        ),     
      .ifu_emi_resp_data_p                   (ifu_emi_resp_data_p                      ),
      .ifu_emi_resp_error                    (ifu_emi_resp_error                       ),
      
      .ifu_expipe_fetch_en                   (ifu_expipe_fetch_en_net                  ),
      .ifu_expipe_req_branch_excpt_req_valid (ifu_expipe_req_branch_excpt_req_valid_net),
      .ifu_expipe_req_branch_excpt_req_fenci (ifu_expipe_req_branch_excpt_req_fenci_net),
      .ifu_expipe_req_fenci_proceed          (ifu_expipe_req_fenci_proceed_net         ),
      .ifu_expipe_req_branch_excpt_req_ready (ifu_expipe_req_branch_excpt_req_ready_net),
      .ifu_expipe_req_branch_excpt_vaddr     (ifu_expipe_req_branch_excpt_vaddr_net    ),
      .ifu_expipe_req_priv                   (ifu_expipe_req_priv_net                  ),
      .ifu_expipe_req_flush                  (ifu_expipe_req_flush_net                 ),
      .ifu_expipe_resp_valid                 (ifu_expipe_resp_valid_net                ),
      .ifu_expipe_resp_ready                 (ifu_expipe_resp_ready_net                ), 
      .ifu_expipe_resp_ireg                  (ifu_expipe_resp_ireg_net                 ),
      .ifu_expipe_resp_ireg_vaddr            (ifu_expipe_resp_ireg_vaddr_net           ),
      .ifu_expipe_resp_ireg_vaddr_valid      (ifu_expipe_resp_ireg_vaddr_valid_net     ),
      .ifu_expipe_resp_next_vaddr            (ifu_expipe_resp_next_vaddr_net           ),
      .ifu_expipe_resp_compressed            (ifu_expipe_resp_compressed_net           ),
      .ifu_expipe_resp_access_fault          (ifu_expipe_resp_access_fault_net         ),
      .ifu_expipe_resp_access_mem_error      (ifu_expipe_resp_access_mem_error_net     ),
      .ifu_expipe_resp_access_parity_error   (ifu_expipe_resp_access_parity_error_net  ),
      .ifu_expipe_resp_access_misalign_error (ifu_expipe_resp_access_misalign_error_net),
      .ifu_expipe_resp_access_aborted        (ifu_expipe_resp_access_aborted_net       )
    );
  
  //--------------------------------------------------------
  // Load-Store Unit
  //--------------------------------------------------------
  
  miv_rv32_lsu
   #(                                               
      .D_ADDR_WIDTH                                 (I_ADDR_WIDTH                             ) 
    )
    u_lsu_0
    (                                               
      .clk                                          (clk                                      ),
      .resetn                                       (resetn                                   ),
      .parity_en                                    (parity_en                                ),
      .lsu_flush                                    (lsu_flush_net                            ),
      .lsu_op_os                                    (lsu_op_os_net                            ),
      .lsu_ld_op_os                                 (lsu_load_os_net                          ),
      .lsu_fence_op_os                              (lsu_fence_os_net                         ),
      .lsu_emi_req_valid                            (lsu_emi_req_valid                        ),
      .lsu_emi_req_ready                            (lsu_emi_req_ready                        ),
      .lsu_emi_req_rd_byte_en                       (lsu_emi_req_rd_byte_en                   ),
      .lsu_emi_req_wr_byte_en                       (lsu_emi_req_wr_byte_en                   ),
      .lsu_emi_req_addr                             (lsu_emi_req_addr                         ),      
      .lsu_emi_req_addr_p                           (lsu_emi_req_addr_p                       ),
      .lsu_emi_req_fence                            (lsu_emi_req_fence                        ),
      .lsu_emi_req_read                             (lsu_emi_req_read                         ),
      .lsu_emi_req_write                            (lsu_emi_req_write                        ),
      .lsu_emi_req_wr_data                          (lsu_emi_req_wr_data                      ),
      .lsu_emi_req_wr_data_p                        (lsu_emi_req_wr_data_p                    ),
      .lsu_emi_resp_valid                           (lsu_emi_resp_valid                       ),
      .lsu_emi_resp_ready                           (lsu_emi_resp_ready                       ),
      .lsu_emi_resp_error                           (lsu_emi_resp_error                       ),
      .lsu_emi_resp_rd_data                         (lsu_emi_resp_rd_data                     ),     
      .lsu_emi_resp_rd_data_p                       (lsu_emi_resp_rd_data_p                   ),
      .lsu_expipe_req_valid                         (lsu_expipe_req_valid_net                 ),
      .lsu_expipe_req_ready                         (lsu_expipe_req_ready_net                 ),
      .lsu_expipe_req_addr                          (lsu_expipe_req_addr_net                  ),
      .lsu_expipe_req_addr_valid                    (lsu_expipe_req_addr_valid_net            ),
      .lsu_expipe_req_wr_data                       (lsu_expipe_req_wr_data_net               ),
      .lsu_expipe_req_wr_data_valid                 (lsu_expipe_req_wr_data_valid_net         ),
      .lsu_expipe_req_op                            (lsu_expipe_req_op_net                    ),
      .lsu_expipe_resp_valid                        (lsu_expipe_resp_valid_net                ),
      .lsu_expipe_resp_ready                        (lsu_expipe_resp_ready_net                ),
      .lsu_expipe_resp_rd_data                      (lsu_expipe_resp_rd_data_net              ),
      .lsu_expipe_resp_ld_addr_misalign             (lsu_expipe_resp_ld_addr_misalign_net     ),
      .lsu_expipe_resp_ld_access_fault              (lsu_expipe_resp_ld_access_fault_net      ),
      .lsu_expipe_resp_str_amo_addr_misalign        (lsu_expipe_resp_str_amo_addr_misalign_net),
      .lsu_expipe_resp_str_amo_access_fault         (lsu_expipe_resp_str_amo_access_fault_net ),
      .lsu_expipe_resp_access_mem_error             (lsu_expipe_resp_access_mem_error_net     ),
      .lsu_expipe_resp_access_parity_error          (lsu_expipe_resp_access_parity_error_net  ),
      .lsu_expipe_resp_access_aborted               (lsu_expipe_resp_access_aborted_net       )
   );      

  
  //--------------------------------------------------------
  // Execution Pipeline Unit
  //--------------------------------------------------------
  
  miv_rv32_expipe
   #(
      .I_ADDR_WIDTH                          (I_ADDR_WIDTH                             ),
      .D_ADDR_WIDTH                          (D_ADDR_WIDTH                             ),
      .I_DATA_BYTES                          (I_DATA_BYTES                             ),
      .D_DATA_BYTES                          (D_DATA_BYTES                             ),
      .l_core_cfg_hw_debug              (l_core_cfg_hw_debug                 ),
      .l_core_cfg_num_triggers          (l_core_cfg_num_triggers             ),
      .l_core_cfg_hw_macc_multiplier    (l_core_cfg_hw_macc_multiplier       ),
      .l_core_cfg_hw_multiply_divide    (l_core_cfg_hw_multiply_divide       ),
      .l_core_cfg_hw_compressed         (l_core_cfg_hw_compressed            ),
      .l_core_reset_vector              (l_core_reset_vector                 ),
      .l_core_static_mtvec_base         (l_core_static_mtvec_base            ),
      .l_core_cfg_static_mtvec_base     (l_core_cfg_static_mtvec_base        ),
      .l_core_cfg_static_mtvec_mode     (l_core_cfg_static_mtvec_mode        ),
      .l_core_static_mtvec_mode         (l_core_static_mtvec_mode            ),
	  .l_core_num_sys_ext_irqs          (l_core_num_sys_ext_irqs             ),
	  .l_core_cfg_time_count_width      (l_core_cfg_time_count_width         ),
      .l_core_cfg_lsu_fwd               (l_core_cfg_lsu_fwd                  ),
      .l_core_cfg_csr_fwd               (l_core_cfg_csr_fwd                  ),
      .l_core_cfg_exu_fwd               (l_core_cfg_exu_fwd                  ),
	  .l_core_cfg_gpr_type              (l_core_cfg_gpr_type                 ),
	  .ECC_ENABLE                            (ECC_ENABLE                               )
    )
    u_expipe_0
    (
      .clk                                   (clk                                      ),
      .resetn                                (resetn                                   ),
      .core_soft_reset                       (core_soft_reset                          ),
      .gpr_uncorrectable_ecc_error           (gpr_uncorrectable_ecc_error              ),
      .time_count                            (time_count                               ),
      .hart_id                               (hart_id                                  ),
      .ifu_expipe_fetch_en                   (ifu_expipe_fetch_en_net                  ),
      .ifu_expipe_req_branch_excpt_req_valid (ifu_expipe_req_branch_excpt_req_valid_net),
      .ifu_expipe_req_branch_excpt_req_fenci (ifu_expipe_req_branch_excpt_req_fenci_net),
      .ifu_expipe_req_fenci_proceed          (ifu_expipe_req_fenci_proceed_net         ),
      .ifu_expipe_req_branch_excpt_req_ready (ifu_expipe_req_branch_excpt_req_ready_net),
      .ifu_expipe_req_branch_excpt_vaddr     (ifu_expipe_req_branch_excpt_vaddr_net    ),
      .ifu_expipe_req_priv                   (ifu_expipe_req_priv_net                  ),
      .ifu_expipe_req_flush                  (ifu_expipe_req_flush_net                 ),
      .ifu_expipe_resp_valid                 (ifu_expipe_resp_valid_net                ),
      .ifu_expipe_resp_ready                 (ifu_expipe_resp_ready_net                ),
      .ifu_expipe_resp_ireg                  (ifu_expipe_resp_ireg_net                 ),
      .ifu_expipe_resp_ireg_vaddr            (ifu_expipe_resp_ireg_vaddr_net           ),      
      .ifu_expipe_resp_ireg_vaddr_valid      (ifu_expipe_resp_ireg_vaddr_valid_net     ),
      .ifu_expipe_resp_next_vaddr            (ifu_expipe_resp_next_vaddr_net           ),
      .ifu_expipe_resp_compressed            (ifu_expipe_resp_compressed_net           ),
      .ifu_expipe_resp_access_fault          (ifu_expipe_resp_access_fault_net         ),
      .ifu_expipe_resp_access_mem_error      (ifu_expipe_resp_access_mem_error_net     ),
      .ifu_expipe_resp_access_parity_error   (ifu_expipe_resp_access_parity_error_net  ),
      .ifu_expipe_resp_access_misalign_error (ifu_expipe_resp_access_misalign_error_net),
      .ifu_expipe_resp_access_aborted        (ifu_expipe_resp_access_aborted_net       ),
      .lsu_flush                             (lsu_flush_net                            ),
      .lsu_op_os                             (lsu_op_os_net                            ),
      .lsu_ld_op_os                          (lsu_load_os_net                          ),
      .lsu_fence_op_os                       (lsu_fence_os_net                         ),
      .lsu_req_valid                         (lsu_expipe_req_valid_net                 ),
      .lsu_req_ready                         (lsu_expipe_req_ready_net                 ),
      .lsu_req_addr                          (lsu_expipe_req_addr_net                  ),
      .lsu_req_addr_valid                    (lsu_expipe_req_addr_valid_net            ),
      .lsu_req_wr_data                       (lsu_expipe_req_wr_data_net               ),
      .lsu_req_wr_data_valid                 (lsu_expipe_req_wr_data_valid_net         ),
      .lsu_req_op                            (lsu_expipe_req_op_net                    ),
      .lsu_resp_valid                        (lsu_expipe_resp_valid_net                ),
      .lsu_resp_ready                        (lsu_expipe_resp_ready_net                ),
      .lsu_resp_rd_data                      (lsu_expipe_resp_rd_data_net              ),
      .lsu_resp_ld_addr_misalign             (lsu_expipe_resp_ld_addr_misalign_net     ),
      .lsu_resp_ld_access_fault              (lsu_expipe_resp_ld_access_fault_net      ),
      .lsu_resp_str_amo_addr_misalign        (lsu_expipe_resp_str_amo_addr_misalign_net),
      .lsu_resp_str_amo_access_fault         (lsu_expipe_resp_str_amo_access_fault_net ),
      .lsu_resp_access_mem_error             (lsu_expipe_resp_access_mem_error_net     ),
      .lsu_resp_access_parity_error          (lsu_expipe_resp_access_parity_error_net  ),
      .lsu_resp_access_aborted               (lsu_expipe_resp_access_aborted_net       ),
      .debug_reset                           (debug_reset                              ),
      .debug_core_reset                      (debug_core_reset                         ),
      .debug_active                          (debug_active                             ),
      .debug_csr_gpr_req_wr_data             (debug_csr_gpr_req_wr_data                ), 
      .debug_csr_req_valid                   (debug_csr_req_valid                      ), 
      .debug_csr_req_ready                   (debug_csr_req_ready                      ), 
      .debug_csr_req_wr_en                   (debug_csr_req_wr_en                      ), 
      .debug_csr_req_rd_en                   (debug_csr_req_rd_en                      ), 
      .debug_csr_req_addr                    (debug_csr_req_addr                       ), 
      .debug_csr_resp_rd_data                (debug_csr_resp_rd_data                   ), 
      .debug_csr_resp_ready                  (debug_csr_resp_ready                     ), 
      .debug_csr_resp_valid                  (debug_csr_resp_valid                     ), 
      .debug_gpr_req_valid                   (debug_gpr_req_valid                      ), 
      .debug_gpr_req_ready                   (debug_gpr_req_ready                      ), 
      .debug_gpr_req_wr_en                   (debug_gpr_req_wr_en                      ), 
      .debug_gpr_req_rd_en                   (debug_gpr_req_rd_en                      ), 
      .debug_gpr_req_addr                    (debug_gpr_req_addr                       ), 
      .debug_gpr_resp_rd_data                (debug_gpr_resp_rd_data                   ), 
      .debug_gpr_resp_ready                  (debug_gpr_resp_ready                     ), 
      .debug_gpr_resp_valid                  (debug_gpr_resp_valid                     ), 
      .debug_halt_req                        (debug_halt_req                           ), 
      .debug_halt_ack                        (debug_halt_ack                           ), 
      .debug_resethalt_req                   (debug_resethalt_req                      ), 
      .debug_resethalt_ack                   (debug_resethalt_ack                      ), 
      .debug_resume_req                      (debug_resume_req                         ),
      .debug_resume_ack                      (debug_resume_ack                         ),
      .debug_mode                            (debug_mode                               ),
      .m_sw_irq                              (m_sw_irq                                 ),
      .m_timer_irq                           (m_timer_irq                              ),
      .m_external_irq                        (m_external_irq                           ),
      .sys_ext_irq_src                       (sys_ext_irq_src                          ),
	  .gpr_ram_init_done                     (gpr_ram_init_done                        ),
      .formal_trace_instr                    (formal_trace_instr                       ),
      .formal_trace_pc                       (formal_trace_pc                          ),
      .formal_trace_reset_taken              (formal_trace_reset_taken                 ),
      .formal_trace_instr_retire             (formal_trace_instr_retire                )
    );
      
      
      
 

     

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

`endif

 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_csr_decode.sv
//
//   Purpose:   decoder for csr registers
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module  miv_rv32_csr_decode
//********************************************************************************
// Parameter description
  #(
      CHECK_ILLEGAL = 0,
	  l_core_cfg_hw_debug           = 0
  )

//********************************************************************************
// Port description

  (
    //inputs
    input wire logic                clk,
    input wire logic                resetn,
    
    input wire logic                debug_mode,
    input wire logic [11:0]         csr_rd_addr,
    input wire logic                csr_rd_en_valid,   
    input wire logic [11:0]         csr_wr_addr,
    input wire logic                csr_wr_en_valid,
    
    output t_csr_reg_rd_sel         csr_reg_rd_sel,
    output t_csr_reg_wr_sel         csr_reg_wr_sel,
    output logic                    csr_rd_illegal,  
    output logic                    csr_wr_illegal
    
  );
    

                        

//********************************************************************************
// localparams
  

// Declarations



  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  assign csr_reg_rd_sel.mvendorid_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mvendorid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mvendorid_sw_wr_sel = 1'b0;  // read only
  
  assign csr_reg_rd_sel.marchid_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_marchid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.marchid_sw_wr_sel   = 1'b0;  // read only 

  assign csr_reg_rd_sel.mimpid_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_mimpid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mimpid_sw_wr_sel    = 1'b0;  // read only 
  
  assign csr_reg_rd_sel.mhartid_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mhartid) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mhartid_sw_wr_sel   = 1'b0;  // read only
    
  // term does not need to check privilege as core only supports machine mode                      
  assign csr_reg_rd_sel.mstatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mstatus) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.sstatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_sstatus) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.ustatus_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_ustatus) && csr_rd_en_valid;                          
  assign csr_reg_wr_sel.mstatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mstatus) && csr_wr_en_valid; 
  assign csr_reg_wr_sel.sstatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_sstatus) && csr_wr_en_valid;  
  assign csr_reg_wr_sel.ustatus_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_ustatus) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.misa_sw_rd_sel      = (csr_rd_addr == l_core_csr_addr_misa) && csr_rd_en_valid;
  assign csr_reg_wr_sel.misa_sw_wr_sel      = (csr_wr_addr == l_core_csr_addr_misa) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.medeleg_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_medeleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.medeleg_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_medeleg) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mideleg_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mideleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mideleg_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mideleg) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_mie) && csr_rd_en_valid;  
  assign csr_reg_rd_sel.sie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_sie) && csr_rd_en_valid;  
  assign csr_reg_rd_sel.uie_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_uie) && csr_rd_en_valid;                     
  assign csr_reg_wr_sel.mie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_mie) && csr_wr_en_valid;
  assign csr_reg_wr_sel.sie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_sie) && csr_wr_en_valid;
  assign csr_reg_wr_sel.uie_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_uie) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.mip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_mip) && csr_rd_en_valid;
  assign csr_reg_rd_sel.sip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_sip) && csr_rd_en_valid;
  assign csr_reg_rd_sel.uip_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_uip) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.ip_sw_rd_sel     = csr_reg_rd_sel.mip_sw_rd_sel | csr_reg_rd_sel.sip_sw_rd_sel | csr_reg_rd_sel.uip_sw_rd_sel;                           
  assign csr_reg_wr_sel.mip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_mip) && csr_wr_en_valid;
  assign csr_reg_wr_sel.sip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_sip) && csr_wr_en_valid;
  assign csr_reg_wr_sel.uip_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_uip) && csr_wr_en_valid;  
  assign csr_reg_wr_sel.ip_sw_wr_sel     = 1'b0; 
  
  assign csr_reg_rd_sel.mtvec_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mtvec) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mtvec_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mtvec) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mepc_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_mepc) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mepc_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_mepc) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mcause_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcause) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcause_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcause) && csr_wr_en_valid ; 
  
  assign csr_reg_rd_sel.mtval_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mtval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mtval_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mtval) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.mcounteren_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcounteren) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcounteren_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcounteren) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mcounterinhibit_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcounterinhibit) && csr_rd_en_valid ;
  assign csr_reg_wr_sel.mcounterinhibit_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcounterinhibit) && csr_wr_en_valid ;
  
  assign csr_reg_rd_sel.mscratch_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.mscratch_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mscratch) && csr_wr_en_valid; 
  
  assign csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel = ({csr_rd_addr[11:2],2'b00} == (l_core_csr_addr_pmpcfg0 & 12'hFFC)) && csr_rd_en_valid;
  assign csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel = ({csr_wr_addr[11:2],2'b00} == (l_core_csr_addr_pmpcfg0 & 12'hFFC)) && csr_wr_en_valid;
  assign csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel = ({csr_rd_addr[11:4],4'b0000} == (l_core_csr_addr_pmpaddr0 & 12'hFF0)) && csr_rd_en_valid;
  assign csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel = ({csr_wr_addr[11:4],4'b0000} == (l_core_csr_addr_pmpaddr0 & 12'hFF0)) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.sedeleg_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_sedeleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sedeleg_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_sedeleg) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sideleg_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_sideleg) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sideleg_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_sideleg) && csr_wr_en_valid;
  assign csr_reg_rd_sel.stvec_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_stvec) && csr_rd_en_valid;
  assign csr_reg_wr_sel.stvec_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_stvec) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sepc_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_sepc) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sepc_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_sepc) && csr_wr_en_valid;
  assign csr_reg_rd_sel.scause_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_scause) && csr_rd_en_valid;
  assign csr_reg_wr_sel.scause_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_scause) && csr_wr_en_valid;
  assign csr_reg_rd_sel.stval_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_stval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.stval_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_stval) && csr_wr_en_valid;
  assign csr_reg_rd_sel.scounteren_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_scounteren) && csr_rd_en_valid;
  assign csr_reg_wr_sel.scounteren_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_scounteren) && csr_wr_en_valid;
  assign csr_reg_rd_sel.sscratch_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_sscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.sscratch_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_sscratch) && csr_wr_en_valid;
  assign csr_reg_rd_sel.satp_sw_rd_sel       = (csr_rd_addr == l_core_csr_addr_satp) && csr_rd_en_valid;
  assign csr_reg_wr_sel.satp_sw_wr_sel       = (csr_wr_addr == l_core_csr_addr_satp) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.utvec_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_utvec) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utvec_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_utvec) && csr_wr_en_valid;
  assign csr_reg_rd_sel.uepc_sw_rd_sel     = (csr_rd_addr == l_core_csr_addr_uepc) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uepc_sw_wr_sel     = (csr_wr_addr == l_core_csr_addr_uepc) && csr_wr_en_valid;
  assign csr_reg_rd_sel.ucause_sw_rd_sel   = (csr_rd_addr == l_core_csr_addr_ucause) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucause_sw_wr_sel   = (csr_wr_addr == l_core_csr_addr_ucause) && csr_wr_en_valid;
  assign csr_reg_rd_sel.utval_sw_rd_sel    = (csr_rd_addr == l_core_csr_addr_utval) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utval_sw_wr_sel    = (csr_wr_addr == l_core_csr_addr_utval) && csr_wr_en_valid;
  assign csr_reg_rd_sel.uscratch_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_uscratch) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uscratch_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_uscratch) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.ucycle_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_cycle) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.mcycle_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_mcycle) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucycle_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_cycle) && csr_wr_en_valid;  // illegal
  assign csr_reg_wr_sel.mcycle_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_mcycle) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.ucycleh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_cycleh) && csr_rd_en_valid;
  assign csr_reg_rd_sel.mcycleh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_mcycleh) && csr_rd_en_valid;
  assign csr_reg_wr_sel.ucycleh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_cycleh) && csr_wr_en_valid; // illegal
  assign csr_reg_wr_sel.mcycleh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_mcycleh) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.utime_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_time) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utime_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_time) && csr_wr_en_valid; 
  assign csr_reg_rd_sel.utimeh_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_timeh) && csr_rd_en_valid;
  assign csr_reg_wr_sel.utimeh_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_timeh) && csr_wr_en_valid;  
  
  assign csr_reg_rd_sel.uinstret_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_instret) && csr_rd_en_valid; 
  assign csr_reg_rd_sel.minstret_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_minstret) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uinstret_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_instret) && csr_wr_en_valid;  // illegal
  assign csr_reg_wr_sel.minstret_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_minstret) && csr_wr_en_valid; 
  assign csr_reg_rd_sel.uinstreth_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_instreth) && csr_rd_en_valid;
  assign csr_reg_rd_sel.minstreth_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_minstreth) && csr_rd_en_valid;
  assign csr_reg_wr_sel.uinstreth_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_instreth) && csr_wr_en_valid; // illegal
  assign csr_reg_wr_sel.minstreth_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_minstreth) && csr_wr_en_valid;
  
  assign csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounter3 & 12'hFE0)) && 
                                                      (csr_rd_addr != l_core_csr_addr_cycle) &&
                                                      (csr_rd_addr != l_core_csr_addr_time) &&
                                                      (csr_rd_addr != l_core_csr_addr_instret) &&
                                                      csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounter3 & 12'hFE0)) && 
                                                     (csr_wr_addr != l_core_csr_addr_cycle) &&
                                                     (csr_wr_addr != l_core_csr_addr_time) &&
                                                     (csr_wr_addr != l_core_csr_addr_instret) && 
                                                     csr_wr_en_valid;
  assign csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounterh3 & 12'hFE0)) && 
                                                       (csr_rd_addr != l_core_csr_addr_cycleh) &&
                                                       (csr_rd_addr != l_core_csr_addr_timeh) &&
                                                       (csr_rd_addr != l_core_csr_addr_instreth) &&
                                                       csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_hpmcounterh3 & 12'hFE0)) && 
                                                      (csr_wr_addr != l_core_csr_addr_cycleh) &&
                                                      (csr_wr_addr != l_core_csr_addr_timeh) &&
                                                      (csr_wr_addr != l_core_csr_addr_instreth) && 
                                                      csr_wr_en_valid;     
  assign csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounter3 & 12'hFE0)) && 
                                                      (csr_rd_addr != 12'hB00) &&
                                                      (csr_rd_addr != 12'hB01) &&
                                                      (csr_rd_addr != 12'hB02) &&
                                                      csr_rd_en_valid;
  assign csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounter3 & 12'hFE0)) && 
                                                      (csr_wr_addr != 12'hB00) &&
                                                      (csr_wr_addr != 12'hB01) &&
                                                      (csr_wr_addr != 12'hB02) && 
                                                      csr_wr_en_valid;                                    
  assign csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounterh3 & 12'hFE0)) && 
                                                       (csr_rd_addr != 12'hB80) &&
                                                       (csr_rd_addr != 12'hB81) &&
                                                       (csr_rd_addr != 12'hB82) &&
                                                       csr_rd_en_valid;
  assign csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmcounterh3 & 12'hFE0)) && 
                                                       (csr_wr_addr != 12'hB80) &&
                                                       (csr_wr_addr != 12'hB81) &&
                                                       (csr_wr_addr != 12'hB82) && 
                                                       csr_wr_en_valid;     

  assign csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel = ({csr_rd_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmevent3 & 12'hFE0)) && 
                                                   (csr_rd_addr != 12'h320) &&
                                                   (csr_rd_addr != 12'h321) &&
                                                   (csr_rd_addr != 12'h322) &&
                                                   csr_rd_en_valid;
  assign csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel = ({csr_wr_addr[11:5],5'b00000} == (l_core_csr_addr_mhpmevent3 & 12'hFE0)) && 
                                                   (csr_wr_addr != 12'h320) &&
                                                   (csr_wr_addr != 12'h321) &&
                                                   (csr_wr_addr != 12'h322) &&
                                                   csr_wr_en_valid;  
                                                   
                                                   

  assign csr_reg_rd_sel.tselect_sw_rd_sel = (csr_rd_addr == l_core_csr_addr_tselect) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tselect_sw_wr_sel = (csr_wr_addr == l_core_csr_addr_tselect) && csr_wr_en_valid;
  assign csr_reg_rd_sel.tdata1_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata1) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata1_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata1) && csr_wr_en_valid;
  assign csr_reg_rd_sel.tdata2_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata2) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata2_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata2) && csr_wr_en_valid;      
  assign csr_reg_rd_sel.tdata3_sw_rd_sel  = (csr_rd_addr == l_core_csr_addr_tdata3) && csr_rd_en_valid;
  assign csr_reg_wr_sel.tdata3_sw_wr_sel  = (csr_wr_addr == l_core_csr_addr_tdata3) && csr_wr_en_valid;  

  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug  
    assign csr_reg_rd_sel.dcsr_debugger_rd_sel       = (csr_rd_addr == l_core_csr_addr_dcsr) & csr_rd_en_valid & debug_mode; 
    assign csr_reg_wr_sel.dcsr_debugger_wr_sel       = (csr_wr_addr == l_core_csr_addr_dcsr) & csr_wr_en_valid & debug_mode; 
    assign csr_reg_rd_sel.dpc_debugger_rd_sel        = (csr_rd_addr == l_core_csr_addr_dpc)  & csr_rd_en_valid & debug_mode;
    assign csr_reg_wr_sel.dpc_debugger_wr_sel        = (csr_wr_addr == l_core_csr_addr_dpc)  & csr_wr_en_valid & debug_mode;
    assign csr_reg_rd_sel.dscratch0_debugger_rd_sel  = (csr_rd_addr == l_core_csr_addr_dscratch0) & csr_rd_en_valid & debug_mode;
    assign csr_reg_wr_sel.dscratch0_debugger_wr_sel  = (csr_wr_addr == l_core_csr_addr_dscratch0) & csr_wr_en_valid & debug_mode;
    assign csr_reg_rd_sel.dscratch1_debugger_rd_sel  = (csr_rd_addr == l_core_csr_addr_dscratch1) & csr_rd_en_valid & debug_mode; 
    assign csr_reg_wr_sel.dscratch1_debugger_wr_sel  = (csr_wr_addr == l_core_csr_addr_dscratch1) & csr_wr_en_valid & debug_mode; 
  end else begin : ngen_debug           
    assign csr_reg_rd_sel.dcsr_debugger_rd_sel       = 1'b0;
    assign csr_reg_wr_sel.dcsr_debugger_wr_sel       = 1'b0;
    assign csr_reg_rd_sel.dpc_debugger_rd_sel        = 1'b0;
    assign csr_reg_wr_sel.dpc_debugger_wr_sel        = 1'b0;
    assign csr_reg_rd_sel.dscratch0_debugger_rd_sel  = 1'b0;
    assign csr_reg_wr_sel.dscratch0_debugger_wr_sel  = 1'b0;
    assign csr_reg_rd_sel.dscratch1_debugger_rd_sel  = 1'b0;
    assign csr_reg_wr_sel.dscratch1_debugger_wr_sel  = 1'b0; 
  end 
  endgenerate     
  
  generate 
  if(CHECK_ILLEGAL) begin :gen_check_illegal  
  
    logic                    rd_legal_csr;
    logic                    rd_legal_csr_debug;
    logic                    illegal_wr_read_only;
    logic                    wr_legal_csr;
    logic                    wr_legal_csr_debug;     
  
  
    assign rd_legal_csr = csr_reg_rd_sel.mvendorid_sw_rd_sel |
                          csr_reg_rd_sel.marchid_sw_rd_sel |                       
                          csr_reg_rd_sel.mimpid_sw_rd_sel |
                          csr_reg_rd_sel.mhartid_sw_rd_sel |
                          csr_reg_rd_sel.mstatus_sw_rd_sel |
                          csr_reg_rd_sel.sstatus_sw_rd_sel |
                          csr_reg_rd_sel.ustatus_sw_rd_sel |
                          csr_reg_rd_sel.misa_sw_rd_sel |
                          csr_reg_rd_sel.medeleg_sw_rd_sel |
                          csr_reg_rd_sel.mideleg_sw_rd_sel |
                          csr_reg_rd_sel.mie_sw_rd_sel |
                          csr_reg_rd_sel.sie_sw_rd_sel |
                          csr_reg_rd_sel.uie_sw_rd_sel |
                          csr_reg_rd_sel.mip_sw_rd_sel |
                          csr_reg_rd_sel.sip_sw_rd_sel |
                          csr_reg_rd_sel.uip_sw_rd_sel |
                          csr_reg_rd_sel.mtvec_sw_rd_sel |
                          csr_reg_rd_sel.mepc_sw_rd_sel |
                          csr_reg_rd_sel.mcause_sw_rd_sel |
                          csr_reg_rd_sel.mtval_sw_rd_sel |
                          csr_reg_rd_sel.mcounterinhibit_sw_rd_sel |
                          csr_reg_rd_sel.mcounteren_sw_rd_sel |
                          csr_reg_rd_sel.mscratch_sw_rd_sel |
                          csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel |
                          csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel |
                          csr_reg_rd_sel.sideleg_sw_rd_sel |
                          csr_reg_rd_sel.sedeleg_sw_rd_sel |
                          csr_reg_rd_sel.stvec_sw_rd_sel |
                          csr_reg_rd_sel.sepc_sw_rd_sel |
                          csr_reg_rd_sel.scause_sw_rd_sel |
                          csr_reg_rd_sel.stval_sw_rd_sel | 
                          csr_reg_rd_sel.scounteren_sw_rd_sel |
                          csr_reg_rd_sel.sscratch_sw_rd_sel |
                          csr_reg_rd_sel.satp_sw_rd_sel |
                          csr_reg_rd_sel.utvec_sw_rd_sel |
                          csr_reg_rd_sel.uepc_sw_rd_sel |
                          csr_reg_rd_sel.ucause_sw_rd_sel |
                          csr_reg_rd_sel.utval_sw_rd_sel | 
                          csr_reg_rd_sel.uscratch_sw_rd_sel |
                          csr_reg_rd_sel.ucycle_sw_rd_sel |
                          csr_reg_rd_sel.ucycleh_sw_rd_sel |
                          csr_reg_rd_sel.mcycle_sw_rd_sel |
                          csr_reg_rd_sel.mcycleh_sw_rd_sel |
                          csr_reg_rd_sel.utime_sw_rd_sel |
                          csr_reg_rd_sel.utimeh_sw_rd_sel |
                          csr_reg_rd_sel.uinstret_sw_rd_sel |
                          csr_reg_rd_sel.uinstreth_sw_rd_sel |
                          csr_reg_rd_sel.minstret_sw_rd_sel |
                          csr_reg_rd_sel.minstreth_sw_rd_sel |                       
                          csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel |
                          csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel |                      
                          csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel |
                          csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel |
                          csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel |
                          csr_reg_rd_sel.tselect_sw_rd_sel |
                          csr_reg_rd_sel.tdata1_sw_rd_sel |
                          csr_reg_rd_sel.tdata2_sw_rd_sel |
                          csr_reg_rd_sel.tdata3_sw_rd_sel;    
                          
    assign rd_legal_csr_debug  = rd_legal_csr |
                                 csr_reg_rd_sel.dcsr_debugger_rd_sel |
                                 csr_reg_rd_sel.dpc_debugger_rd_sel |
                                 csr_reg_rd_sel.dscratch0_debugger_rd_sel |
                                 csr_reg_rd_sel.dscratch1_debugger_rd_sel; 
                                  
    assign csr_rd_illegal      =  csr_rd_en_valid & (debug_mode ? ~rd_legal_csr_debug : ~rd_legal_csr); 
  
    assign illegal_wr_read_only = csr_reg_wr_sel.mvendorid_sw_wr_sel |
                                  csr_reg_wr_sel.marchid_sw_wr_sel |         
                                  csr_reg_wr_sel.mimpid_sw_wr_sel |          
                                  csr_reg_wr_sel.mhartid_sw_wr_sel |         
                                  csr_reg_wr_sel.ucycle_sw_wr_sel |          
                                  csr_reg_wr_sel.ucycleh_sw_wr_sel |         
                                  csr_reg_wr_sel.utime_sw_wr_sel |           
                                  csr_reg_wr_sel.utimeh_sw_wr_sel |          
                                  csr_reg_wr_sel.uinstret_sw_wr_sel |        
                                  csr_reg_wr_sel.uinstreth_sw_wr_sel |       
                                  csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel | 
                                  csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel; 
                           
    assign wr_legal_csr =  csr_reg_wr_sel.mstatus_sw_wr_sel |
                           csr_reg_wr_sel.sstatus_sw_wr_sel |
                           csr_reg_wr_sel.ustatus_sw_wr_sel |
                           csr_reg_wr_sel.misa_sw_wr_sel |
                           csr_reg_wr_sel.medeleg_sw_wr_sel |
                           csr_reg_wr_sel.mideleg_sw_wr_sel |
                           csr_reg_wr_sel.mie_sw_wr_sel |
                           csr_reg_wr_sel.sie_sw_wr_sel |
                           csr_reg_wr_sel.uie_sw_wr_sel |
                           csr_reg_wr_sel.mip_sw_wr_sel |
                           csr_reg_wr_sel.sip_sw_wr_sel |
                           csr_reg_wr_sel.uip_sw_wr_sel |
                           csr_reg_wr_sel.mtvec_sw_wr_sel |
                           csr_reg_wr_sel.mepc_sw_wr_sel |
                           csr_reg_wr_sel.mcause_sw_wr_sel |
                           csr_reg_wr_sel.mtval_sw_wr_sel |
                           csr_reg_wr_sel.mcounterinhibit_sw_wr_sel |
                           csr_reg_wr_sel.mcounteren_sw_wr_sel |
                           csr_reg_wr_sel.mscratch_sw_wr_sel |
                           csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel |
                           csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel |
                           csr_reg_wr_sel.sideleg_sw_wr_sel |
                           csr_reg_wr_sel.sedeleg_sw_wr_sel |
                           csr_reg_wr_sel.stvec_sw_wr_sel |
                           csr_reg_wr_sel.sepc_sw_wr_sel |
                           csr_reg_wr_sel.scause_sw_wr_sel |
                           csr_reg_wr_sel.stval_sw_wr_sel | 
                           csr_reg_wr_sel.scounteren_sw_wr_sel |
                           csr_reg_wr_sel.sscratch_sw_wr_sel |
                           csr_reg_wr_sel.satp_sw_wr_sel |
                           csr_reg_wr_sel.utvec_sw_wr_sel |
                           csr_reg_wr_sel.uepc_sw_wr_sel |
                           csr_reg_wr_sel.ucause_sw_wr_sel |
                           csr_reg_wr_sel.utval_sw_wr_sel | 
                           csr_reg_wr_sel.uscratch_sw_wr_sel |
                           csr_reg_wr_sel.mcycle_sw_wr_sel |
                           csr_reg_wr_sel.mcycleh_sw_wr_sel |
                           csr_reg_wr_sel.minstret_sw_wr_sel |
                           csr_reg_wr_sel.minstreth_sw_wr_sel |
                           csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel |
                           csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel |
                           csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel |
                           csr_reg_wr_sel.tselect_sw_wr_sel |
                           csr_reg_wr_sel.tdata1_sw_wr_sel |
                           csr_reg_wr_sel.tdata2_sw_wr_sel |
                           csr_reg_wr_sel.tdata3_sw_wr_sel;   
                           
    assign wr_legal_csr_debug   = wr_legal_csr |
                                  csr_reg_wr_sel.dcsr_debugger_wr_sel |
                                  csr_reg_wr_sel.dpc_debugger_wr_sel |
                                  csr_reg_wr_sel.dscratch0_debugger_wr_sel |
                                  csr_reg_wr_sel.dscratch1_debugger_wr_sel;  
                         
    // use non-trap masked version as illegal is a term in trap generation                       
    assign csr_wr_illegal = csr_wr_en_valid & (illegal_wr_read_only | ( debug_mode ? ~wr_legal_csr_debug : ~wr_legal_csr));
    
  end
  else begin :ngen_check_illegal
  
    assign csr_rd_illegal = 1'b0;
    assign csr_wr_illegal = 1'b0;
  
  end
  endgenerate
  
// properties
`ifdef miv_rv32_RTL_PROPS

  // should only be up to one read request
  assert_csr_priv_rd_sel_onehot0 : assert property (@(posedge clk) disable iff (~resetn)
                         csr_rd_en_valid |-> $onehot0({csr_reg_rd_sel.mvendorid_sw_rd_sel,
                                                      csr_reg_rd_sel.marchid_sw_rd_sel,     
                                                      csr_reg_rd_sel.mimpid_sw_rd_sel,
                                                      csr_reg_rd_sel.mhartid_sw_rd_sel,
                                                      csr_reg_rd_sel.mstatus_sw_rd_sel,
                                                      csr_reg_rd_sel.sstatus_sw_rd_sel,
                                                      csr_reg_rd_sel.ustatus_sw_rd_sel,
                                                      csr_reg_rd_sel.misa_sw_rd_sel,
                                                      csr_reg_rd_sel.medeleg_sw_rd_sel,
                                                      csr_reg_rd_sel.mideleg_sw_rd_sel,
                                                      csr_reg_rd_sel.mie_sw_rd_sel,
                                                      csr_reg_rd_sel.sie_sw_rd_sel,
                                                      csr_reg_rd_sel.uie_sw_rd_sel,
                                                      csr_reg_rd_sel.mip_sw_rd_sel,
                                                      csr_reg_rd_sel.sip_sw_rd_sel,
                                                      csr_reg_rd_sel.uip_sw_rd_sel,
                                                      csr_reg_rd_sel.mtvec_sw_rd_sel,
                                                      csr_reg_rd_sel.mepc_sw_rd_sel,
                                                      csr_reg_rd_sel.mcause_sw_rd_sel,
                                                      csr_reg_rd_sel.mtval_sw_rd_sel,
                                                      csr_reg_rd_sel.mcounteren_sw_rd_sel,
                                                      csr_reg_rd_sel.mcounterinhibit_sw_rd_sel,
                                                      csr_reg_rd_sel.mscratch_sw_rd_sel,
                                                      csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel,
                                                      csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel,
                                                      csr_reg_rd_sel.sideleg_sw_rd_sel ,
                                                      csr_reg_rd_sel.sedeleg_sw_rd_sel ,
                                                      csr_reg_rd_sel.stvec_sw_rd_sel ,
                                                      csr_reg_rd_sel.sepc_sw_rd_sel ,
                                                      csr_reg_rd_sel.scause_sw_rd_sel ,
                                                      csr_reg_rd_sel.stval_sw_rd_sel , 
                                                      csr_reg_rd_sel.scounteren_sw_rd_sel ,
                                                      csr_reg_rd_sel.sscratch_sw_rd_sel ,
                                                      csr_reg_rd_sel.satp_sw_rd_sel ,
                                                      csr_reg_rd_sel.utvec_sw_rd_sel ,
                                                      csr_reg_rd_sel.uepc_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucause_sw_rd_sel ,
                                                      csr_reg_rd_sel.utval_sw_rd_sel , 
                                                      csr_reg_rd_sel.uscratch_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucycle_sw_rd_sel ,
                                                      csr_reg_rd_sel.ucycleh_sw_rd_sel ,
                                                      csr_reg_rd_sel.mcycle_sw_rd_sel ,
                                                      csr_reg_rd_sel.mcycleh_sw_rd_sel ,
                                                      csr_reg_rd_sel.utime_sw_rd_sel ,
                                                      csr_reg_rd_sel.utimeh_sw_rd_sel ,
                                                      csr_reg_rd_sel.uinstret_sw_rd_sel ,
                                                      csr_reg_rd_sel.uinstreth_sw_rd_sel ,
                                                      csr_reg_rd_sel.minstret_sw_rd_sel ,
                                                      csr_reg_rd_sel.minstreth_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmcounter_3_31_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmcounter_3_31h_sw_rd_sel ,
                                                      csr_reg_rd_sel.mhpmcounter_3_31_sw_rd_sel ,
                                                      csr_reg_rd_sel.mhpmcounter_3_31h_sw_rd_sel ,
                                                      csr_reg_rd_sel.hpmevent_3_31_sw_rd_sel,
                                                      csr_reg_rd_sel.tselect_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata1_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata2_sw_rd_sel,
                                                      csr_reg_rd_sel.tdata3_sw_rd_sel})); 
  
  // should only be up to one write request
  assert_csr_priv_wr_sel_onehot0 : assert property (@(posedge clk) disable iff (~resetn)
                         csr_wr_en_valid |-> $onehot0({csr_reg_wr_sel.mvendorid_sw_wr_sel,
                                                      csr_reg_wr_sel.marchid_sw_wr_sel,     
                                                      csr_reg_wr_sel.mimpid_sw_wr_sel,
                                                      csr_reg_wr_sel.mhartid_sw_wr_sel,
                                                      csr_reg_wr_sel.mstatus_sw_wr_sel,
                                                      csr_reg_wr_sel.sstatus_sw_wr_sel,
                                                      csr_reg_wr_sel.ustatus_sw_wr_sel,
                                                      csr_reg_wr_sel.misa_sw_wr_sel,
                                                      csr_reg_wr_sel.medeleg_sw_wr_sel,
                                                      csr_reg_wr_sel.mideleg_sw_wr_sel,
                                                      csr_reg_wr_sel.mie_sw_wr_sel,
                                                      csr_reg_wr_sel.sie_sw_wr_sel,
                                                      csr_reg_wr_sel.uie_sw_wr_sel,
                                                      csr_reg_wr_sel.mip_sw_wr_sel,
                                                      csr_reg_wr_sel.sip_sw_wr_sel,
                                                      csr_reg_wr_sel.uip_sw_wr_sel,
                                                      csr_reg_wr_sel.mtvec_sw_wr_sel,
                                                      csr_reg_wr_sel.mepc_sw_wr_sel,
                                                      csr_reg_wr_sel.mcause_sw_wr_sel,
                                                      csr_reg_wr_sel.mtval_sw_wr_sel,
                                                      csr_reg_wr_sel.mcounteren_sw_wr_sel,
                                                      csr_reg_wr_sel.mcounterinhibit_sw_wr_sel,
                                                      csr_reg_wr_sel.mscratch_sw_wr_sel,
                                                      csr_reg_wr_sel.pmpcfg_0_3_sw_wr_sel,
                                                      csr_reg_wr_sel.pmpaddr_0_15_sw_wr_sel ,
                                                      csr_reg_wr_sel.sideleg_sw_wr_sel ,
                                                      csr_reg_wr_sel.sedeleg_sw_wr_sel ,
                                                      csr_reg_wr_sel.stvec_sw_wr_sel ,
                                                      csr_reg_wr_sel.sepc_sw_wr_sel ,
                                                      csr_reg_wr_sel.scause_sw_wr_sel ,
                                                      csr_reg_wr_sel.stval_sw_wr_sel , 
                                                      csr_reg_wr_sel.scounteren_sw_wr_sel ,
                                                      csr_reg_wr_sel.sscratch_sw_wr_sel ,
                                                      csr_reg_wr_sel.satp_sw_wr_sel,
                                                      csr_reg_wr_sel.utvec_sw_wr_sel ,
                                                      csr_reg_wr_sel.uepc_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucause_sw_wr_sel ,
                                                      csr_reg_wr_sel.utval_sw_wr_sel , 
                                                      csr_reg_wr_sel.uscratch_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucycle_sw_wr_sel ,
                                                      csr_reg_wr_sel.ucycleh_sw_wr_sel ,
                                                      csr_reg_wr_sel.mcycle_sw_wr_sel ,
                                                      csr_reg_wr_sel.mcycleh_sw_wr_sel ,
                                                      csr_reg_wr_sel.utime_sw_wr_sel ,
                                                      csr_reg_wr_sel.utimeh_sw_wr_sel ,
                                                      csr_reg_wr_sel.uinstret_sw_wr_sel ,
                                                      csr_reg_wr_sel.uinstreth_sw_wr_sel ,
                                                      csr_reg_wr_sel.minstret_sw_wr_sel ,
                                                      csr_reg_wr_sel.minstreth_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmcounter_3_31_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmcounter_3_31h_sw_wr_sel ,
                                                      csr_reg_wr_sel.mhpmcounter_3_31_sw_wr_sel ,
                                                      csr_reg_wr_sel.mhpmcounter_3_31h_sw_wr_sel ,
                                                      csr_reg_wr_sel.hpmevent_3_31_sw_wr_sel,
                                                      csr_reg_wr_sel.tselect_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata1_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata2_sw_wr_sel,
                                                      csr_reg_wr_sel.tdata3_sw_wr_sel})); 
                                                     
`endif                                                      
                                                                                                          
                                                                                                                               
endmodule


`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
// v1.1 HW trigger re-enabled, DPC updated for debug entry on HW trigger
// see assign implicit_wr_dpc_pc_wr_data  = trigger_debug_enter_taken ? excpt_trigger_dpc : // <CL> Update dpc on trigger_debug_enter_taken
// HW Trigger re-enabled (tselect)
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_csr_privarch.sv
//
//   Purpose: Core CSRs and privileged state
//
//   Author: 
//
//   Version: 1.1
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_csr_privarch
  //****************************************************************************
  // Parameter description
  #(parameter I_ADDR_WIDTH                         = 16,
	parameter l_core_cfg_hw_debug                  = 0,
    parameter l_core_cfg_num_triggers              = 0,
    parameter l_core_cfg_trigger_bus_width         = 0,
    parameter l_core_cfg_hw_multiply_divide        = 0,
    parameter l_core_cfg_hw_compressed             = 0,
    parameter l_core_reset_vector                  = 32'h6000_0000,
    parameter l_core_static_mtvec_base             = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base         = 0,
    parameter l_core_cfg_static_mtvec_mode         = 0,
    parameter l_core_static_mtvec_mode             = 0,
	parameter l_core_num_sys_ext_irqs              = 7,
	parameter l_core_cfg_time_count_width          = 0,
    parameter l_core_cfg_gpr_ecc_uncorrectable_irq = 0,
    parameter l_core_cfg_gpr_ecc_correctable_irq   = 0
   )


  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                              clk,
  input  wire logic                              resetn,                            
  input  wire logic                              soft_reset, 
  input  wire logic                              debug_soft_reset,   
  input  wire logic                              debug_reset,   
// hart configuration
  input  wire logic [L_XLEN-1:0]                 hart_id, 
// instruction (pipeline) status 
  input  wire logic                              cycle_executed,
  input  wire logic [(L_XLEN*2)-1:0]             time_count, 
  input  wire logic                              instr_retired, 
  
  input  wire logic                              instr_wfi, 
  
  input  wire logic                              instr_completing_retr,
  input  wire logic                              instr_valid_retr, 
  input  wire logic                              instr_lsu_op_retr, 
  input  wire logic                              lsu_op_os,
  output logic                                   wfi_waiting, 
  output logic                                   irq_stall_lsu_req,  
  output logic                                   irq_abort_lsu_req, 
  input  wire logic                              flush,
// GPR/immediate data path for sw writes  
  input wire  logic [L_XLEN-1:0]                 csr_op_gpr_imm,            
  input wire  logic                              csr_op_gpr_imm_valid, 
  output logic [L_XLEN-1:0]                      csr_op_rd_data,   
  output logic                                   csr_op_rd_data_valid,               
  output logic                                   csr_op_ready, 
// control path for csr operations
  input wire  t_csr_alu_wr_op_sel                csr_alu_wr_op_sel,  
  input wire  t_csr_alu_rd_op_sel                csr_alu_rd_op_sel,           
  input  wire logic [11:0]                       csr_op_addr,
  input  wire logic                              csr_op_addr_valid,   
// implicit read/write signals
  input  wire logic                              ext_msip,
  input  wire logic                              ext_mtip,
  input  wire logic                              ext_meip,    
  input  wire logic [7:0]                        sys_ext_irq_src,              
  input  wire logic                              gpr_uncorrectable_ecc_irq_src,
  input  wire logic                              gpr_correctable_ecc_irq_src,  
  input  wire logic [L_XLEN-1:0]                 curr_pc,    
  input  wire logic [L_XLEN-1:0]                 curr_instr_enc,
  input  wire logic [L_XLEN-1:0]                 curr_ld_addr,  
  input  wire logic [L_XLEN-1:0]                 curr_str_addr,          
  input  wire logic                              excpt_i_addr_misalign,     
  input  wire logic                              excpt_i_access_fault,      
  input  wire logic                              excpt_illegal_instr,       
  input  wire logic                              excpt_breakpoint, 
  input  wire logic [l_core_cfg_trigger_bus_width-1:0]      excpt_trigger,             
  input  wire logic                              excpt_ld_addr_misalign,         
  input  wire logic                              excpt_ld_access_fault,          
  input  wire logic                              excpt_str_amo_addr_misalign,    
  input  wire logic                              excpt_str_amo_access_fault,     
  input  wire logic                              excpt_m_env_call,               
  input  wire logic                              excpt_s_env_call,               
  input  wire logic                              excpt_u_env_call,
  input  wire logic                              excpt_bus_error_i,          
  input  wire logic                              excpt_parity_error_i,       
  input  wire logic                              excpt_bus_error_d,          
  input  wire logic                              excpt_parity_error_d,  
  output logic                                   trap_taken,                     
  input  wire logic                              trap_return,  
  input  wire logic [1:0]                        extension_context_state,    
// debug 
  input  wire  logic [L_XLEN-1:0]                debug_csr_op_wr_data,
  input  wire  logic                             debug_csr_wr_en, 
  input  wire  logic                             debug_csr_rd_en, 
  input  wire logic [11:0]                       debug_csr_op_addr,
  output logic [L_XLEN-1:0]                      debug_csr_op_rd_data,
  output logic                                   debug_csr_op_rd_data_valid, 
   
  input  wire  logic                             debug_active,
  input  wire logic                              debug_halt_req,   
  output logic                                   debug_halt_ack,  
  input  wire  logic                             debug_resethalt_req,
  output logic                                   debug_resethalt_ack,
  input  wire logic                              debug_resume_req,   
  output logic                                   debug_resume_ack,
  output logic                                   debug_mode_enter_req,      
  input  wire  logic                             debug_instr_debug_enter_req,
  output logic                                   debug_mode_enter, 
  output logic                                   debug_mode_retire_mask,
  output logic                                   debug_mode_exit,   
// CSR Priv state values
  output logic [L_XLEN-1:0]                      csr_priv_misa,  
  output logic [4:0]                             csr_priv_cause_excpt_code,
  output logic                                   csr_priv_mtvec_excpt_vectored,
  output logic [L_XLEN-1:0]                      csr_priv_mtvec_excpt_vec, 
  output logic [L_XLEN-1:0]                      csr_priv_epc,   
  output logic [L_XLEN-1:0]                      csr_priv_dpc,   
  output logic                                   csr_priv_soft_reset_taken,
  output logic                                   csr_priv_interrupt_taken,  
  output logic [1:0]                             csr_priv_priv_mode,
  output logic                                   csr_priv_debug_mode,
// trigger/debug inputs
  input wire  logic [31:0]                       trigger_instruction_opcode,    
  input wire  logic [31:0]                       trigger_instruction_address,  
  input wire  logic                              trigger_instruction_valid,
  input wire  logic                              step_instruction_valid,
  output logic [l_core_cfg_trigger_bus_width-1:0]           trigger_req,
// soft/debug reset output signal for triggering gpr ram init
  output logic                                   gpr_ram_init_soft_debug_reset
                               
);  

  
//******************************************************************************
// Declarations

  logic                         soft_reset_taken_retr;
  logic                         soft_reset_pending;
  logic                         next_soft_reset_pending;
  logic                         debug_reset_taken_retr;
  logic                         debug_active_retr;
  logic                         interrupt_taken;  
  logic                         exception_taken;
  logic                         excpt_ebreak;
  logic                         excpt_trigger_break_taken;
  logic                         excpt_trigger_break_taken_and_debug;
  logic [31:0]                  excpt_trigger_dpc;
  logic                         excpt_trigger_debug_taken;
  logic [4:0]                   cause_excpt_code;
  logic [4:0]                   cause_excpt_code_irq;
  logic [4:0]                   cause_excpt_code_excpt;
  logic [L_XLEN-1:0]            trap_val;
  logic                         irq_m_swi;
  logic                         locally_enabled_irq_captured;
  logic                         base_irq_src_ext; 
  logic                         base_irq_src_timer;
  logic                         base_irq_src_sw;
  logic                         base_irq_p_ext;
  logic                         base_irq_p_timer;    
  logic                         base_irq_p_sw; 
  logic [7:0]                   sys_ext_irq_p;              
  logic                         gpr_correctable_ecc_irq_p;  
  logic                         gpr_uncorrectable_ecc_irq_p;
  logic                         instret_count_irq_p;
  logic                         cycle_count_irq_p;
  logic                         hpm_count_irq_p;
  logic                         instret_count_irq_src;
  logic                         cycle_count_irq_src;  
  logic                         hpm_count_irq_src;    
  
  logic                         trap_taken_internal;
  logic                         valid_instr_completing;
  t_csr_reg_rd_sel              csr_reg_rd_sel;
  t_csr_reg_wr_sel              csr_reg_wr_sel;
  logic [L_XLEN-1:0]            mvendorid;
  logic [L_XLEN-1:0]            mvendorid_rd_data;  
  logic [L_XLEN-1:0]            marchid;
  logic [L_XLEN-1:0]            marchid_rd_data;  
  logic [L_XLEN-1:0]            mimpid;
  logic [L_XLEN-1:0]            mimpid_rd_data;  
  logic [L_XLEN-1:0]            mhartid;
  logic [L_XLEN-1:0]            mhartid_rd_data;  
  logic [L_XLEN-1:0]            mstatus;
  logic [L_XLEN-1:0]            mstatus_rd_data;
  logic [L_XLEN-1:0]            sstatus;
  logic [L_XLEN-1:0]            sstatus_rd_data;
  logic [L_XLEN-1:0]            ustatus;
  logic [L_XLEN-1:0]            ustatus_rd_data;  
  logic                         status_uie;
  logic                         status_sie;
  logic                         status_mie;
  logic                         status_ie;
  logic                         machine_init_wr_status_mie_wr_en;  
  logic                         machine_init_wr_status_mie_wr_data;
  logic                         machine_implicit_wr_status_mie_wr_en;
  logic                         machine_implicit_wr_status_mie_wr_data;
  logic                         machine_sw_wr_status_mie_wr_en;
  logic                         machine_sw_wr_status_mie_wr_data;
  logic                         status_upie; 
  logic                         status_spie; 
  logic                         status_mpie;
  logic                         machine_implicit_wr_status_mpie_wr_en;
  logic                         machine_implicit_wr_status_mpie_wr_data;
  logic                         machine_sw_wr_status_mpie_wr_en;
  logic                         machine_sw_wr_status_mpie_wr_data; 
  logic                         status_spp;
  logic [1:0]                   status_mpp;
  logic [1:0]                   status_fs;
  logic [1:0]                   status_xs;
  logic                         status_mprv;
  logic                         status_sum;
  logic                         status_mxr;
  logic                         status_tvm;
  logic                         status_tw;
  logic                         status_tsr;
  logic                         status_sd;  
  logic [L_XLEN-1:0]            misa;
  logic [L_XLEN-1:0]            misa_rd_data;
  logic                         misa_ext_a;
  logic                         misa_ext_b;
  logic                         misa_ext_c;
  logic                         misa_ext_d;
  logic                         misa_ext_e;
  logic                         misa_ext_f;
  logic                         misa_ext_g;
  logic                         misa_ext_h;
  logic                         misa_ext_i;
  logic                         misa_ext_j;
  logic                         misa_ext_k;
  logic                         misa_ext_l;
  logic                         misa_ext_m;
  logic                         misa_ext_n;
  logic                         misa_ext_o;
  logic                         misa_ext_p;
  logic                         misa_ext_q;
  logic                         misa_ext_r;
  logic                         misa_ext_s;
  logic                         misa_ext_t;
  logic                         misa_ext_u;
  logic                         misa_ext_v;
  logic                         misa_ext_w;
  logic                         misa_ext_x;
  logic                         misa_ext_y;
  logic                         misa_ext_z;
  logic [1:0]                   misa_ext_mxl; 
  logic [L_XLEN-1:0]            mideleg;
  logic [L_XLEN-1:0]            mideleg_rd_data;
  logic [L_XLEN-1:0]            medeleg;
  logic [L_XLEN-1:0]            medeleg_rd_data;  
  logic [L_XLEN-1:0]            mie;
  logic [L_XLEN-1:0]            mie_rd_data;
  logic [L_XLEN-1:0]            sie;
  logic [L_XLEN-1:0]            sie_rd_data;
  logic [L_XLEN-1:0]            uie;
  logic [L_XLEN-1:0]            ie;
  logic [L_XLEN-1:0]            uie_rd_data;
  logic                         ie_usie;
  logic                         ie_ssie;
  logic                         ie_msie;
  logic                         machine_implicit_wr_ie_msie_wr_en;
  logic                         machine_implicit_wr_ie_msie_wr_data;
  logic                         machine_sw_wr_ie_msie_wr_en;
  logic                         machine_sw_wr_ie_msie_wr_data;
  logic                         ie_utie;
  logic                         ie_stie;
  logic                         ie_mtie;
  logic                         machine_implicit_wr_ie_mtie_wr_en;
  logic                         machine_implicit_wr_ie_mtie_wr_data;
  logic                         machine_sw_wr_ie_mtie_wr_en;
  logic                         machine_sw_wr_ie_mtie_wr_data;
  logic                         ie_ueie;
  logic                         ie_seie;
  logic                         ie_meie;
  logic                         machine_implicit_wr_ie_meie_wr_en;
  logic                         machine_implicit_wr_ie_meie_wr_data;
  logic                         machine_sw_wr_ie_meie_wr_en;
  logic                         machine_sw_wr_ie_meie_wr_data;
  logic [7:0]                   ie_mextsysie;
  logic                         ie_gpr_ecc_uncorr;
  logic                         ie_gpr_ecc_corr;
  logic                         ie_instret_cnt;
  logic                         ie_cycle_cnt;
  logic                         ie_hpm_cnt;
  logic [L_XLEN-1:0]            mip;
  logic [L_XLEN-1:0]            mip_rd_data; 
  logic [L_XLEN-1:0]            sip;
  logic [L_XLEN-1:0]            sip_rd_data;
  logic [L_XLEN-1:0]            uip;
  logic [L_XLEN-1:0]            uip_rd_data;
  logic                         ip_usip;
  logic                         ip_ssip;
  logic                         ip_msip;
  logic                         ip_utip;
  logic                         ip_stip;
  logic                         ip_mtip;
  logic                         ip_ueip;
  logic                         ip_seip;
  logic                         ip_meip;
  logic                         gpr_uncorrectable_ecc_irq_clr;
  logic                         gpr_correctable_ecc_irq_clr;
  logic                         instret_count_irq_clr;
  logic                         cycle_count_irq_clr;
  logic                         hpm_count_irq_clr;
  
    
  logic [L_XLEN-1:0]            mtvec;
  logic [L_XLEN-1:0]            mtvec_rd_data; 
  logic [1:0]                   mtvec_mode; 
  logic                         machine_implicit_wr_mtvec_mode_wr_en;
  logic [1:0]                   machine_implicit_wr_mtvec_mode_wr_data;
  logic                         machine_sw_wr_mtvec_mode_wr_en;
  logic [1:0]                   machine_sw_wr_mtvec_mode_wr_data;
  logic [L_XLEN-1:2]            mtvec_base_reg;   
  logic                         machine_implicit_wr_mtvec_base_wr_en;
  logic [L_XLEN-1:2]            machine_implicit_wr_mtvec_base_wr_data;
  logic                         machine_sw_wr_mtvec_base_wr_en;
  logic [L_XLEN-1:2]            machine_sw_wr_mtvec_base_wr_data;
  logic [L_XLEN-1:0]            mtvec_base; 
  
  logic [L_XLEN-1:0]            mepc;
  logic [L_XLEN-1:0]            mepc_rd_data;  
  logic [L_XLEN-1:1]            mepc_epc; 
  logic                         machine_implicit_wr_mepc_epc_wr_en;
  logic [L_XLEN-1:1]            machine_implicit_wr_mepc_epc_wr_data;
  logic                         machine_sw_wr_mepc_epc_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mepc_epc_wr_data;
  
  logic [L_XLEN-1:0]            mcause;
  logic [L_XLEN-1:0]            mcause_rd_data;
  logic                         mcause_sw_rd_sel;
  logic                         mcause_sw_wr_sel;  
  logic [4:0]                   mcause_excpt_code; 
  logic                         machine_init_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_init_wr_mcause_excpt_code_wr_data;
  logic                         machine_implicit_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_implicit_wr_mcause_excpt_code_wr_data;
  logic                         machine_sw_wr_mcause_excpt_code_wr_en;
  logic [4:0]                   machine_sw_wr_mcause_excpt_code_wr_data;
  logic                         mcause_interrupt; 
  logic                         machine_init_wr_mcause_interrupt_wr_en;
  logic                         machine_init_wr_mcause_interrupt_wr_data;
  logic                         machine_implicit_wr_mcause_interrupt_wr_en;
  logic                         machine_implicit_wr_mcause_interrupt_wr_data;
  logic                         machine_sw_wr_mcause_interrupt_wr_en;
  logic                         machine_sw_wr_mcause_interrupt_wr_data;  
  logic [L_XLEN-1:0]            mtval;
  logic [L_XLEN-1:0]            mtval_rd_data;  
  logic [L_XLEN-1:0]            mtval_tval; 
  logic                         machine_implicit_wr_mtval_tval_wr_en;
  logic [L_XLEN-1:0]            machine_implicit_wr_mtval_tval_wr_data;
  logic                         machine_sw_wr_mtval_tval_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mtval_tval_wr_data;  
  logic [L_XLEN-1:0]            mcounteren;
  logic [L_XLEN-1:0]            mcounteren_rd_data;
  logic                         mcounteren_cycle_count_en;
  logic                         mcounteren_timer_count_en;
  logic                         mcounteren_instret_count_en;
  logic [28:0]                  mcounteren_hpm_count_en; 
  logic [L_XLEN-1:0]            mcounterinhibit;
  logic [L_XLEN-1:0]            mcounterinhibit_rd_data; 
  logic                         mcounterinhibit_cycle_count_inh; 
  logic                         mcounterinhibit_instret_count_inh;     
  logic [28:0]                  mcounterinhibit_hpm_count_inh;   
  logic [L_XLEN-1:0]            mscratch;
  logic [L_XLEN-1:0]            mscratch_rd_data;
  logic [L_XLEN-1:0]            mscratch_scratch; 
  logic                         machine_sw_wr_mscratch_scratch_wr_en;
  logic [L_XLEN-1:0]            machine_sw_wr_mscratch_scratch_wr_data; 
  logic [L_XLEN-1:0]            pmpcfg_0_3;
  logic [L_XLEN-1:0]            pmpcfg_0_3_rd_data;
  logic [L_XLEN-1:0]            pmpaddr_0_15;
  logic [L_XLEN-1:0]            pmpaddr_0_15_rd_data;  
  logic [L_XLEN-1:0]            sideleg;
  logic [L_XLEN-1:0]            sideleg_rd_data; 
  logic [L_XLEN-1:0]            sedeleg;
  logic [L_XLEN-1:0]            sedeleg_rd_data;
  logic [L_XLEN-1:0]            stvec;
  logic [L_XLEN-1:0]            stvec_rd_data;
  logic [L_XLEN-1:0]            sepc;
  logic [L_XLEN-1:0]            sepc_rd_data;
  logic [L_XLEN-1:0]            scause;
  logic [L_XLEN-1:0]            scause_rd_data;
  logic [L_XLEN-1:0]            stval;
  logic [L_XLEN-1:0]            stval_rd_data;
  logic [L_XLEN-1:0]            scounteren;
  logic [L_XLEN-1:0]            scounteren_rd_data;
  logic [L_XLEN-1:0]            sscratch;
  logic [L_XLEN-1:0]            sscratch_rd_data;
  logic [L_XLEN-1:0]            satp;
  logic [L_XLEN-1:0]            satp_rd_data; 
  logic [L_XLEN-1:0]            utvec;
  logic [L_XLEN-1:0]            utvec_rd_data;
  logic [L_XLEN-1:0]            uepc;
  logic [L_XLEN-1:0]            uepc_rd_data;
  logic [L_XLEN-1:0]            ucause;
  logic [L_XLEN-1:0]            ucause_rd_data;
  logic [L_XLEN-1:0]            utval;
  logic [L_XLEN-1:0]            utval_rd_data;
  logic [L_XLEN-1:0]            uscratch;
  logic [L_XLEN-1:0]            uscratch_rd_data;  
//  logic [l_core_cfg_cycle_count_width-1:0]   cycle_count_reg;
  logic [(L_XLEN*2)-1:0]                          cycle_count;           
  logic [L_XLEN-1:0]                              ucycle_rd_data;    
  logic [L_XLEN-1:0]                              mcycle_rd_data;              
  logic [L_XLEN-1:0]                              ucycleh_rd_data;    
  logic [L_XLEN-1:0]                              mcycleh_rd_data; 
  logic [L_XLEN-1:0]                              utime;
  logic [L_XLEN-1:0]                              utime_rd_data; 
  logic [L_XLEN-1:0]                              utimeh;
  logic [L_XLEN-1:0]                              utimeh_rd_data;
//  logic [l_core_cfg_instret_count_width-1:0] instret_count_reg;
  logic [(L_XLEN*2)-1:0]                          instret_count;
  logic [L_XLEN-1:0]                              uinstret_rd_data;
  logic [L_XLEN-1:0]                              minstret_rd_data;
  logic [L_XLEN-1:0]                              uinstreth_rd_data;
  logic [L_XLEN-1:0]                              minstreth_rd_data;
  logic [L_XLEN-1:0]                              hpmcounter_3_31_rd_data;
  logic [L_XLEN-1:0]                              hpmcounter_3_31h_rd_data;
  logic [L_XLEN-1:0]                              mhpmcounter_3_31_rd_data;
  logic [L_XLEN-1:0]                              mhpmcounter_3_31h_rd_data; 
  logic [L_XLEN-1:0]                              hpmevent_3_31_rd_data; 
   
  logic [L_XLEN-1:0]                              tselect;
  logic [L_XLEN-1:0]                              tselect_rd_data;
  logic [L_XLEN-1:0]                              tdata1;
  logic [L_XLEN-1:0]                              tdata1_rd_data;
  logic [L_XLEN-1:0]                              tdata2;
  logic [L_XLEN-1:0]                              tdata2_rd_data;
  logic [L_XLEN-1:0]                              tdata3;
  logic [L_XLEN-1:0]                              tdata3_rd_data;          
  
  logic                                           sw_csr_wr_valid_qual;
  logic                                           sw_csr_rd_valid_qual;
  logic                                           sw_rd_en_valid;
  logic [11:0]                                    csr_op_addr_sig;
  
  logic [1:0]                                     priv_mode;       
  
  logic                                           ext_msip_retime;
  logic                                           ext_mtip_retime;
  logic                                           ext_meip_retime;
  
      
  logic [L_XLEN-1:0]                              csr_op_wr_data; 
  logic                                           csr_op_wr_data_valid;  
  logic                                           csr_op_wr_valid;   
  logic                                           csr_op_rd_valid;    
  logic                                           csr_alu_wr_op_ready; 
  
  logic [L_XLEN-1:0]                              exu_csr_op_wr_data; 
  logic                                           exu_csr_op_wr_data_valid;  
  logic                                           exu_csr_op_wr_valid;    
  logic                                           exu_csr_alu_wr_op_ready; 
  
  logic                                           set_wfi_waiting;
  logic                                           clr_wfi_waiting;
  logic                                           wfi_waiting_reg;
  
  logic                                           debugger_rd_en_valid;
  logic                                           debugger_wr_en_valid;
  logic                                           debug_mode;   
  logic                                           debug_enter_taken; 
  logic                                           debug_exit_taken; 

  logic [L_XLEN-1:0]                              dcsr;
  logic [L_XLEN-1:0]                              dcsr_rd_data;
  logic [3:0]                                     dcsr_xdebugver;
  logic                                           dcsr_ebreakm;
  logic                                           dcsr_ebreaks;
  logic                                           dcsr_ebreaku;
  logic                                           dcsr_stepie;
  logic                                           dcsr_stopcount;
  logic                                           dcsr_stoptime;
  logic [2:0]                                     dcsr_cause;
  logic                                           dcsr_mprven;
  logic                                           dcsr_nmip;
  logic                                           dcsr_step;
  logic [1:0]                                     dcsr_prv;
  logic [I_ADDR_WIDTH-1:0]                        dpc_reg;
  logic [L_XLEN-1:0]                              dpc;
  logic [L_XLEN-1:0]                              dpc_rd_data;
  logic [L_XLEN-1:0]                              dscratch0;
  logic [L_XLEN-1:0]                              dscratch0_rd_data;  
  logic [L_XLEN-1:0]                              dscratch1;  
  logic [L_XLEN-1:0]                              dscratch1_rd_data; 
  logic                                           step_debug_enter_taken;  
  logic                                           haltreq_debug_enter_taken;    
  logic                                           resethaltreq_debug_enter_taken; 
  logic                                           trigger_debug_enter_taken; 
  logic                                           ebreak_debug_enter_taken; 
  
//******************************************************************************
// Main code

  

// CSR write path operations
//------------------------------------
  
  always @*
  begin
    case(csr_alu_wr_op_sel)
      csr_alu_wr_op_swap :
      begin
        exu_csr_op_wr_data        = csr_op_gpr_imm ;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end
      
      csr_alu_wr_op_set :
      begin
        exu_csr_op_wr_data        = csr_op_rd_data | csr_op_gpr_imm;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end
      
      csr_alu_wr_op_clr :
      begin
        exu_csr_op_wr_data        = csr_op_rd_data & ~csr_op_gpr_imm;
        exu_csr_op_wr_data_valid  = csr_op_gpr_imm_valid;
        exu_csr_op_wr_valid       = 1'b1;
        exu_csr_alu_wr_op_ready   = csr_op_gpr_imm_valid;
      end


      csr_alu_wr_op_none :
      begin
        exu_csr_op_wr_data        = {L_XLEN{1'b0}};
        exu_csr_op_wr_data_valid  = 1'b0;
        exu_csr_op_wr_valid       = 1'b0;
        exu_csr_alu_wr_op_ready   = 1'b1;
      end
      
      default :
      begin
        exu_csr_op_wr_data        = {L_XLEN{1'b0}};
        exu_csr_op_wr_data_valid  = 1'b0;
        exu_csr_op_wr_valid       = 1'b0;
        exu_csr_alu_wr_op_ready   = 1'b0;
      end
    endcase
  end
  
  assign csr_op_wr_data        = debug_mode ? debug_csr_op_wr_data  : exu_csr_op_wr_data;      
  assign csr_op_wr_data_valid  = debug_mode ? debug_csr_wr_en       : exu_csr_op_wr_data_valid;
  assign csr_op_wr_valid       = debug_mode ? debug_csr_wr_en       : (exu_csr_op_wr_valid  & ~flush);     
  assign csr_alu_wr_op_ready   = debug_mode ? 1'b1                  : exu_csr_alu_wr_op_ready; 
  
  assign csr_op_rd_valid       = debug_mode ? debug_csr_rd_en       : (csr_alu_rd_op_sel != csr_alu_rd_op_none);
  assign csr_op_addr_sig       = debug_mode ? debug_csr_op_addr     : csr_op_addr;

// intermediate computations
//------------------------------------
  
  // when dcsr_ebreakm = 0 take exception as per priv spec, when = 1 enter debug as defined in debug spec, unless debug not active
  assign excpt_ebreak = excpt_breakpoint & ((~dcsr_ebreakm) | (~debug_active_retr));  

  assign valid_instr_completing = instr_completing_retr & instr_valid_retr;       

  // Mask exception generation when entering debug mode since the instruction is not retired, hence precise exceptions associated
  // with it not generated. 
  // A trigger break that causes a trap and enters debug mode (from seperate triggers), should not generate a trap externally, howevever
  // if both are allowed simultaneously (l_cfg_core_trigger_both = 1), as optionally defined by the debug spec, a trap should be generated internally
  // such that the implicit updates associated with a trap are performed; then when exitingdebug, the trap will appear to also have executed.
  
  assign exception_taken = valid_instr_completing & 
                           ~(debug_enter_taken | debug_mode) &
                            ((|{excpt_i_addr_misalign,        
                                excpt_i_access_fault,        
                                excpt_illegal_instr,         
                                excpt_ebreak, 
                                excpt_trigger_break_taken,           
                                excpt_ld_addr_misalign,      
                                excpt_ld_access_fault,       
                                excpt_str_amo_addr_misalign, 
                                excpt_str_amo_access_fault,  
                                excpt_m_env_call,            
                                excpt_s_env_call,            
                                excpt_u_env_call,
                                excpt_bus_error_i,   
                                excpt_parity_error_i,
                                excpt_bus_error_d,   
                                excpt_parity_error_d}) | 
                               excpt_trigger_break_taken_and_debug) ;                   
 
  // interrupts                                     
  assign base_irq_src_ext    = ext_meip; 
  assign base_irq_src_timer  = ext_mtip;
  assign base_irq_src_sw     = ext_msip;                              
                                      
  miv_rv32_priv_irq  #( .l_core_num_sys_ext_irqs              (l_core_num_sys_ext_irqs              ),
                         .l_core_cfg_gpr_ecc_uncorrectable_irq (l_core_cfg_gpr_ecc_uncorrectable_irq ),
                         .l_core_cfg_gpr_ecc_correctable_irq   (l_core_cfg_gpr_ecc_correctable_irq   )  
  )
  u_miv_rv32_priv_irq_0
  (
    .clk                            (clk                           ),
    .resetn                         (resetn                        ), 
    .debug_mode                     (debug_mode                    ),
    .lsu_op_os                      (lsu_op_os                     ),
    .instr_completing_retr          (instr_completing_retr         ),
    .instr_valid_retr               (instr_valid_retr              ),
    .instr_lsu_op_retr              (instr_lsu_op_retr             ),
    .ie                             (ie                            ),
    .global_enable                  (status_ie                     ),
    .dcsr_stepie                    (dcsr_stepie                   ),
    .dcsr_step                      (dcsr_step                     ),
    .ip_read                        (csr_reg_rd_sel.ip_sw_rd_sel   ),
                                    
    .base_irq_src_ext               (base_irq_src_ext              ),
    .base_irq_src_timer             (base_irq_src_timer            ),
    .base_irq_src_sw                (base_irq_src_sw               ),
    .sys_ext_irq_src                (sys_ext_irq_src               ),
    .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src ),
    .gpr_uncorrectable_ecc_irq_clr  (gpr_uncorrectable_ecc_irq_clr ),
    .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src   ),
    .gpr_correctable_ecc_irq_clr    (gpr_correctable_ecc_irq_clr   ),
    .instret_count_irq_src          (instret_count_irq_src         ),
    .instret_count_irq_clr          (instret_count_irq_clr         ),
    .cycle_count_irq_src            (cycle_count_irq_src           ),
    .cycle_count_irq_clr            (cycle_count_irq_clr           ),
    .hpm_count_irq_src              (hpm_count_irq_src             ),
    .hpm_count_irq_clr              (hpm_count_irq_clr             ),
                                    
    .irq_stall_lsu_req              (irq_stall_lsu_req             ),
    .irq_abort_lsu_req              (irq_abort_lsu_req             ),
    .locally_enabled_irq_captured   (locally_enabled_irq_captured  ),
    .irq_taken                      (interrupt_taken               ),
    .base_ip_ext                    (base_irq_p_ext                ),    
    .base_ip_timer                  (base_irq_p_timer              ),
    .base_ip_sw                     (base_irq_p_sw                 ), 
    .sys_ext_ip                     (sys_ext_irq_p                 ), 
    .gpr_correctable_ecc_ip         (gpr_correctable_ecc_irq_p     ), 
    .gpr_uncorrectable_ecc_ip       (gpr_uncorrectable_ecc_irq_p   ), 
    .instret_count_ip               (instret_count_irq_p           ),
    .cycle_count_ip                 (cycle_count_irq_p             ),
    .hpm_count_ip                   (hpm_count_irq_p               ),
    .cause_excpt_code_irq           (cause_excpt_code_irq          )
  ); 
  
  assign trap_taken_internal = exception_taken | interrupt_taken; 
  assign trap_taken          = trap_taken_internal & ~(debug_enter_taken | debug_mode);                                 
                                                
  // priority/encoding defined by priv spec                                                
  assign cause_excpt_code_excpt = excpt_trigger_break_taken ? 5'd3 :  
                                    excpt_i_access_fault ? 5'd1 : 
                                      excpt_illegal_instr ? 5'd2 : 
                                        excpt_i_addr_misalign ? 5'd0 :  
                                          excpt_m_env_call ? 5'd11 : 
                                            excpt_ebreak ? 5'd3 :
                                              excpt_str_amo_addr_misalign ? 5'd6 :
                                                excpt_ld_addr_misalign ? 5'd4 : 
                                                  excpt_str_amo_access_fault ? 5'd7 :
                                                    excpt_ld_access_fault ? 5'd5 : 
                                                      excpt_bus_error_i ? 5'd24 :    
                                                        excpt_parity_error_i ? 5'd25 :
                                                          excpt_bus_error_d ? 5'd26 :   
                                                            excpt_parity_error_d ? 5'd27 : 5'd0;                                             
                                                  
                                                           
  assign cause_excpt_code = interrupt_taken ? cause_excpt_code_irq : cause_excpt_code_excpt;
  
  assign trap_val = interrupt_taken ? 32'd0 :
                      excpt_trigger_break_taken ? curr_pc : 
                        excpt_i_access_fault ? curr_pc :
                          excpt_illegal_instr ? curr_instr_enc :  
                            excpt_i_addr_misalign ? curr_pc : 
                              excpt_m_env_call ? 32'd0 :
                                excpt_ebreak ? curr_pc :
                                  excpt_str_amo_addr_misalign ? curr_str_addr :
                                    excpt_ld_addr_misalign ? curr_ld_addr :
                                      excpt_str_amo_access_fault ? curr_str_addr : 
                                        excpt_ld_access_fault ? curr_ld_addr : 
                                          excpt_bus_error_i ? curr_pc :   
                                            excpt_parity_error_i ? curr_pc :
                                              excpt_bus_error_d ? curr_ld_addr :   
                                                excpt_parity_error_d ? curr_ld_addr : 32'd0; 
  
  //--------------------------------------------------------
  // Reset handling
  //--------------------------------------------------------   
  // Need to ensure soft_reset occurs (soft_reset_taken_retr asserted) only when an instruction is completing
  // to ensure reset handling instruction is inserted without anything outstanding in the retr stage
  // stage.
  // Reset must take priority over new instructions and must happen if no instructions in flight
  // need to mask when debug entry is pending so that debug mode can be entered as soft_rest will prevent it doing so if held asserted 
  // as may be the case when debugger is requesting debug mode entry straight out of reset
  
  assign next_soft_reset_pending = (soft_reset_pending & ~soft_reset_taken_retr) | (soft_reset | debug_soft_reset);
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      soft_reset_pending <= 1'b0;
    else
      soft_reset_pending <= next_soft_reset_pending;
  end
  
  assign soft_reset_taken_retr = soft_reset_pending & (instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req;  
  
  assign gpr_ram_init_soft_debug_reset = next_soft_reset_pending;
 

// piveleged mode bits
//------------------------------------

  assign priv_mode = l_core_mode_machine ; // Only Machine mode supported by core
  

// CSR registers
//------------------------------------
 
  assign sw_csr_wr_valid_qual = csr_op_wr_valid & csr_op_wr_data_valid & csr_op_addr_valid;
  assign sw_csr_rd_valid_qual = csr_op_rd_valid & csr_op_addr_valid;  
  
    miv_rv32_csr_decode
    #(
      .CHECK_ILLEGAL     (0),  // illegal checks performed in DE stage
	  .l_core_cfg_hw_debug (l_core_cfg_hw_debug)
    )
    u_miv_rv32_csr_decode_0
    (
      .clk                         (clk                 ),
      .resetn                      (resetn              ),
      .debug_mode                  (debug_mode          ),
      .csr_rd_addr                 (csr_op_addr_sig     ),
      .csr_rd_en_valid             (sw_csr_rd_valid_qual),
      .csr_wr_addr                 (csr_op_addr_sig     ),
      .csr_wr_en_valid             (sw_csr_wr_valid_qual),
      .csr_reg_rd_sel              (csr_reg_rd_sel      ),
      .csr_reg_wr_sel              (csr_reg_wr_sel      ),
      .csr_rd_illegal              (                    ),  // open, illegal checks performed in DE stage
      .csr_wr_illegal              (                    )   // open, illegal checks performed in DE stage   
    );   
  
// Machine Mode CSRs
//++++++++++++++++++ 

//mvendorid	
//  mvendorid
  

  assign mvendorid = l_core_vendorid;
  assign mvendorid_rd_data = mvendorid & {L_XLEN{csr_reg_rd_sel.mvendorid_sw_rd_sel}};
  
//marchid	
//  marchid


  assign marchid = l_core_marchid;
  assign marchid_rd_data = marchid & {L_XLEN{csr_reg_rd_sel.marchid_sw_rd_sel}};
	
//mimpid	
//  mimpid

  assign mimpid = l_core_mimpid;
  assign mimpid_rd_data = mimpid & {L_XLEN{csr_reg_rd_sel.mimpid_sw_rd_sel}};
	
//mhartid	
// mhartid

  assign mhartid = hart_id;  // read only
  assign mhartid_rd_data = mhartid & {L_XLEN{csr_reg_rd_sel.mhartid_sw_rd_sel}};
	    
//status  
                                                    
//  status_uie
  assign status_uie = 1'b0;         // no user mode in core
//  status_sie
  assign status_sie = 1'b0;         // no supervisor mode in core
//  status_mie
  assign machine_init_wr_status_mie_wr_en       = soft_reset_taken_retr;
  assign machine_init_wr_status_mie_wr_data     = 1'b0;
  assign machine_implicit_wr_status_mie_wr_en   = (priv_mode == l_core_mode_machine ) && (trap_taken_internal || trap_return);
  assign machine_implicit_wr_status_mie_wr_data = trap_taken_internal ? 1'b0 :status_mpie;
  assign machine_sw_wr_status_mie_wr_en         = csr_reg_wr_sel.mstatus_sw_wr_sel;
  assign machine_sw_wr_status_mie_wr_data       = csr_op_wr_data[3];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_status_mie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_status_mie_wr_en),
      .init_wr_data                (machine_init_wr_status_mie_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_status_mie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_status_mie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_status_mie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_status_mie_wr_data),
      .state_val                   (status_mie)
    );   
    
  assign status_ie =  ((priv_mode == l_core_mode_machine) & status_mie) |
                      ((priv_mode == l_core_mode_supervisor) & status_sie) |
                      ((priv_mode == l_core_mode_user) & status_uie);
    
//  status_upie  
  assign status_upie = 1'b0;        // no user mode in core
//  status_spie
  assign status_spie = 1'b0;        // no supervisor mode in core
//  status_mpie
  assign machine_implicit_wr_status_mpie_wr_en   = (priv_mode == l_core_mode_machine ) && (trap_taken_internal || trap_return);
  assign machine_implicit_wr_status_mpie_wr_data = trap_taken_internal ? status_mie :1'b1;
  assign machine_sw_wr_status_mpie_wr_en         = csr_reg_wr_sel.mstatus_sw_wr_sel;
  assign machine_sw_wr_status_mpie_wr_data       = csr_op_wr_data[7];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_status_mpie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_status_mpie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_status_mpie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_status_mpie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_status_mpie_wr_data),
      .state_val                   (status_mpie)
    );
    
//  status_spp
  assign status_spp = 1'b0;            // no supervisor mode in core
//  status_mpp
  assign status_mpp = l_core_mode_machine ;   // Previous mode can only be machine mode in core 
//  status_fs
  assign status_fs = 2'b00;             // no floating point in core
//  status_xs
  assign status_xs = extension_context_state;
//  status_mprv
  assign status_mprv = 1'b0;            // no supervisor mode in core
//  status_sum
  assign status_sum = 1'b0;             // no supervisor mode in core
//  status_mxr
  assign status_mxr = 1'b0;             // no supervisor mode in core
//  status_tvm
  assign status_tvm = 1'b0;             // no supervisor mode in core
//  status_tw
  assign status_tw = 1'b0;              // no supervisor mode in core
//  status_tsr
  assign status_tsr = 1'b0;             // no supervisor mode in core
//  status_sd
  assign status_sd = |{status_fs,status_xs};


  assign mstatus = {status_sd,
                    8'b0000_0000,
                    status_tsr,
                    status_tw,
                    status_tvm,
                    status_mxr,
                    status_sum,
                    status_mprv,
                    status_xs,
                    status_fs,
                    status_mpp,
                    2'b00,
                    status_spp,
                    status_mpie,
                    1'b0,
                    status_spie,
                    status_upie,
                    status_mie,
                    1'b0,
                    status_sie,
                    status_uie};
                   
  assign mstatus_rd_data = mstatus & {L_XLEN{csr_reg_rd_sel.mstatus_sw_rd_sel}}; 
  
  assign sstatus = {status_sd,       
                    8'b0000_0000,    
                    1'b0,            
                    1'b0,            
                    1'b0,            
                    status_mxr,      
                    status_sum,      
                    1'b0,            
                    status_xs,       
                    status_fs,       
                    2'b00,           
                    2'b00,           
                    1'b0,            
                    1'b0,            
                    1'b0,            
                    status_spie,     
                    status_upie,     
                    1'b0,            
                    1'b0,            
                    status_sie,      
                    status_uie};      
                                      
                   
  assign sstatus_rd_data = sstatus & {L_XLEN{csr_reg_rd_sel.sstatus_sw_rd_sel}};    
  
  assign ustatus = {1'b0,
                    8'b0000_0000,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    2'b0,
                    2'b0,
                    2'b00,
                    2'b00,
                    1'b0,
                    1'b0,
                    1'b0,
                    1'b0,
                    status_upie,
                    1'b0,
                    1'b0,
                    1'b0,
                    status_uie};
                   
  assign ustatus_rd_data = ustatus & {L_XLEN{csr_reg_rd_sel.ustatus_sw_rd_sel}};              
	
//misa	
  
// All ISA config is static in core
//  misa_ext_a
  assign misa_ext_a = l_core_cfg_hw_atomics;
//  misa_ext_b
  assign misa_ext_b = 1'b0;
//  misa_ext_c
  assign misa_ext_c = l_core_cfg_hw_compressed;
//  misa_ext_d  
  assign misa_ext_d = 1'b0;
//  misa_ext_e
  assign misa_ext_e = 1'b0;
//  misa_ext_f
  assign misa_ext_f = 1'b0;
//  misa_ext_g
  assign misa_ext_g = 1'b0;
//  misa_ext_h
  assign misa_ext_h = 1'b0;
//  misa_ext_i
  assign misa_ext_i = 1'b1;
//  misa_ext_j
  assign misa_ext_j = 1'b0;
//  misa_ext_k
  assign misa_ext_k = 1'b0;
//  misa_ext_l
  assign misa_ext_l = 1'b0;
//  misa_ext_m
  assign misa_ext_m = l_core_cfg_hw_multiply_divide;
//  misa_ext_n
  assign misa_ext_n = 1'b0;
//  misa_ext_o
  assign misa_ext_o = 1'b0;
//  misa_ext_p
  assign misa_ext_p = 1'b0;
//  misa_ext_q
  assign misa_ext_q = 1'b0;
//  misa_ext_r
  assign misa_ext_r = 1'b0;
//  misa_ext_s
  assign misa_ext_s = 1'b0;
//  misa_ext_t
  assign misa_ext_t = 1'b0;
//  misa_ext_u
  assign misa_ext_u = 1'b0;
//  misa_ext_v
  assign misa_ext_v = 1'b0;
//  misa_ext_w
  assign misa_ext_w = 1'b0;
//  misa_ext_x
  assign misa_ext_x = 1'b0;
//  misa_ext_y
  assign misa_ext_y = 1'b0;
//  misa_ext_z
  assign misa_ext_z = 1'b1; // ZCisr supported
//  misa_mxl
  assign misa_ext_mxl = 2'd1; // 32-bit only

  assign misa = {misa_ext_mxl, 
                 4'b0000,
                 misa_ext_z, misa_ext_y, misa_ext_x, misa_ext_w, misa_ext_v, misa_ext_u, 
                 misa_ext_t, misa_ext_s, misa_ext_r, misa_ext_q, misa_ext_p, misa_ext_o, misa_ext_n, 
                 misa_ext_m, misa_ext_l, misa_ext_k, misa_ext_j, misa_ext_i, misa_ext_h, misa_ext_g, 
                 misa_ext_f, misa_ext_e, misa_ext_d, misa_ext_c, misa_ext_b, misa_ext_a};
                 
  assign misa_rd_data = misa & {L_XLEN{csr_reg_rd_sel.misa_sw_rd_sel}};
	
//medeleg	
// medeleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign medeleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign medeleg_rd_data   = medeleg & {L_XLEN{csr_reg_rd_sel.medeleg_sw_rd_sel}};
  
//mideleg	
// mideleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign mideleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign mideleg_rd_data   = mideleg & {L_XLEN{csr_reg_rd_sel.mideleg_sw_rd_sel}};
	
//ie	

//  ie_usie
  assign ie_usie = 1'b0;
//  ie_ssie
  assign ie_ssie = 1'b0;
//  ie_msie
  assign machine_implicit_wr_ie_msie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_msie_wr_data = 1'b0;
  assign machine_sw_wr_ie_msie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_msie_wr_data       = csr_op_wr_data[3];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_msie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_msie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_msie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_msie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_msie_wr_data),
      .state_val                   (ie_msie)
    );
//  ie_utie
  assign ie_utie = 1'b0;
//  ie_stie
  assign ie_stie = 1'b0;
//  ie_mtie
  assign machine_implicit_wr_ie_mtie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_mtie_wr_data = 1'b0;
  assign machine_sw_wr_ie_mtie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_mtie_wr_data       = csr_op_wr_data[7];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_mtie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_mtie_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_mtie_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_mtie_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_mtie_wr_data),
      .state_val                   (ie_mtie)
    );

//  ie_ueie
  assign ie_ueie = 1'b0;
//  ie_seie
  assign ie_seie = 1'b0;
//  ie_meie
  assign machine_implicit_wr_ie_meie_wr_en   = 1'b0;
  assign machine_implicit_wr_ie_meie_wr_data = 1'b0;
  assign machine_sw_wr_ie_meie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
  assign machine_sw_wr_ie_meie_wr_data       = csr_op_wr_data[11];

  miv_rv32_csr_gpr_state_reg
  #(
    .WIDTH               (1),
    .FIELD_RESET_EN      (0),
    .FIELD_RESET_VAL     (0)
  )
  u_csr_gpr_state_reg_ie_meie
  (
    .clk                         (clk),
    .resetn                      (resetn),
    .init_wr_en                  (1'b0),
    .init_wr_data                (1'b0),
    .machine_implicit_wr_en      (machine_implicit_wr_ie_meie_wr_en),
    .machine_implicit_wr_data    (machine_implicit_wr_ie_meie_wr_data),
    .machine_sw_wr_en            (machine_sw_wr_ie_meie_wr_en),
    .machine_sw_wr_data          (machine_sw_wr_ie_meie_wr_data),
    .state_val                   (ie_meie)
  );
    
  genvar i_ext_sys_irq;
  generate  
  for (i_ext_sys_irq = 0; i_ext_sys_irq < 8; i_ext_sys_irq++) begin : gen_ext_sys_irq
  
    if(i_ext_sys_irq < l_core_num_sys_ext_irqs) begin : gen_ext_sys_irq_bit
    
      logic machine_implicit_wr_ie_mextsysie_wr_en;  
      logic machine_implicit_wr_ie_mextsysie_wr_data;
      logic machine_sw_wr_ie_mextsysie_wr_en;        
      logic machine_sw_wr_ie_mextsysie_wr_data;      
    
      assign machine_implicit_wr_ie_mextsysie_wr_en   = 1'b0;
      assign machine_implicit_wr_ie_mextsysie_wr_data = 1'b0;
      assign machine_sw_wr_ie_mextsysie_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
      assign machine_sw_wr_ie_mextsysie_wr_data       = csr_op_wr_data[24+i_ext_sys_irq];
    
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_ie_mextsysie
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (machine_implicit_wr_ie_mextsysie_wr_en),
        .machine_implicit_wr_data    (machine_implicit_wr_ie_mextsysie_wr_data),
        .machine_sw_wr_en            (machine_sw_wr_ie_mextsysie_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_ie_mextsysie_wr_data),
        .state_val                   (ie_mextsysie[i_ext_sys_irq])
      );
     
    end
    else begin : ngen_ext_sys_irq_bit
      
        assign ie_mextsysie[i_ext_sys_irq] = 1'b0;
  
    end
  end
  endgenerate
  
  generate if(l_core_cfg_gpr_ecc_uncorrectable_irq) begin : gen_ecc_uncorrectable_irq
  
    logic machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en;  
    logic machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data;
    logic machine_sw_wr_ie_gpr_ecc_uncorr_wr_en;        
    logic machine_sw_wr_ie_gpr_ecc_uncorr_wr_data;      
    
    assign machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data = 1'b0;
    assign machine_sw_wr_ie_gpr_ecc_uncorr_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_gpr_ecc_uncorr_wr_data       = csr_op_wr_data[16];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_gpr_ecc_uncorr
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_gpr_ecc_uncorr_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_gpr_ecc_uncorr_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_gpr_ecc_uncorr_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_gpr_ecc_uncorr_wr_data),
      .state_val                   (ie_gpr_ecc_uncorr)
    );  
   
  end
  else begin : ngen_ecc_uncorrectable_irq
    
      assign ie_gpr_ecc_uncorr = 1'b0;
  
  end
  endgenerate

  generate if(l_core_cfg_gpr_ecc_correctable_irq) begin : gen_ecc_correctable_irq
  
    logic machine_implicit_wr_ie_gpr_ecc_corr_wr_en;  
    logic machine_implicit_wr_ie_gpr_ecc_corr_wr_data;
    logic machine_sw_wr_ie_gpr_ecc_corr_wr_en;        
    logic machine_sw_wr_ie_gpr_ecc_corr_wr_data;      
    
    assign machine_implicit_wr_ie_gpr_ecc_corr_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_gpr_ecc_corr_wr_data = 1'b0;
    assign machine_sw_wr_ie_gpr_ecc_corr_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_gpr_ecc_corr_wr_data       = csr_op_wr_data[17];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_gpr_ecc_corr
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_gpr_ecc_corr_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_gpr_ecc_corr_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_gpr_ecc_corr_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_gpr_ecc_corr_wr_data),
      .state_val                   (ie_gpr_ecc_corr)
    );  
   
  end
  else begin : ngen_ecc_correctable_irq
    
      assign ie_gpr_ecc_corr = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_instret_count_irq) begin : gen_instret_count_irq
  
    logic machine_implicit_wr_ie_instret_cnt_wr_en;  
    logic machine_implicit_wr_ie_instret_cnt_wr_data;
    logic machine_sw_wr_ie_instret_cnt_wr_en;        
    logic machine_sw_wr_ie_instret_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_instret_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_instret_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_instret_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_instret_cnt_wr_data       = csr_op_wr_data[18];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_instret_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_instret_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_instret_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_instret_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_instret_cnt_wr_data),
      .state_val                   (ie_instret_cnt)
    );  
   
  end
  else begin : ngen_instret_count_irq
    
      assign ie_instret_cnt = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_cycle_count_irq) begin : gen_cycle_count_irq
  
    logic machine_implicit_wr_ie_cycle_cnt_wr_en;  
    logic machine_implicit_wr_ie_cycle_cnt_wr_data;
    logic machine_sw_wr_ie_cycle_cnt_wr_en;        
    logic machine_sw_wr_ie_cycle_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_cycle_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_cycle_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_cycle_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_cycle_cnt_wr_data       = csr_op_wr_data[19];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_cycle_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_cycle_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_cycle_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_cycle_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_cycle_cnt_wr_data),
      .state_val                   (ie_cycle_cnt)
    );  
   
  end
  else begin : ngen_cycle_count_irq
    
      assign ie_cycle_cnt = 1'b0;
  
  end
  endgenerate
  
  generate if(l_core_cfg_hpm_count_irq) begin : gen_hpm_count_irq
  
    logic machine_implicit_wr_ie_hpm_cnt_wr_en;  
    logic machine_implicit_wr_ie_hpm_cnt_wr_data;
    logic machine_sw_wr_ie_hpm_cnt_wr_en;        
    logic machine_sw_wr_ie_hpm_cnt_wr_data;      
    
    assign machine_implicit_wr_ie_hpm_cnt_wr_en   = 1'b0;
    assign machine_implicit_wr_ie_hpm_cnt_wr_data = 1'b0;
    assign machine_sw_wr_ie_hpm_cnt_wr_en         = csr_reg_wr_sel.mie_sw_wr_sel;
    assign machine_sw_wr_ie_hpm_cnt_wr_data       = csr_op_wr_data[20];
    
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_ie_hpm_cnt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                (1'b0),
      .machine_implicit_wr_en      (machine_implicit_wr_ie_hpm_cnt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_ie_hpm_cnt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_ie_hpm_cnt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_ie_hpm_cnt_wr_data),
      .state_val                   (ie_hpm_cnt)
    );  
   
  end
  else begin : ngen_hpm_count_irq
    
      assign ie_hpm_cnt = 1'b0;
  
  end
  endgenerate
  
  assign mie = {ie_mextsysie,
                {3{1'b0}},
                ie_hpm_cnt,
                ie_cycle_cnt,
                ie_instret_cnt,
                ie_gpr_ecc_corr,
                ie_gpr_ecc_uncorr,
                {4{1'b0}},
                ie_meie,
                1'b0,
                ie_seie,
                ie_ueie,
                ie_mtie,
                1'b0,
                ie_stie,
                ie_utie,
                ie_msie,
                1'b0,
                ie_ssie,
                ie_usie};
                   
  assign mie_rd_data = mie & {L_XLEN{csr_reg_rd_sel.mie_sw_rd_sel}};  
  
  assign sie = {{20{1'b0}},
                1'b0,
                1'b0,
                ie_seie,
                ie_ueie,
                1'b0,
                1'b0,
                ie_stie,
                ie_utie,
                1'b0,
                1'b0,
                ie_ssie,
                ie_usie};
                   
  assign sie_rd_data = sie & {L_XLEN{csr_reg_rd_sel.sie_sw_rd_sel}};
  
  assign uie = {{20{1'b0}},
                1'b0,
                1'b0,
                1'b0,
                ie_ueie,
                1'b0,
                1'b0,
                1'b0,
                ie_utie,
                1'b0,
                1'b0,
                1'b0,
                ie_usie};
                   
  assign uie_rd_data = uie & {L_XLEN{csr_reg_rd_sel.uie_sw_rd_sel}};
  
  assign ie = ({L_XLEN{(priv_mode == l_core_mode_machine)}} & mie) |
              ({L_XLEN{(priv_mode == l_core_mode_supervisor)}} & sie) |
              ({L_XLEN{(priv_mode == l_core_mode_user)}} & uie);
	
//ip	

  // sticky pending bits are cleared by writing 1 to corresponding IP bit
  // Note this action can only be performed in machine mode by writing to the mip alias for ip.
  
  assign gpr_uncorrectable_ecc_irq_clr  = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[16];
  assign gpr_correctable_ecc_irq_clr    = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[17];
  assign instret_count_irq_clr          = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[18];
  assign cycle_count_irq_clr            = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[19];
  assign hpm_count_irq_clr              = csr_reg_wr_sel.mip_sw_wr_sel & csr_op_wr_data[20];
  
  
//  ip_usip
  assign ip_usip = 1'b0;
//  ip_ssip
  assign ip_ssip = 1'b0;
//  ip_msip
  assign ip_msip = base_irq_p_sw;
//  ip_utip
  assign ip_utip = 1'b0;
//  ip_stip
  assign ip_stip = 1'b0;
//  ip_mtip
  assign ip_mtip = base_irq_p_timer;
//  ip_ueip
  assign ip_ueip = 1'b0;
//  ip_seip
  assign ip_seip = 1'b0;
//  ip_meip
  assign ip_meip = base_irq_p_ext;

  assign mip = {sys_ext_irq_p,
                {3{1'b0}},
                hpm_count_irq_p, 
                cycle_count_irq_p,
                instret_count_irq_p,
                gpr_correctable_ecc_irq_p,
                gpr_uncorrectable_ecc_irq_p,
                {4{1'b0}},
                ip_meip,
                1'b0,
                ip_seip,
                ip_ueip,
                ip_mtip,
                1'b0,
                ip_stip,
                ip_utip,
                ip_msip,
                1'b0,
                ip_ssip,
                ip_usip};
                   
  assign mip_rd_data = mip & {L_XLEN{csr_reg_rd_sel.mip_sw_rd_sel}}; 
  
  assign sip = {{20{1'b0}},
               1'b0,
               1'b0,
               ip_seip,
               ip_ueip,
               1'b0,
               1'b0,
               ip_stip,
               ip_utip,
               1'b0,
               1'b0,
               ip_ssip,
               ip_usip};
                   
  assign sip_rd_data = sip & {L_XLEN{csr_reg_rd_sel.sip_sw_rd_sel}}; 
  
  assign uip = {{20{1'b0}},
               1'b0,
               1'b0,
               1'b0,
               ip_ueip,
               1'b0,
               1'b0,
               1'b0,
               ip_utip,
               1'b0,
               1'b0,
               1'b0,
               ip_usip};
                   
  assign uip_rd_data = uip & {L_XLEN{csr_reg_rd_sel.uip_sw_rd_sel}}; 
	
//mtvec	

//  mtvec_mode
  assign machine_implicit_wr_mtvec_mode_wr_en   = 1'b0;
  assign machine_implicit_wr_mtvec_mode_wr_data = 2'b00;
  assign machine_sw_wr_mtvec_mode_wr_en         = csr_reg_wr_sel.mtvec_sw_wr_sel;
  assign machine_sw_wr_mtvec_mode_wr_data       = csr_op_wr_data[1:0];

  generate if(l_core_cfg_static_mtvec_mode) 
  begin : gen_mtvec_mode_read_only
  
    assign mtvec_mode = l_core_static_mtvec_mode;
  end
  else begin : gen_mtvec_mode_writable
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (2),
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mtvec_mode
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({2{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtvec_mode_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtvec_mode_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtvec_mode_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtvec_mode_wr_data),
      .state_val                   (mtvec_mode)
    );
    
  end
  endgenerate
  
//	mtvec_base

  assign machine_implicit_wr_mtvec_base_wr_en   = 1'b0;
  assign machine_implicit_wr_mtvec_base_wr_data = {30{1'd0}};
  assign machine_sw_wr_mtvec_base_wr_en         = csr_reg_wr_sel.mtvec_sw_wr_sel;
  assign machine_sw_wr_mtvec_base_wr_data       = csr_op_wr_data[31:2];
  
  generate if(l_core_cfg_static_mtvec_base) 
  begin : gen_mtvec_base_read_only
  
    assign mtvec_base_reg = l_core_static_mtvec_base[31:2];
  end
  else begin : gen_mtvec_base_writable

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (30),  
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mtvec_base
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({30{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtvec_base_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtvec_base_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtvec_base_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtvec_base_wr_data),
      .state_val                   (mtvec_base_reg)
    );
    
    
  end
  endgenerate

  assign mtvec_base      = {mtvec_base_reg,2'b00}; 
  assign mtvec           = {mtvec_base_reg,mtvec_mode}; 
  assign mtvec_rd_data   = mtvec & {L_XLEN{csr_reg_rd_sel.mtvec_sw_rd_sel}};
  
  assign csr_priv_mtvec_excpt_vectored = (mtvec_mode == 2'd1);
  assign csr_priv_mtvec_excpt_vec      = mtvec_base;
	
//mepc	
//  mepc_epc
  assign machine_implicit_wr_mepc_epc_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mepc_epc_wr_data = curr_pc[L_XLEN-1:1];
  assign machine_sw_wr_mepc_epc_wr_en         = csr_reg_wr_sel.mepc_sw_wr_sel;
  assign machine_sw_wr_mepc_epc_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (31),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mepc_epc
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({31{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mepc_epc_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mepc_epc_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mepc_epc_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mepc_epc_wr_data[L_XLEN-1:1]),
      .state_val                   (mepc_epc)
    );

  assign mepc           = {mepc_epc,1'b0}; 
  assign mepc_rd_data   = mepc & {L_XLEN{csr_reg_rd_sel.mepc_sw_rd_sel}};
	
//mcause	

//  mcause_excpt_code
  assign machine_init_wr_mcause_excpt_code_wr_en       = soft_reset_taken_retr;  // async reset handled seperately
  assign machine_init_wr_mcause_excpt_code_wr_data     = l_core_mcause_code_reset_state;
  assign machine_implicit_wr_mcause_excpt_code_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mcause_excpt_code_wr_data = cause_excpt_code;
  assign machine_sw_wr_mcause_excpt_code_wr_en         = csr_reg_wr_sel.mcause_sw_wr_sel;
  assign machine_sw_wr_mcause_excpt_code_wr_data       = csr_op_wr_data[4:0];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (5),  // 
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (l_core_mcause_code_reset_state)
    )
    u_csr_gpr_state_reg_mcause_excpt_code
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_mcause_excpt_code_wr_en),
      .init_wr_data                (machine_init_wr_mcause_excpt_code_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_mcause_excpt_code_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mcause_excpt_code_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mcause_excpt_code_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mcause_excpt_code_wr_data),
      .state_val                   (mcause_excpt_code)
    );
//  mcause_interrupt
  assign machine_init_wr_mcause_interrupt_wr_en       = soft_reset_taken_retr;  // async reset handled seperately
  assign machine_init_wr_mcause_interrupt_wr_data     = l_core_mcause_interrupt_reset_state;
  assign machine_implicit_wr_mcause_interrupt_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mcause_interrupt_wr_data = interrupt_taken;
  assign machine_sw_wr_mcause_interrupt_wr_en         = csr_reg_wr_sel.mcause_sw_wr_sel;
  assign machine_sw_wr_mcause_interrupt_wr_data       = csr_op_wr_data[31];

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),  // 
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mcause_interrupt
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_mcause_interrupt_wr_en),
      .init_wr_data                (machine_init_wr_mcause_interrupt_wr_data),
      .machine_implicit_wr_en      (machine_implicit_wr_mcause_interrupt_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mcause_interrupt_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mcause_interrupt_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mcause_interrupt_wr_data),
      .state_val                   (mcause_interrupt)
    );

  assign mcause           = {mcause_interrupt, {26{1'b0}}, mcause_excpt_code}; 
  assign mcause_rd_data   = mcause & {L_XLEN{csr_reg_rd_sel.mcause_sw_rd_sel}};
	

//  mtval
//  mtval_tval
  assign machine_implicit_wr_mtval_tval_wr_en   = trap_taken_internal;
  assign machine_implicit_wr_mtval_tval_wr_data = trap_val;
  assign machine_sw_wr_mtval_tval_wr_en         = csr_reg_wr_sel.mtval_sw_wr_sel;
  assign machine_sw_wr_mtval_tval_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (32),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mtval_tval
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({32{1'b0}}),
      .machine_implicit_wr_en      (machine_implicit_wr_mtval_tval_wr_en),
      .machine_implicit_wr_data    (machine_implicit_wr_mtval_tval_wr_data),
      .machine_sw_wr_en            (machine_sw_wr_mtval_tval_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mtval_tval_wr_data),
      .state_val                   (mtval_tval)
    );

  assign mtval           = mtval_tval; 
  assign mtval_rd_data   = mtval & {L_XLEN{csr_reg_rd_sel.mtval_sw_rd_sel}};

//mcounteren	
// Mcounteren is implemented as read-only and always reads 0 for mcounteren_cycle_count_en, mcounteren_timer_count_en, mcounteren_instret_count_en, mcounteren_hpm_count_en
// as there is no supervisor mode in core 

//  mcounteren_cycle_count_en
  assign mcounteren_cycle_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_timer_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_instret_count_en = 1'b0;
//	mcounteren_timer_count_en
  assign mcounteren_hpm_count_en = {29{1'b0}};

  assign mcounteren           = {mcounteren_hpm_count_en,mcounteren_instret_count_en,mcounteren_timer_count_en,mcounteren_cycle_count_en}; 
  assign mcounteren_rd_data   = mcounteren & {L_XLEN{csr_reg_rd_sel.mcounteren_sw_rd_sel}};

//mcounterinhibit	
//  mcounterinhibit_cycle_count_inh
  generate if(l_core_cfg_cycle_count_width > 0) 
  begin : gen_cycle_count_inh
  
    
    logic  machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en;
    logic  machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data;

    assign machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data       = csr_op_wr_data[0];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_cycle_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_cycle_count_inh_wr_data),
        .state_val                   (mcounterinhibit_cycle_count_inh)
      );
  end 
  else begin : ngen_cycle_count_inh
    assign mcounterinhibit_cycle_count_inh = 1'b0;
  end
  endgenerate
  
//  mcounterinhibit_instret_count_inh
  generate if(l_core_cfg_instret_count_width > 0) 
  begin : gen_instret_count_inh
    
    logic machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en;
    logic machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data;
  
    assign machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data       = csr_op_wr_data[2];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_instret_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                (1'b0),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_instret_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_instret_count_inh_wr_data),
        .state_val                   (mcounterinhibit_instret_count_inh)
      );
  end 
  else begin : ngen_instret_count_inh
    assign mcounterinhibit_instret_count_inh = 1'b0;
  end
  endgenerate
  
//  mcounterinhibit_hpm_count_inh
  generate if(l_core_cfg_num_hpm_counters > 0) 
  begin : gen_hpm_count_inh
  
  
  logic                                          machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en;
  logic [l_core_cfg_num_hpm_counters-1:0]   machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data;
  logic [l_core_cfg_num_hpm_counters-1:0]   mcounterinhibit_hpm_count_inh_reg; 
  

    assign machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en         = csr_reg_wr_sel.mcounterinhibit_sw_wr_sel;
    assign machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data       = csr_op_wr_data[l_core_cfg_num_hpm_counters-1:0];

      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (l_core_cfg_num_hpm_counters),
        .FIELD_RESET_EN      (0),
        .FIELD_RESET_VAL     (0)
      )
      u_csr_gpr_state_reg_mcounterinhibit_hpm_count_inh
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (1'b0),
        .init_wr_data                ({l_core_cfg_num_hpm_counters{1'b0}}),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    ({l_core_cfg_num_hpm_counters{1'b0}}),
        .machine_sw_wr_en            (machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_mcounterinhibit_hpm_count_inh_wr_data),
        .state_val                   (mcounterinhibit_hpm_count_inh_reg)
      );
      
      if(l_core_cfg_num_hpm_counters >= 29) // should not be greater than 29!
      begin : gen_assign_hpm_count_inh_eq29
        assign mcounterinhibit_hpm_count_inh = mcounterinhibit_hpm_count_inh_reg;
      end
      else begin : gen_assign_hpm_count_inh_lt29
        assign mcounterinhibit_hpm_count_inh = {{(29-l_core_cfg_num_hpm_counters){1'b0}}, mcounterinhibit_hpm_count_inh_reg};
      end

  end 
  else begin : ngen_hpm_count_inh
    assign mcounterinhibit_hpm_count_inh = {29{1'b0}};
  end
  endgenerate

  assign mcounterinhibit           = {mcounterinhibit_hpm_count_inh, 
                                      mcounterinhibit_instret_count_inh, 
                                      1'b0, 
                                      mcounterinhibit_cycle_count_inh}; 
  assign mcounterinhibit_rd_data   = mcounterinhibit & {L_XLEN{csr_reg_rd_sel.mcounterinhibit_sw_rd_sel}};
  
  	
//mscratch	
//  mscratch_scratch
  assign machine_sw_wr_mscratch_scratch_wr_en         = csr_reg_wr_sel.mscratch_sw_wr_sel;
  assign machine_sw_wr_mscratch_scratch_wr_data       = csr_op_wr_data;

    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (32),  
      .FIELD_RESET_EN      (0),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_mscratch_scratch
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (1'b0),
      .init_wr_data                ({32{1'b0}}),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    ({32{1'b0}}),
      .machine_sw_wr_en            (machine_sw_wr_mscratch_scratch_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_mscratch_scratch_wr_data),
      .state_val                   (mscratch_scratch)
    );

  assign mscratch           = mscratch_scratch; 
  assign mscratch_rd_data   = mscratch & {L_XLEN{csr_reg_rd_sel.mscratch_sw_rd_sel}};
  
//pmpcfg
// Core does not currently support memory protection, so pmp registers unused, group together
// however csrs are legally addressable

  assign pmpcfg_0_3           = {L_XLEN{1'b0}}; 
  assign pmpcfg_0_3_rd_data   = pmpcfg_0_3 & {L_XLEN{csr_reg_rd_sel.pmpcfg_0_3_sw_rd_sel}};
  
//pmpaddr
// Core does not currently support memory protection, so pmp registers unused, group together
// however csrs are legally addressable
  assign pmpaddr_0_15           = {L_XLEN{1'b0}}; 
  assign pmpaddr_0_15_rd_data   = pmpaddr_0_15 & {L_XLEN{csr_reg_rd_sel.pmpaddr_0_15_sw_rd_sel}};

// Supervisor Mode CSRs
//+++++++++++++++++++++  

// sedeleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign sedeleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sedeleg_rd_data   = sedeleg & {L_XLEN{csr_reg_rd_sel.sedeleg_sw_rd_sel}};
  
//sideleg	
// sideleg not implemented on core as it is machine only
// however csr is legally addressable 
  assign sideleg           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sideleg_rd_data   = sideleg & {L_XLEN{csr_reg_rd_sel.sideleg_sw_rd_sel}};
  
//stvec	
// stvec not implemented on core as it is machine only
// however csr is legally addressable 
  assign stvec           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign stvec_rd_data   = stvec & {L_XLEN{csr_reg_rd_sel.stvec_sw_rd_sel}};
  
//sepc	
// sepc not implemented on core as it is machine only
// however csr is legally addressable 
  assign sepc           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sepc_rd_data   = sepc & {L_XLEN{csr_reg_rd_sel.sepc_sw_rd_sel}};
  
//scause	
// scause not implemented on core as it is machine only
// however csr is legally addressable 
  assign scause           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign scause_rd_data   = scause & {L_XLEN{csr_reg_rd_sel.scause_sw_rd_sel}};
  
//stval	
// stval not implemented on core as it is machine only
// however csr is legally addressable 
  assign stval           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign stval_rd_data   = stval & {L_XLEN{csr_reg_rd_sel.stval_sw_rd_sel}};
  
//scounteren	
// scounteren not implemented on core as it is machine only
// however csr is legally addressable 
  assign scounteren           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign scounteren_rd_data   = scounteren & {L_XLEN{csr_reg_rd_sel.scounteren_sw_rd_sel}};
  
//sscratch	
// sscratch not implemented on core as it is machine only
// however csr is legally addressable 
  assign sscratch           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign sscratch_rd_data   = sscratch & {L_XLEN{csr_reg_rd_sel.sscratch_sw_rd_sel}};
  
//satp	
// satp not implemented on core as it is machine only
// however csr is legally addressable 
  assign satp           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign satp_rd_data   = satp & {L_XLEN{csr_reg_rd_sel.satp_sw_rd_sel}};

// User Mode CSRs
//+++++++++++++++++++++ 
 
//utvec	
// utvec not implemented on core as it is machine only
// however csr is legally addressable 
  assign utvec           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign utvec_rd_data   = utvec & {L_XLEN{csr_reg_rd_sel.utvec_sw_rd_sel}};
  
//uepc	
// uepc not implemented on core as it is machine only
// however csr is legally addressable 
  assign uepc           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign uepc_rd_data   = uepc & {L_XLEN{csr_reg_rd_sel.uepc_sw_rd_sel}};
  
//ucause	
// ucause not implemented on core as it is machine only
// however csr is legally addressable 
  assign ucause           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign ucause_rd_data   = ucause & {L_XLEN{csr_reg_rd_sel.ucause_sw_rd_sel}};
  
//utval	
// utval not implemented on core as it is machine only
// however csr is legally addressable 
  assign utval           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign utval_rd_data   = utval & {L_XLEN{csr_reg_rd_sel.utval_sw_rd_sel}};
  
//uscratch	
// uscratch not implemented on core as it is machine only
// however csr is legally addressable
  assign uscratch           = {L_XLEN{1'b0}}; // Machine mode only in core, so no delegation
  assign uscratch_rd_data   = uscratch & {L_XLEN{csr_reg_rd_sel.uscratch_sw_rd_sel}};
  
// cycle
// (up-to) 64-bit cycle counter
  generate if(l_core_cfg_cycle_count_width > 0) 
  begin : gen_cycle_count
  
    logic [l_core_cfg_cycle_count_width-1:0] next_count_inc;  
    assign next_count_inc = ~(debug_mode & dcsr_stopcount) ? (cycle_count[l_core_cfg_cycle_count_width-1:0] + 'd1) : 
                                                              cycle_count[l_core_cfg_cycle_count_width-1:0];    
    
    // cycle_count_lo
    if(l_core_cfg_cycle_count_width >= L_XLEN) 
    begin : gen_cycle_count_lo_gte_xlen
    
      logic [L_XLEN-1:0]                            cycle_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(csr_reg_wr_sel.mcycle_sw_wr_sel)
          cycle_count_reg_lo = csr_op_wr_data;
        else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
          cycle_count_reg_lo = next_count_inc[L_XLEN-1:0];
      end 
      
      assign cycle_count[L_XLEN-1:0] = cycle_count_reg_lo;
    
    end else begin :gen_cycle_count_lo_lt_xlen 
    
      logic [l_core_cfg_cycle_count_width-1:0]  cycle_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          cycle_count_reg_lo = {l_core_cfg_cycle_count_width{1'b0}};
        else if(csr_reg_wr_sel.mcycle_sw_wr_sel)
          cycle_count_reg_lo = csr_op_wr_data[l_core_cfg_cycle_count_width-1:0];
        else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
          cycle_count_reg_lo = next_count_inc[l_core_cfg_cycle_count_width-1:0];
      end 
      
      assign cycle_count[L_XLEN-1:0] = {{(L_XLEN-l_core_cfg_cycle_count_width){1'b0}},cycle_count_reg_lo}; 
    
    end
    
    // cycle_count_hi
    
    if(l_core_cfg_cycle_count_width > L_XLEN) 
    begin : gen_cycle_count_hi_gt_xlen
    
    
    
      if(l_core_cfg_cycle_count_width == L_XLEN*2) 
      begin : gen_cycle_count_hi_eq_2xlen
      
        logic [L_XLEN-1:0]    cycle_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width{1'b0}};
          else if(soft_reset_taken_retr)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width{1'b0}};
          else if(csr_reg_wr_sel.mcycleh_sw_wr_sel)
            cycle_count_reg_hi = csr_op_wr_data;
          else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
            cycle_count_reg_hi = next_count_inc[L_XLEN+:L_XLEN];
        end 
        
        assign cycle_count[L_XLEN+:L_XLEN] = cycle_count_reg_hi;
    
      end else begin :gen_cycle_count_hi_lt_xlen 
      
        logic [l_core_cfg_cycle_count_width-L_XLEN-1:0]    cycle_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width-L_XLEN{1'b0}};
          else if(soft_reset_taken_retr)
            cycle_count_reg_hi = {l_core_cfg_cycle_count_width-L_XLEN{1'b0}};
          else if(csr_reg_wr_sel.mcycleh_sw_wr_sel)
            cycle_count_reg_hi = csr_op_wr_data[l_core_cfg_cycle_count_width-L_XLEN-1:0];
          else if(cycle_executed && !mcounterinhibit_cycle_count_inh)
            cycle_count_reg_hi = next_count_inc[l_core_cfg_cycle_count_width-L_XLEN-1:0];
        end 
        
        assign cycle_count[L_XLEN+:L_XLEN] = {{((L_XLEN*2)-l_core_cfg_cycle_count_width){1'b0}},cycle_count_reg_hi}; 
    
      end
       
    end
    else begin :gen_cycle_count_hi_lte_xlen
      assign cycle_count[L_XLEN+:L_XLEN] = {L_XLEN{1'b0}};
    end
    
    assign cycle_count_irq_src = cycle_count[l_core_cfg_instret_count_width-1];

  end
  else begin : ngen_cycle_count 

    assign cycle_count          = {(L_XLEN*2){1'b0}}; 
    assign cycle_count_irq_src  = 1'b0; 

  end
  endgenerate


  assign ucycle_rd_data    = cycle_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.ucycle_sw_rd_sel}};
  assign mcycle_rd_data    = cycle_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.mcycle_sw_rd_sel}};


  assign ucycleh_rd_data    = cycle_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.ucycleh_sw_rd_sel}};
  assign mcycleh_rd_data    = cycle_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.mcycleh_sw_rd_sel}};
  
// time
// 64-bit time counter
// timer is external to core such that it can be shared across multiple cores
// ISA requires time to read 0 if not implemented


  generate if(l_core_cfg_time_count_width > 0) 
  begin : gen_time_ext
    assign utime  = time_count[0+:L_XLEN]; 
    assign utimeh = time_count[L_XLEN+:L_XLEN];
  end
  else begin : ngen_time_ext
    assign utime  = {L_XLEN{1'b0}};
    assign utimeh = {L_XLEN{1'b0}};
  end
  endgenerate

  assign utime_rd_data   = utime & {L_XLEN{csr_reg_rd_sel.utime_sw_rd_sel}};
  assign utimeh_rd_data   = utimeh & {L_XLEN{csr_reg_rd_sel.utimeh_sw_rd_sel}};
  
// instret
// (up-to) 64-bit instret counter
  generate if(l_core_cfg_instret_count_width > 0) 
  begin : gen_instret_count
  
    logic [l_core_cfg_instret_count_width-1:0] next_count_inc;  
    assign next_count_inc = ~(debug_mode & dcsr_stopcount) ? (instret_count[l_core_cfg_instret_count_width-1:0] + 'd1) :
                                                              instret_count[l_core_cfg_instret_count_width-1:0];    
    
    // instret_count_lo
    if(l_core_cfg_instret_count_width >= L_XLEN) 
    begin : gen_instret_count_lo_gte_xlen
    
      logic [L_XLEN-1:0]                            instret_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(csr_reg_wr_sel.minstret_sw_wr_sel)
          instret_count_reg_lo = csr_op_wr_data;
        else if(instr_retired && !mcounterinhibit_instret_count_inh)
          instret_count_reg_lo = next_count_inc[L_XLEN-1:0];
      end 
      
      assign instret_count[L_XLEN-1:0] = instret_count_reg_lo;
    
    end else begin :gen_instret_count_lo_lt_xlen 
    
      logic [l_core_cfg_instret_count_width-1:0]  instret_count_reg_lo;
    
      always @(posedge clk or negedge resetn)
      begin
        if(~resetn)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(soft_reset_taken_retr)
          instret_count_reg_lo = {l_core_cfg_instret_count_width{1'b0}};
        else if(csr_reg_wr_sel.minstret_sw_wr_sel)
          instret_count_reg_lo = csr_op_wr_data[l_core_cfg_instret_count_width-1:0];
        else if(instr_retired && !mcounterinhibit_instret_count_inh)
          instret_count_reg_lo = next_count_inc[l_core_cfg_instret_count_width-1:0];
      end 
      
      assign instret_count[L_XLEN-1:0] = {{(L_XLEN-l_core_cfg_instret_count_width){1'b0}},instret_count_reg_lo}; 
    
    end
    
    // instret_count_hi
    
    if(l_core_cfg_instret_count_width > L_XLEN) 
    begin : gen_instret_count_hi_gt_xlen
    
    
    
      if(l_core_cfg_instret_count_width == L_XLEN*2) 
      begin : gen_instret_count_hi_eq_2xlen
      
        logic [L_XLEN-1:0]    instret_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            instret_count_reg_hi = {l_core_cfg_instret_count_width{1'b0}};
          else if(soft_reset_taken_retr)
            instret_count_reg_hi = {l_core_cfg_instret_count_width{1'b0}};
          else if(csr_reg_wr_sel.minstreth_sw_wr_sel)
            instret_count_reg_hi = csr_op_wr_data;
          else if(instr_retired && !mcounterinhibit_instret_count_inh)
            instret_count_reg_hi = next_count_inc[L_XLEN+:L_XLEN];
        end 
        
        assign instret_count[L_XLEN+:L_XLEN] = instret_count_reg_hi;
    
      end else begin :gen_instret_count_hi_lt_xlen 
      
        logic [l_core_cfg_instret_count_width-L_XLEN-1:0]    instret_count_reg_hi;
    
        always @(posedge clk or negedge resetn)
        begin
          if(~resetn)
            instret_count_reg_hi = {l_core_cfg_instret_count_width-L_XLEN{1'b0}};
          else if(soft_reset_taken_retr)
            instret_count_reg_hi = {l_core_cfg_instret_count_width-L_XLEN{1'b0}};
          else if(csr_reg_wr_sel.minstreth_sw_wr_sel)
            instret_count_reg_hi = csr_op_wr_data[l_core_cfg_instret_count_width-L_XLEN-1:0];
          else if(instr_retired && !mcounterinhibit_instret_count_inh)
            instret_count_reg_hi = next_count_inc[l_core_cfg_instret_count_width-L_XLEN-1:0];
        end 
        
        assign instret_count[L_XLEN+:L_XLEN] = {{((L_XLEN*2)-l_core_cfg_instret_count_width){1'b0}},instret_count_reg_hi}; 
    
      end
       
    end
    else begin :gen_instret_count_hi_lte_xlen
      assign instret_count[L_XLEN+:L_XLEN] = {L_XLEN{1'b0}};
    end
    
    // generate interrupt when msb bit is set
    // this allows the instruction retired counter to have less bits than 64 to reduce area, and allow software to handle wrapping
    assign instret_count_irq_src = instret_count[l_core_cfg_instret_count_width-1];

  end
  else begin : ngen_instret_count 

    assign instret_count          = {(L_XLEN*2){1'b0}}; 
    assign instret_count_irq_src  = 1'b0;

  end
  endgenerate


  assign uinstret_rd_data    = instret_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.uinstret_sw_rd_sel}};
  assign minstret_rd_data    = instret_count[0+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.minstret_sw_rd_sel}};
  assign uinstreth_rd_data    = instret_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.uinstreth_sw_rd_sel}};
  assign minstreth_rd_data    = instret_count[L_XLEN+:L_XLEN] & {L_XLEN{csr_reg_rd_sel.minstreth_sw_rd_sel}};
  
//hpmcounter
// Core does not currently support hardware performance monitors
// however csrs are legally addressable
  assign hpmcounter_3_31_rd_data   = {L_XLEN{1'b0}};
  assign mhpmcounter_3_31_rd_data  = {L_XLEN{1'b0}};
  assign hpmcounter_3_31h_rd_data  = {L_XLEN{1'b0}};
  assign mhpmcounter_3_31h_rd_data = {L_XLEN{1'b0}};
  assign hpmevent_3_31_rd_data     = {L_XLEN{1'b0}}; 
  
  assign hpm_count_irq_src         = 1'b0;
  
// Debug and Trace CSRs
//++++++++++++++++++++++++++  

// Trace/trigger registers
// When implemented Core only supports address (execution) triggers)
// The number of triggers is defined by l_core_cfg_num_triggers
// When implemented trigger registers are accessible from debug mode or machine mode
// tselect is an index into the indirectly accessed tdata1 and tdata2 registers; 
// tdata3 is not used by core and always reads 0


// tselect 
  // can always write tselect when addressed as always in machine or debug mode

 
 generate if(l_core_cfg_num_triggers > 0) 
  begin : gen_tselect
  
    logic                                             machine_sw_wr_tselect_wr_en;    
    logic [l_core_cfg_trigger_select_width-1:0]  machine_sw_wr_tselect_wr_data;  
    logic                                             machine_init_wr_tselect_wr_en;  
    logic [l_core_cfg_trigger_select_width-1:0]  machine_init_wr_tselect_wr_data;
    logic [l_core_cfg_trigger_select_width-1:0]  tselect_reg; 
  
    assign machine_sw_wr_tselect_wr_en      = csr_reg_wr_sel.tselect_sw_wr_sel; 
    assign machine_sw_wr_tselect_wr_data    = csr_op_wr_data[l_core_cfg_trigger_select_width-1:0];
    assign machine_init_wr_tselect_wr_en    = soft_reset_taken_retr; //debug_reset_taken_retr | 
    assign machine_init_wr_tselect_wr_data  = {l_core_cfg_trigger_select_width{1'b0}};
    
    assign tselect_reg = 1'b0; // single HW Breakpoint operation

/*  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (l_core_cfg_trigger_select_width),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_tselect
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (machine_init_wr_tselect_wr_en),
      .init_wr_data                (machine_init_wr_tselect_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    ({l_core_cfg_trigger_select_width{1'b0}}),
      .machine_sw_wr_en            (machine_sw_wr_tselect_wr_en),
      .machine_sw_wr_data          (machine_sw_wr_tselect_wr_data),
      .state_val                   (tselect_reg)
    );
*/
    if(l_core_cfg_trigger_select_width < L_XLEN)
    begin : gen_partial_assign_tselect
      assign tselect           = {{(L_XLEN-l_core_cfg_trigger_select_width){1'b0}}, tselect_reg};
    end
    else begin : gen_full_assign_tselect
      assign tselect           = tselect_reg;
    end // end generate gen_full_assign_tselect
      
  end
  else begin : ngen_tselect
  
    assign tselect           = {L_XLEN{1'b0}};

  end
  endgenerate
  
  assign tselect_rd_data   = tselect & {L_XLEN{csr_reg_rd_sel.tselect_sw_rd_sel}};
  
  
// tdata<n> registers are implemented per-trigger, selected by tselect

   // tdata1, tdata 2

  genvar i_trig_tdata1_2;
  generate if(l_core_cfg_num_triggers > 0) 
  begin : gen_tdata1_2
  
    logic [L_XLEN-1:0]                                tdata1_mcontrol [l_core_cfg_num_triggers-1:0];
    logic [L_XLEN-1:0]                                tdata1_mcontrol_rd_data [l_core_cfg_num_triggers-1:0];
    logic                                             tdata1_mcontrol_sw_rd_sel [l_core_cfg_num_triggers-1:0];
    logic                                             tdata1_mcontrol_sw_wr_sel [l_core_cfg_num_triggers-1:0];
    logic [L_XLEN-1:0]                                tdata1_reg [l_core_cfg_num_triggers-1:0];
    
    logic [l_core_cfg_num_triggers-1:0]          trigger_match; 
    logic [l_core_cfg_num_triggers-1:0]          trigger_hit;
    logic [l_core_cfg_num_triggers-1:0]          per_trigger_excpt;
    logic [l_core_cfg_num_triggers-1:0]          per_trigger_debug;
    

    
    logic [L_XLEN-1:0]                                tdata2_reg [l_core_cfg_num_triggers-1:0];
   
    for(i_trig_tdata1_2 = 0; i_trig_tdata1_2 < l_core_cfg_num_triggers; i_trig_tdata1_2++)
    begin : gen_per_trig_tdata1 
    
      logic [3:0] tdata1_type;
      logic       tdata1_dmode;
      logic       machine_init_wr_tdata1_dmode_wr_en;
      logic       machine_init_wr_tdata1_dmode_wr_data;
      logic       machine_sw_wr_tdata1_dmode_wr_en;
      logic       machine_sw_wr_tdata1_dmode_wr_data;
      logic [5:0] tdata1_mcontrol_maskmax;
      logic       tdata1_mcontrol_hit;
      logic       machine_init_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_hit_wr_data;
      logic       machine_implicit_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_implicit_wr_tdata1_mcontrol_hit_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_hit_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_hit_wr_data;
      logic       tdata1_mcontrol_select;
      logic       machine_init_wr_tdata1_mcontrol_select_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_select_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_select_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_select_wr_data;
      logic       tdata1_mcontrol_timing;
      logic [1:0] tdata1_mcontrol_sizelo;
      logic [3:0] tdata1_mcontrol_action; 
      logic       tdata1_mcontrol_action_reg;
      logic       machine_init_wr_tdata1_mcontrol_action_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_action_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_action_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_action_wr_data;
      logic       tdata1_mcontrol_chain;
      logic [3:0] tdata1_mcontrol_match;
      logic       tdata1_mcontrol_m;
      logic       machine_init_wr_tdata1_mcontrol_m_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_m_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_m_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_m_wr_data;
      logic       tdata1_mcontrol_s;
      logic       tdata1_mcontrol_u;
      logic       tdata1_mcontrol_execute;
      logic       machine_init_wr_tdata1_mcontrol_execute_wr_en;
      logic       machine_init_wr_tdata1_mcontrol_execute_wr_data;
      logic       machine_sw_wr_tdata1_mcontrol_execute_wr_en;
      logic       machine_sw_wr_tdata1_mcontrol_execute_wr_data;
      logic       tdata1_mcontrol_store;
      logic       tdata1_mcontrol_load;
      
      logic               machine_init_wr_tdata2_match_data_wr_en;
      logic [L_XLEN-1:0]  machine_init_wr_tdata2_match_data_wr_data;
      logic               machine_sw_wr_tdata2_match_data_wr_en;
      logic [L_XLEN-1:0]  machine_sw_wr_tdata2_match_data_wr_data;
      
      logic [L_XLEN-1:0]  tdata2_match_data;
      
      logic [L_XLEN-1:0]  curr_match_data;
      logic               trigger_opcode_match;
      logic               trigger_iaddr_match;
      
      
      // tdata1_type[3:0]
      // Supports only type 2 (instruction address/opcode trigger)
      assign tdata1_type = 4'd2;

      // tdata1_dmode 
      // 0: Both Debug and M-mode can write the tdata
      // registers at the selected tselect.
      // 1: Only Debug Mode can write the tdata registers at the selected tselect. Writes from other
      // modes are ignored.
      // This bit is only writable from Debug Mode.
      
      assign tdata1_dmode = 1'b1; // Debug only triggers
/*      
      assign machine_init_wr_tdata1_dmode_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_dmode_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_dmode_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                      (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) & 
                                                      debug_mode;
      assign machine_sw_wr_tdata1_dmode_wr_data     = csr_op_wr_data[27];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_dmode
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_dmode_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_dmode_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_dmode_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_dmode_wr_data),
        .state_val                   (tdata1_dmode)
      );  
*/
      // tdata1_mcontrol_maskmax[5:0]
      // maskmax is always 0 for core 
      assign tdata1_mcontrol_maskmax = 6'd0;

      // tdata1_mcontrol_hit
      // indicates the trigger hit on the match
      
      assign trigger_hit[i_trig_tdata1_2]                     = excpt_trigger[i_trig_tdata1_2] & ~debug_mode;
      
      assign machine_init_wr_tdata1_mcontrol_hit_wr_en        = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_mcontrol_hit_wr_data      = 1'b0;
      assign machine_implicit_wr_tdata1_mcontrol_hit_wr_en    = trigger_hit[i_trig_tdata1_2];
      assign machine_implicit_wr_tdata1_mcontrol_hit_wr_data  = 1'b1;
      assign machine_sw_wr_tdata1_mcontrol_hit_wr_en          = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_hit_wr_data        = csr_op_wr_data[20];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_hit
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_hit_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_hit_wr_data),
        .machine_implicit_wr_en      (machine_implicit_wr_tdata1_mcontrol_hit_wr_en),
        .machine_implicit_wr_data    (machine_implicit_wr_tdata1_mcontrol_hit_wr_data),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_hit_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_hit_wr_data),
        .state_val                   (tdata1_mcontrol_hit)
      );  

      // tdata1_mcontrol_select
      // 0: Perform a match on the virtual address.
      // 1: Perform a match on the data value loaded or stored, or the instruction executed. 
      //    Core only supports instruction match, so this will be a match on the opcode
      
      assign tdata1_mcontrol_select = 1'b0; // address match only supported
/*      
      assign machine_init_wr_tdata1_mcontrol_select_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this use reset aligned to ex stage rather than retr?
      assign machine_init_wr_tdata1_mcontrol_select_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_select_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_select_wr_data     = csr_op_wr_data[19];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_select
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_select_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_select_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_select_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_select_wr_data),
        .state_val                   (tdata1_mcontrol_select)
      );  
*/

      // tdata1_mcontrol_timing 
      // Always 0 for Core as it follows the recommendation in the debug specification  
      // to perform address triggers just before the instruction is (or would have been) executed
      assign tdata1_mcontrol_timing  = 1'b0;


      // tdata1_mcontrol_sizelo [1:0]
      // Always 0 for Core as it only performs instruction/opcode matches of any size
      // Compressed opcode matches will automatically only match the bottom 16 bits of tdata2, ignoring the upper bits
      assign tdata1_mcontrol_sizelo  = 2'b00;

      // tdata1_mcontrol_action [3:0]
      // May only be 0 or 1, bits [3:1] will always be 0 in Core
      // 0 Raise a breakpoint exception. (Used when software wants to use the trigger module without an external debugger attached.)
      // 1 Enter Debug Mode. (Only supported when the triggers dmode is 1.)
      
      assign tdata1_mcontrol_action = 4'b0001; // debug entry only supported
/*      
      assign machine_init_wr_tdata1_mcontrol_action_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata1_mcontrol_action_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_action_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_action_wr_data     = csr_op_wr_data[12];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_action
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_action_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_action_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_action_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_action_wr_data),
        .state_val                   (tdata1_mcontrol_action_reg)
      );  
      
      assign tdata1_mcontrol_action = {3'b000,tdata1_mcontrol_action_reg};
*/
      // tdata1_mcontrol_chain
      // Always 0 in Core as it does not supported chained matches 
      assign tdata1_mcontrol_chain = 1'b0;

      // tdata1_mcontrol_match [3:0]
      // Always 0 in Core . Exact match only 
      assign tdata1_mcontrol_match = 4'd0;

      // tdata1_mcontrol_m 
      // When set, enable this trigger in M-mode.
      assign tdata1_mcontrol_m = 1'b1;

/*      
      assign machine_init_wr_tdata1_mcontrol_m_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this be reset aligned to ex rather than retr?
      assign machine_init_wr_tdata1_mcontrol_m_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_m_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                           (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                           ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_m_wr_data     = csr_op_wr_data[6];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_m
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_m_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_m_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_m_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_m_wr_data),
        .state_val                   (tdata1_mcontrol_m)
      );  
*/
      // tdata1_mcontrol_s 
      // When set, enable this trigger in S-mode.
      // Always 0 in core as Supervisor mode does not exist
      assign tdata1_mcontrol_s = 1'b0;

      // tdata1_mcontrol_u 
      // When set, enable this trigger in U-mode.
      // Always 0 in core as User mode does not exixt
      assign tdata1_mcontrol_u = 1'b0;

      // tdata1_mcontrol_execute 
      // When set, the trigger fires on the virtual address or opcode of an instruction that is executed.
      
      assign machine_init_wr_tdata1_mcontrol_execute_wr_en     = soft_reset_taken_retr; // | debug_reset_taken_retr; // REVISIT should this be reset aligned to ex stage rather than retr?
      assign machine_init_wr_tdata1_mcontrol_execute_wr_data   = 1'b0;
      assign machine_sw_wr_tdata1_mcontrol_execute_wr_en       = csr_reg_wr_sel.tdata1_sw_wr_sel & 
                                                                (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                                ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata1_mcontrol_execute_wr_data     = csr_op_wr_data[6];
      
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (1),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     (0)
      )
      u_tdata1_mcontrol_execute
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata1_mcontrol_execute_wr_en),
        .init_wr_data                (machine_init_wr_tdata1_mcontrol_execute_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    (1'b0),
        .machine_sw_wr_en            (machine_sw_wr_tdata1_mcontrol_execute_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata1_mcontrol_execute_wr_data),
        .state_val                   (tdata1_mcontrol_execute)
      );  

      // tdata1_mcontrol_store
      // Always 0 for Core as it only supports instruction matching 
      assign tdata1_mcontrol_store = 1'b0;

      // tdata1_mcontrol_load
      // Always 0 for Core as it only supports instruction matching 
      assign tdata1_mcontrol_load = 1'b0;
      
      assign tdata1_reg[i_trig_tdata1_2]          = {tdata1_type,
                                                     tdata1_dmode,
                                                     tdata1_mcontrol_maskmax,
                                                     tdata1_mcontrol_hit,
                                                     tdata1_mcontrol_select,
                                                     tdata1_mcontrol_timing,
                                                     tdata1_mcontrol_sizelo,
                                                     tdata1_mcontrol_action,
                                                     tdata1_mcontrol_chain,
                                                     tdata1_mcontrol_match,
                                                     tdata1_mcontrol_m,
                                                     1'b0,
                                                     tdata1_mcontrol_s,
                                                     tdata1_mcontrol_u,
                                                     tdata1_mcontrol_execute,
                                                     tdata1_mcontrol_store,
                                                     tdata1_mcontrol_load};
                                                   
      //tdata2
      
      assign machine_init_wr_tdata2_match_data_wr_en        = soft_reset_taken_retr; // | debug_reset_taken_retr;
      assign machine_init_wr_tdata2_match_data_wr_data      = {L_XLEN{1'b0}};
      assign machine_sw_wr_tdata2_match_data_wr_en          = csr_reg_wr_sel.tdata2_sw_wr_sel & 
                                                              (tselect[l_core_cfg_trigger_select_width-1:0] == i_trig_tdata1_2[l_core_cfg_trigger_select_width-1:0]) &
                                                              ((tdata1_dmode == 1'b0) | debug_mode);
      assign machine_sw_wr_tdata2_match_data_wr_data        = csr_op_wr_data[L_XLEN-1:0];
        
      miv_rv32_csr_gpr_state_reg
      #(
        .WIDTH               (L_XLEN),
        .FIELD_RESET_EN      (1),
        .FIELD_RESET_VAL     ({L_XLEN{1'b0}})
      )
      u_tdata2_match_data
      (
        .clk                         (clk),
        .resetn                      (resetn),
        .init_wr_en                  (machine_init_wr_tdata2_match_data_wr_en),
        .init_wr_data                (machine_init_wr_tdata2_match_data_wr_data),
        .machine_implicit_wr_en      (1'b0),
        .machine_implicit_wr_data    ({L_XLEN{1'b0}}),
        .machine_sw_wr_en            (machine_sw_wr_tdata2_match_data_wr_en),
        .machine_sw_wr_data          (machine_sw_wr_tdata2_match_data_wr_data),
        .state_val                   (tdata2_match_data)
      );  
    
      assign tdata2_reg[i_trig_tdata1_2]  = tdata2_match_data;
      
      // for each trigger, check if enabled and matches
                                                   
      assign curr_match_data                      = tdata2_reg[i_trig_tdata1_2];
      
      assign trigger_opcode_match                 = 1'b0;
      
//      assign trigger_opcode_match                 = ((curr_match_data[1:0] == 2'b11) ? (trigger_instruction_opcode == curr_match_data) :                // uncompressed match
//                                                                                       (trigger_instruction_opcode[15:0] == curr_match_data[15:0])) &   // compressed match
//                                                    trigger_instruction_valid;
                                                    
      assign trigger_iaddr_match                  = (trigger_instruction_address == curr_match_data[I_ADDR_WIDTH-1:0]) &  
                                                    trigger_instruction_valid;                                             
                                          
      assign trigger_match[i_trig_tdata1_2]       = ((tdata1_mcontrol_select == 1'b0) ? trigger_iaddr_match : trigger_opcode_match) &
                                                    tdata1_mcontrol_m &
                                                    tdata1_mcontrol_execute;     
      
      assign per_trigger_excpt[i_trig_tdata1_2]  = 1'b0;
      
//      assign per_trigger_excpt[i_trig_tdata1_2]  = trigger_hit[i_trig_tdata1_2] & ~tdata1_mcontrol_action[i_trig_tdata1_2]; 
      assign per_trigger_debug[i_trig_tdata1_2]  = trigger_hit[i_trig_tdata1_2] & tdata1_mcontrol_action[i_trig_tdata1_2]; 
       
      assign trigger_req[i_trig_tdata1_2]        = trigger_match[i_trig_tdata1_2];
                            
                                                 
    end // for-generate gen_per_trig_tdata1
    
    // mux per-trigger tdata1 registers based on tselect 
    
    assign tdata1 = tdata1_reg[tselect[l_core_cfg_trigger_select_width-1:0]];    
    assign tdata2 = tdata2_reg[tselect[l_core_cfg_trigger_select_width-1:0]]; 
    
    // as per debug spec, if separate triggers generate trap (breakpoint exception) and enter debug mode simulataneously
    // allowable behaviour is to do both (in n defined order), or just enter debug mode (with hit still updated, but no trap)
    // In Core l_cfg_core_trigger_both = 1 allows both debug enter and trap to be generated simultaneously
    // In this mode trap generation and the register updating side effects will occur as usual, with debug mode also entered
    // To make it appear as if a trap was executed DPC will be updated with the exception vector rather than the current program counter
    // When debug mode is exited, execution will resume at the trap vector.
    // In Core l_cfg_core_trigger_both = 0 prevents simultaneous generation and will only allow debug mode to be entered but 
    // any trap generation will be supressed 
    // In this case DPC will be loaded with the current PC as this would be the next instruction to execute (but it is suppressed from
    // updating state by debug enter)
    
    assign excpt_trigger_debug_taken = |per_trigger_debug;
    
    
    if(l_cfg_core_trigger_both) begin : gen_trigger_break_both
      assign excpt_trigger_break_taken           = (|per_trigger_excpt);
      assign excpt_trigger_dpc                   = curr_pc;
      assign excpt_trigger_break_taken_and_debug = excpt_trigger_break_taken; 
    end
    else begin : ngen_trigger_break_debug_pri
      assign excpt_trigger_break_taken           = (|per_trigger_excpt) & ~excpt_trigger_debug_taken;
      assign excpt_trigger_dpc                   = excpt_trigger_break_taken ? mtvec_base : curr_pc;
      assign excpt_trigger_break_taken_and_debug = 1'b0;
    end
    // endgenerate if l_cfg_core_trigger_both        
    
    
  end // if-generate gen_tdata1_2
  else begin : ngen_tdata1_2
    
    assign tdata1                              = {L_XLEN{1'b0}};
    assign tdata2                              = {L_XLEN{1'b0}}; 
    assign excpt_trigger_break_taken           = 1'b0; 
    assign excpt_trigger_debug_taken           = 1'b0;
    assign trigger_req[0]                      = 1'b0;
    assign excpt_trigger_break_taken_and_debug = 1'b0;
    
  end
  endgenerate
  
  assign tdata1_rd_data   = tdata1 & {L_XLEN{csr_reg_rd_sel.tdata1_sw_rd_sel}};
  assign tdata2_rd_data   = tdata2 & {L_XLEN{csr_reg_rd_sel.tdata2_sw_rd_sel}};                                                  

  
// tdata3 not implemented on core, but still legally addressable
  assign tdata3           = {L_XLEN{1'b0}}; 
  assign tdata3_rd_data   = tdata3 & {L_XLEN{csr_reg_rd_sel.tdata3_sw_rd_sel}}; 
  
// tinfo
// Not implemented as type is read-only. 
// Attempted accesses to this register will cause an illegal instruction exception 

// tcontrol
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// mcontext
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// scontext
// Not implemented 
// Attempted accesses to this register will cause an illegal instruction exception 

// Debug registers
//----------------
  
  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug
  
    logic                             next_debug_reset_pending; 
    logic                             debug_reset_pending;
    logic                             debugger_wr_dcsr_ebreakm_wr_en;    
    logic                             debugger_wr_dcsr_ebreakm_wr_data;  
    logic                             init_wr_dcsr_ebreakm_en;  
    logic                             init_wr_dcsr_ebreakm_wr_data;    
    logic                             debugger_wr_dcsr_stepie_wr_en;    
    logic                             debugger_wr_dcsr_stepie_wr_data;  
    logic                             init_wr_dcsr_stepie_en;  
    logic                             init_wr_dcsr_stepie_wr_data;
    logic                             debugger_wr_dcsr_stopcount_wr_en;    
    logic                             debugger_wr_dcsr_stopcount_wr_data;  
    logic                             init_wr_dcsr_stopcount_en;  
    logic                             init_wr_dcsr_stopcount_wr_data;
    logic                             debugger_wr_dcsr_stoptime_wr_en;    
    logic                             debugger_wr_dcsr_stoptime_wr_data;  
    logic                             init_wr_dcsr_stoptime_en;  
    logic                             init_wr_dcsr_stoptime_wr_data;
    logic                             init_wr_dcsr_cause_en;  
    logic [2:0]                       init_wr_dcsr_cause_wr_data;  
    logic                             implicit_wr_dcsr_cause_en;  
    logic [2:0]                       implicit_wr_dcsr_cause_wr_data;
    logic                             debugger_wr_dcsr_step_wr_en;    
    logic                             debugger_wr_dcsr_step_wr_data;  
    logic                             init_wr_dcsr_step_en;  
    logic                             init_wr_dcsr_step_wr_data;
    logic                             debugger_wr_dpc_pc_wr_en;    
    logic [I_ADDR_WIDTH-1:0]          debugger_wr_dpc_pc_wr_data;  
    logic                             init_wr_dpc_pc_en;  
    logic [I_ADDR_WIDTH-1:0]          init_wr_dpc_pc_wr_data; 
    logic                             implicit_wr_dpc_pc_en;  
    logic [I_ADDR_WIDTH-1:0]          implicit_wr_dpc_pc_wr_data; 
    logic                             trigger_debug_enter_pending; 
    logic                             set_trigger_debug_enter_pending;
    logic                             clr_trigger_debug_enter_pending; 
    logic                             ebreak_debug_enter_req;
    logic                             trigger_debug_enter_req;     
    logic                             set_haltreq_debug_enter_pending;
    logic                             clr_haltreq_debug_enter_pending;
    logic                             haltreq_debug_enter_pending;
    logic                             set_resethaltreq_debug_enter_pending;
    logic                             clr_resethaltreq_debug_enter_pending;
    logic                             resethaltreq_debug_enter_pending;    
    logic                             set_step_debug_enter_pending;
    logic                             clr_step_debug_enter_pending;
    logic                             step_debug_enter_pending;
    
    
  // Need to ensure debug_reset occurs (debug_reset_taken_retr asserted) only when an instruction is completing
  // to ensure reset handling instruction is inserted without anything outstanding in the retr stage
  // stage.
  // Reset must take priority over new instructions and must happen if no instructions in flight
  
  assign next_debug_reset_pending = (debug_reset_pending & ~debug_reset_taken_retr) | debug_reset;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      debug_reset_pending <= 1'b0;
    else
      debug_reset_pending <= next_debug_reset_pending;
  end
  
  assign debug_reset_taken_retr = debug_reset_pending & (instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req;    
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      debug_active_retr  <= 1'b0;
    else
      if((instr_completing_retr | ~instr_valid_retr) & ~debug_mode_enter_req)
        debug_active_retr <= debug_active;
  end

    
    // DCSR
    //xdebugver [3:0]
    // read only, fixed at 4'd4 when debug implemented      
    assign dcsr_xdebugver = 4'd4;

    //ebreakm     
    assign debugger_wr_dcsr_ebreakm_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_ebreakm_wr_data  = csr_op_wr_data[15];
    assign init_wr_dcsr_ebreakm_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_ebreakm_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_ebreakm
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_ebreakm_en),
      .init_wr_data                (init_wr_dcsr_ebreakm_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_ebreakm_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_ebreakm_wr_data),
      .state_val                   (dcsr_ebreakm)
    );
    
    //ebreaks
    assign dcsr_ebreaks = 1'b0;

    //ebreaku
    assign dcsr_ebreaku = 1'b0;
    
    //stepie   
    assign debugger_wr_dcsr_stepie_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stepie_wr_data  = csr_op_wr_data[11];
    assign init_wr_dcsr_stepie_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stepie_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stepie
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stepie_en),
      .init_wr_data                (init_wr_dcsr_stepie_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stepie_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stepie_wr_data),
      .state_val                   (dcsr_stepie)
    );
    
    //stopcount   
    assign debugger_wr_dcsr_stopcount_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stopcount_wr_data  = csr_op_wr_data[10];
    assign init_wr_dcsr_stopcount_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stopcount_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stopcount
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stopcount_en),
      .init_wr_data                (init_wr_dcsr_stopcount_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stopcount_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stopcount_wr_data),
      .state_val                   (dcsr_stopcount)
    );
    
    //stoptime   
    assign debugger_wr_dcsr_stoptime_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_stoptime_wr_data  = csr_op_wr_data[9];
    assign init_wr_dcsr_stoptime_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_stoptime_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_stoptime
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_stoptime_en),
      .init_wr_data                (init_wr_dcsr_stoptime_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_stoptime_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_stoptime_wr_data),
      .state_val                   (dcsr_stoptime)
    );
    
    //cause   
    // Note , Not writeable by debugger
    assign init_wr_dcsr_cause_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_cause_wr_data      = 3'b000;
    assign implicit_wr_dcsr_cause_en       = debug_enter_taken;
    assign implicit_wr_dcsr_cause_wr_data  = trigger_debug_enter_taken ? 3'd2 :
                                               ebreak_debug_enter_taken ? 3'd1 :
                                                 resethaltreq_debug_enter_taken ? 3'd5 :
                                                    haltreq_debug_enter_taken ? 3'd3 :
                                                      step_debug_enter_taken ? 3'd4 : 3'd0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (3),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_cause
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_cause_en),
      .init_wr_data                (init_wr_dcsr_cause_wr_data),
      .machine_implicit_wr_en      (implicit_wr_dcsr_cause_en),
      .machine_implicit_wr_data    (implicit_wr_dcsr_cause_wr_data),
      .machine_sw_wr_en            (1'b0),
      .machine_sw_wr_data          (3'b000),
      .state_val                   (dcsr_cause)
    );

    //mprven    
    assign dcsr_mprven  = 1'b0;
    
    //nmip
    assign dcsr_nmip = 1'b0; // REVISIT does soft reset count as this?

    //step   
    assign debugger_wr_dcsr_step_wr_en    = csr_reg_wr_sel.dcsr_debugger_wr_sel; 
    assign debugger_wr_dcsr_step_wr_data  = csr_op_wr_data[2];
    assign init_wr_dcsr_step_en           = debug_reset_taken_retr;
    assign init_wr_dcsr_step_wr_data      = 1'b0;
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (1),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (0)
    )
    u_csr_gpr_state_reg_dcsr_step
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dcsr_step_en),
      .init_wr_data                (init_wr_dcsr_step_wr_data),
      .machine_implicit_wr_en      (1'b0),
      .machine_implicit_wr_data    (1'b0),
      .machine_sw_wr_en            (debugger_wr_dcsr_step_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dcsr_step_wr_data),
      .state_val                   (dcsr_step)
    );
    
    // prv
    assign dcsr_prv = 2'd3; // Core can only ever be in machine mode when debug entered
    
    //DPC
    
    //pc   
    assign debugger_wr_dpc_pc_wr_en    = csr_reg_wr_sel.dpc_debugger_wr_sel; 
    assign debugger_wr_dpc_pc_wr_data  = csr_op_wr_data[I_ADDR_WIDTH-1:0];
    assign init_wr_dpc_pc_en           = soft_reset_taken_retr;
    assign init_wr_dpc_pc_wr_data      = l_core_reset_vector;
    assign implicit_wr_dpc_pc_en       = debug_enter_taken & ~debug_mode;  // don't update dpc if already in debug mode as the next instruction is already in dpc
    assign implicit_wr_dpc_pc_wr_data  = trigger_debug_enter_taken ? excpt_trigger_dpc : // <CL> Update dpc on trigger_debug_enter_taken
                                          ebreak_debug_enter_taken ? excpt_trigger_dpc :  // trigger is handled as ebreak 
                                           resethaltreq_debug_enter_taken ? l_core_reset_vector : 
                                              haltreq_debug_enter_taken ? curr_pc :                           
                                                step_debug_enter_taken ? curr_pc : dpc_reg; 
  
    miv_rv32_csr_gpr_state_reg
    #(
      .WIDTH               (I_ADDR_WIDTH),
      .FIELD_RESET_EN      (1),
      .FIELD_RESET_VAL     (l_core_reset_vector)
    )
    u_csr_gpr_state_reg_dpc_pc
    (
      .clk                         (clk),
      .resetn                      (resetn),
      .init_wr_en                  (init_wr_dpc_pc_en),
      .init_wr_data                (init_wr_dpc_pc_wr_data),
      .machine_implicit_wr_en      (implicit_wr_dpc_pc_en),
      .machine_implicit_wr_data    (implicit_wr_dpc_pc_wr_data),
      .machine_sw_wr_en            (debugger_wr_dpc_pc_wr_en),  
      .machine_sw_wr_data          (debugger_wr_dpc_pc_wr_data),
      .state_val                   (dpc_reg)
    );
    

  // debug state entry/exit
    
  // step 
  // When step is enabled and not in debug mode, execute an instruction then enter debug mode
  // 
  // Step can only be enabled when in debug mode, therefore the pipline will already be flushed on exiting debug mode (resume request) to perform the step
  // by branching to DPC (debug exit branch pseudo instruction branching to the instruction to execute)
  // Step can only be disabled when in debug mode, therefore resumption is a normal resume request causing debug exit branch to execute  
  
    assign set_step_debug_enter_pending = dcsr_step & ~debug_mode & step_instruction_valid;
    assign clr_step_debug_enter_pending = step_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        step_debug_enter_pending <= 1'b0;
      else
        if(set_step_debug_enter_pending | clr_step_debug_enter_pending)
          step_debug_enter_pending <= set_step_debug_enter_pending & ~clr_step_debug_enter_pending;
    end
    
    assign step_debug_enter_taken  = step_debug_enter_pending & debug_instr_debug_enter_req;
  
 
    
  // trigger/ebreak
  // enter debug mode when dcsr_ebreakm = 1 and the debugger is attached (debug_active_retr = 1), else raise ebreak exception
  // enter debug mode when trigger taken and the debugger is attached (debug_active_retr = 1), else raise ebreak exception
  
    // pending keeps track of any triggers in the pipeline pending and not yet taken.
    // Trigger may cause a debug-entry, or may cause an exception, but still use to generate debug entry req
    // because even if exception, rather than debug taken by the time the request reaches the retr stage,
    // would still have had to flush the pipeline (which happens for trap or debug entry)

    assign set_trigger_debug_enter_pending = |trigger_req; 
    assign clr_trigger_debug_enter_pending = flush | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        trigger_debug_enter_pending <= 1'b0;
      else
        if(set_trigger_debug_enter_pending | clr_trigger_debug_enter_pending)
          trigger_debug_enter_pending <= set_trigger_debug_enter_pending & ~clr_trigger_debug_enter_pending;
    end
    
    assign ebreak_debug_enter_req     = (excpt_breakpoint & dcsr_ebreakm) & debug_active_retr;
    assign ebreak_debug_enter_taken   = ebreak_debug_enter_req & instr_valid_retr; 
        
    assign trigger_debug_enter_req     = excpt_trigger_debug_taken & debug_active_retr;
    assign trigger_debug_enter_taken    = trigger_debug_enter_req & instr_valid_retr;
  
  // haltreq (from debug module)
  
  // When a halt is requested, the instruction at the DE stage is marked as a debug request, which will suppress any architectural state updates
  // associated with thre marked instruction. All subsequent instructions will be marked, which will prevent any following load-store 
  // instructions being launched in the EX phase
  // when the marked instruction reaches the retr stage, halt_debug_taken will be asserted which will suppress any instructions state updates, and
  // (so this instruction will appear to have not executed at all) and enter debug mode     
  
    assign set_haltreq_debug_enter_pending = debug_halt_req; 
    assign clr_haltreq_debug_enter_pending = haltreq_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        haltreq_debug_enter_pending <= 1'b0;
      else
        if(set_haltreq_debug_enter_pending | clr_haltreq_debug_enter_pending)
          haltreq_debug_enter_pending <= set_haltreq_debug_enter_pending & ~clr_haltreq_debug_enter_pending;
    end

    assign haltreq_debug_enter_taken  = (haltreq_debug_enter_pending & debug_instr_debug_enter_req) | 
                                        (debug_mode & debug_halt_req);
    assign debug_halt_ack             = haltreq_debug_enter_taken |
                                        (debug_halt_req & debug_enter_taken); // take care of corner case when enter debug due to other cause
                                                                              // at same time as req 

  // resethaltreq 
  
  // When a resethalt is requested and reset is assrted, the normal reset mechanism will cause the pipeline to be flushed, and a branch to reset pseudo instruction
  // (branch to reset vector) inserted into the DE stage, this will also cause resetable architectural state to be reset.
  // The debug enter pending will occur immediatel yafter this which using the normal debug entry mechanism, will cause all subsequent instruction (or inserted debug nops)
  // to be marked as debug entry and supressed. Note that the reset branch will cause instructions behind it to be flushed, but the debug entry pending will
  // persist until it reaches the retire stage at which point debug mode will be entered and resethalt_ack asserted
     
  
    assign set_resethaltreq_debug_enter_pending = debug_resethalt_req & soft_reset_taken_retr; 
    assign clr_resethaltreq_debug_enter_pending = resethaltreq_debug_enter_taken | debug_enter_taken;      
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        resethaltreq_debug_enter_pending <= 1'b0;
      else
        if(set_resethaltreq_debug_enter_pending | clr_resethaltreq_debug_enter_pending)
          resethaltreq_debug_enter_pending <= set_resethaltreq_debug_enter_pending & ~clr_resethaltreq_debug_enter_pending;
    end

    assign resethaltreq_debug_enter_taken  = resethaltreq_debug_enter_pending & debug_instr_debug_enter_req;
                                             
    assign debug_resethalt_ack            = resethaltreq_debug_enter_taken |
                                             (debug_resethalt_req & debug_enter_taken); // take care of corner case when enter debug due to other cause
                                                                                             // at same time as req

    // request to the start of the pipeline to mark debug entry request
    assign debug_mode_enter_req       = resethaltreq_debug_enter_pending | haltreq_debug_enter_pending | step_debug_enter_pending | trigger_debug_enter_pending; 
    
    assign debug_enter_taken          = ebreak_debug_enter_taken | 
                                        trigger_debug_enter_taken | 
                                        resethaltreq_debug_enter_taken |
                                        haltreq_debug_enter_taken | 
                                        step_debug_enter_taken;
                                        
    assign debug_exit_taken           = debug_mode & (debug_resume_req | debug_reset_taken_retr | soft_reset_taken_retr);           
    assign debug_resume_ack           = debug_exit_taken & ~debug_reset_taken_retr;              
    
    // instructions should not retire when debug mode is entered, except when entry is caused by an ebreak instruction
    // entry due to an ebreak instruction should not be masked. Not ebreak is higher priority than haltreq or step
    assign debug_mode_retire_mask     = trigger_debug_enter_taken | 
                                        (resethaltreq_debug_enter_taken & ~ebreak_debug_enter_taken) |
                                        (haltreq_debug_enter_taken & ~ebreak_debug_enter_taken) |
                                        (step_debug_enter_taken  & ~ebreak_debug_enter_taken);    
                              
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        debug_mode  <= 1'b0;
      else
        if(debug_enter_taken | debug_exit_taken)
          debug_mode  <= debug_enter_taken & ~debug_exit_taken;
    end
      
  end  // end if-generate gen_debug
  else begin : ngen_debug
  
    assign debug_reset_taken_retr     = 1'b0;
    assign debug_active_retr          = 1'b0;
  
    // DCSR
    assign dcsr_xdebugver =  4'd0;
    assign dcsr_ebreakm   =  1'b0;
    assign dcsr_ebreaks   =  1'b0;
    assign dcsr_ebreaku   =  1'b0;
    assign dcsr_stepie    =  1'b0;
    assign dcsr_stopcount =  1'b0;
    assign dcsr_stoptime  =  1'b0;
    assign dcsr_cause     =  3'd0;
    assign dcsr_mprven    =  1'b0;
    assign dcsr_nmip      =  1'b0;
    assign dcsr_step      =  1'b0;
    assign dcsr_prv       =  2'd3;
    
    // DPC
    assign dpc_reg = {I_ADDR_WIDTH{1'b0}};
    
    assign debug_mode             = 1'b0;
    assign debug_halt_ack         = 1'b0;
    assign debug_resethalt_ack    = 1'b0;
    assign debug_resume_ack       = 1'b0;
    assign debug_enter_taken      = 1'b0;  
    assign debug_mode_retire_mask = 1'b0;   
    assign debug_exit_taken       = 1'b0; 
    assign debug_mode_enter_req   = 1'b0;
    
    assign step_debug_enter_taken = 1'b0;   
    assign resethaltreq_debug_enter_taken = 1'b0;    
    assign haltreq_debug_enter_taken = 1'b0; 
    assign trigger_debug_enter_taken = 1'b0; 
    assign ebreak_debug_enter_taken = 1'b0;  
    
        
  end
  endgenerate
     
  
  assign debug_mode_enter       = debug_enter_taken;                          
  assign debug_mode_exit        = debug_exit_taken;  
  
  assign dcsr = {dcsr_xdebugver,
                 {12{1'b0}},
                 dcsr_ebreakm, 
                 1'b0, 
                 dcsr_ebreaks,  
                 dcsr_ebreaku,  
                 dcsr_stepie,   
                 dcsr_stopcount,
                 dcsr_stoptime, 
                 dcsr_cause,  
                 1'b0,  
                 dcsr_mprven,   
                 dcsr_nmip,     
                 dcsr_step,     
                 dcsr_prv};                      
  
  assign dcsr_rd_data   = dcsr & {L_XLEN{csr_reg_rd_sel.dcsr_debugger_rd_sel}};
  
  generate if(I_ADDR_WIDTH < L_XLEN) begin : gen_assign_partial_addr_dpc
    assign dpc = {{(L_XLEN-I_ADDR_WIDTH){1'b0}},dpc_reg};
  end
  else begin : gen_assign_full_addr_dpc 
    assign dpc = dpc_reg[I_ADDR_WIDTH-1:0];
  end // end if-generate
  endgenerate
  
  assign dpc_rd_data   = dpc & {L_XLEN{csr_reg_rd_sel.dpc_debugger_rd_sel}};

 // DSCRATCH0  
  assign dscratch0 = {L_XLEN{1'b0}};
  assign dscratch0_rd_data = dscratch0 & {L_XLEN{csr_reg_rd_sel.dscratch0_debugger_rd_sel}};
  
 // DSCRATCH1  
  assign dscratch1 = {L_XLEN{1'b0}};
  assign dscratch1_rd_data = dscratch1 & {L_XLEN{csr_reg_rd_sel.dscratch1_debugger_rd_sel}};

// read mux
// ---------
// read data from each register already masked with rd_enable so just need to "or"
	
  assign csr_op_rd_data = mvendorid_rd_data |
                          marchid_rd_data |                         
                          mimpid_rd_data |
                          mhartid_rd_data |
                          mstatus_rd_data |
                          sstatus_rd_data |
                          ustatus_rd_data |
                          misa_rd_data |
                          medeleg_rd_data |
                          mideleg_rd_data |
                          mie_rd_data |
                          sie_rd_data |
                          uie_rd_data |
                          mip_rd_data |
                          sip_rd_data |
                          uip_rd_data |
                          mtvec_rd_data |
                          mepc_rd_data |
                          mcause_rd_data |
                          mtval_rd_data |
                          mcounteren_rd_data |
                          mcounterinhibit_rd_data |
                          mscratch_rd_data |
                          pmpcfg_0_3_rd_data |
                          pmpaddr_0_15_rd_data |
                          sideleg_rd_data |
                          sedeleg_rd_data |
                          stvec_rd_data |
                          sepc_rd_data |
                          scause_rd_data |
                          stval_rd_data | 
                          scounteren_rd_data |
                          sscratch_rd_data |
                          satp_rd_data |
                          utvec_rd_data |
                          uepc_rd_data |
                          ucause_rd_data |
                          utval_rd_data | 
                          uscratch_rd_data |
                          ucycle_rd_data |
                          ucycleh_rd_data |
                          mcycle_rd_data |
                          mcycleh_rd_data |
                          utime_rd_data |
                          utimeh_rd_data |
                          uinstret_rd_data |
                          uinstreth_rd_data |
                          minstret_rd_data |
                          minstreth_rd_data |
                          hpmcounter_3_31_rd_data |
                          hpmcounter_3_31h_rd_data |
                          mhpmcounter_3_31_rd_data |
                          mhpmcounter_3_31h_rd_data |
                          hpmevent_3_31_rd_data |
                          tselect_rd_data |
                          tdata1_rd_data |
                          tdata2_rd_data |
                          tdata3_rd_data |
                          dcsr_rd_data |
                          dpc_rd_data |
                          dscratch0_rd_data |
                          dscratch1_rd_data;
                          
  assign debug_csr_op_rd_data = csr_op_rd_data;  
  assign debug_csr_op_rd_data_valid = debug_mode & csr_op_rd_valid;                            
  assign csr_op_rd_data_valid = 1'b1;                                             
  
  // csr write hazard detetction  
                             
  // op ready when external operands are valid for write, or always for read only
  assign csr_op_ready = csr_alu_wr_op_ready; 
  
  // assign CSR regsister/privileged state/intermediate values used elsewhere
    assign csr_priv_misa              = misa;  
    assign csr_priv_cause_excpt_code  = mcause_excpt_code;
    assign csr_priv_soft_reset_taken  = soft_reset_taken_retr; 
    assign csr_priv_interrupt_taken   = interrupt_taken;   
    assign csr_priv_priv_mode         = priv_mode;
    assign csr_priv_debug_mode        = debug_mode;  
    assign csr_priv_epc               = mepc;  
    assign csr_priv_dpc               = dpc;     
                             
// Wait for interrupt handling
// When a wait for interrupt instruction is retired, if no unmasked interrupts are pending (masked in ie, global ie ignored) then wfi_waiting will be asserted 
// causing the pipeline to stall until an unmasked interrupt is received. 
// If no interrupts are enabled in ie when the wfi instruction is retired, execution will continue without asserting wfi_waiting.
// If debug mode is entered (ebreak executed, triggered, hakltreq set, or stepped) whilst the wfi instruction is retired or wfi_waiting is asserted, wfi_waiting 
// will be deasserted.
// If soft reset is asserted, wfi_waiting will be deasserted
// Clear WFI when an interrupt source is captured for a locally enabled interrupt. Use this insted of local enable & pending, because pending is only asserted
// when it is safe to commit an interrupt - this includes the instr_valid_retr term because it is necessary to have a valid PC in the retr stage to put in mepc 
// when the interrupt is taken. This may not be present when waifting for an interrupt, therefore pending cannot be set. This is necessary because the interrupt
// should not be taken until the pc for the next instruction is present as defined in section 3.2.3 of the RISC-V architecture

  assign set_wfi_waiting = (instr_wfi & instr_valid_retr & (|mie)); 
  assign clr_wfi_waiting = soft_reset_taken_retr | debug_enter_taken | locally_enabled_irq_captured; //(|(mip & mie));
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      wfi_waiting_reg <= 1'b0;
    else
      if(set_wfi_waiting | clr_wfi_waiting)
        wfi_waiting_reg <= set_wfi_waiting & ~clr_wfi_waiting;
  end   
  
  assign wfi_waiting =   wfi_waiting_reg | set_wfi_waiting; // & ~clr_wfi_waiting);                           

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // hart id must be static
  assert_csr_priv_hartid_static : assert property (@(posedge clk) disable iff (~resetn)
                                                   $stable(hart_id));
  
  // A WFI instruction will always complete straight away
  assert_csr_priv_wfi_retire_immediately : assert property (@(posedge clk) disable iff (~resetn)
                                                            (instr_valid_retr & instr_wfi & ~debug_enter_taken) |-> instr_retired);
                                                            
  // can never be in debug mode when debug_active_retr is not asserted
  assert_csr_priv_never_debug_when_not_active : assert property (@(posedge clk) disable iff (~resetn)
                                                            debug_mode |-> debug_active_retr);
                                                            
  // If waiting for an interrupt, will eventually resume
  assert_csr_priv_wfi_eventually_resume : assert property (@(posedge clk) disable iff (~resetn)
                                                            wfi_waiting |-> ##[0:$] clr_wfi_waiting);                                                            


  cover_csr_priv_wfi_taken_wait: cover property (@(posedge clk) disable iff (~resetn)    
                                                      (!(soft_reset_taken_retr | debug_enter_taken)) throughout((set_wfi_waiting & ~clr_wfi_waiting) ##1
                                                                                                                (~set_wfi_waiting & ~clr_wfi_waiting)));                                                            
                                                            
  cover_csr_priv_wfi_taken_wait_exit: cover property (@(posedge clk) disable iff (~resetn)    
                                                      (!(soft_reset_taken_retr | debug_enter_taken)) throughout((set_wfi_waiting & ~clr_wfi_waiting) ##1
                                                                                                                (~set_wfi_waiting & ~clr_wfi_waiting) ##[1:$]
                                                                                                             (~set_wfi_waiting & clr_wfi_waiting)));
  
  // Exception properties
  
  cover_csr_priv_excpt_i_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_i_addr_misalign);      
                                              
  cover_csr_priv_excpt_i_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_i_access_fault);  
                                              
  cover_csr_priv_excpt_illegal_instr_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_illegal_instr);    
                                              
  cover_csr_priv_excpt_ebreak_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ebreak);
                                              
  cover_csr_priv_excpt_trigger_break_taken_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_trigger_break_taken);                                                                                                                                                                                           

  cover_csr_priv_excpt_ld_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ld_addr_misalign);  
                                              
  cover_csr_priv_excpt_ld_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_ld_access_fault); 
                                                                                            
  cover_csr_priv_excpt_str_amo_addr_misalign_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_str_amo_addr_misalign);  
                                              
  cover_csr_priv_excpt_str_amo_access_fault_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_str_amo_access_fault);    
                                              
  cover_csr_priv_excpt_m_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_m_env_call);  
                                              
  cover_csr_priv_excpt_s_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_s_env_call); 
                                              
  cover_csr_priv_excpt_u_env_callt_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_u_env_call);   
                                              
  cover_csr_priv_excpt_bus_error_i_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_bus_error_i);
                                              
  cover_csr_priv_excpt_parity_error_i_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_parity_error_i);                                                                                                                                                                                                                                                                                                                           
                                                     
  cover_csr_priv_excpt_bus_error_d_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_bus_error_d);
                                              
  cover_csr_priv_excpt_parity_error_d_seen: cover property (@(posedge clk) disable iff (~resetn)
                                              excpt_parity_error_d); 
  
  
  // covers
  //-------
  genvar i_cover_step_seq;
  generate if(l_core_cfg_hw_debug != 0) 
  begin : gen_debug_covers
  
    // step
  
    sequence seq_csr_priv_step_exec;
      (step_debug_enter_taken ##[1:$] debug_exit_taken ##[1:$] instr_retired);
    endsequence
  
   // sequence seq_csr_priv_step_repeat_exec(cycles);
   //   seq_csr_priv_step_exec[->cycles];
   // endsequence
  
    // enter debug mode when stepping
  
    cover_csr_priv_debug_enter_step: cover property (@(posedge clk) disable iff (~resetn)
                                                      step_debug_enter_taken);

    // enter debug after step, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_step: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired ##[1:$] 
                                                                                                                                   step_debug_enter_taken ##[1:$] 
                                                                                                                                   debug_exit_taken ##[1:$] 
                                                                                                                                   instr_retired));
 
    // perform multiple steps
  
    cover_csr_priv_debug_step: cover property (@(posedge clk) disable iff (~resetn)
                                                 ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(seq_csr_priv_step_exec ##[1:$] 
                                                                                                                               seq_csr_priv_step_exec ##[1:$]
                                                                                                                               seq_csr_priv_step_exec));
                                                 
                                                 
  // if step mode is enabled, cannot have 2 instructions executed consequitively without entering debug mode in between
  logic [1:0]   prop_next_step_instr_count;
  logic [1:0]   prop_step_instr_count;  
  
  assign prop_next_step_instr_count = debug_enter_taken ? 2'd0 : (instr_retired & dcsr_step) ? prop_step_instr_count + 2'd1 : prop_step_instr_count;
    
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_step_instr_count <= 2'd0;
    else
      prop_step_instr_count <= prop_next_step_instr_count;
  end
  
  
  
  
  // debug prioperties
    
    
    
    assert_csr_priv_debug_step_must_debug_after_retire: assert property (@(posedge clk) disable iff (~resetn)
                                                                         prop_step_instr_count < 2'd2);
    
  
    // trigger   
    cover_csr_priv_debug_enter_trigger: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] trigger_debug_enter_taken);

    // enter debug after trigger, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_trigger: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired[->2:$] ##[1:$]
                                                                                    trigger_debug_enter_taken ##[1:$] 
                                                                                    debug_exit_taken ##[1:$] 
                                                                                    instr_retired));
  
    // halt request
    cover_csr_priv_debug_enter_haltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] haltreq_debug_enter_taken);

    // enter debug after haltreq, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_haltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr | debug_halt_req) throughout(instr_retired[->2:$] ##[1:$]
                                                                                                                  haltreq_debug_enter_taken ##[1:$] 
                                                                                                                  debug_exit_taken ##[1:$] 
                                                                                                                  instr_retired));
                                                                                                                  
    assert_csr_priv_debug_haltreq_must_debug: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_halt_req |-> ##[1:$]  debug_mode);
                                                               
                                                               
     assert_csr_priv_debug_haltreq_must_ack: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_halt_req |-> ##[0:$]  debug_halt_ack);                                                                                                                                                                         

    
     cover_csr_priv_debug_enter_haltreq_in_reset: cover property (@(posedge clk) disable iff (~resetn)
                                                                 (soft_reset & ~ debug_reset_taken_retr) throughout(soft_reset_taken_retr ##[1:$]
                                                                                                                    debug_halt_req ##[1:$]
                                                                                                                    haltreq_debug_enter_taken));
                                                                                                                    

    // reset halt request
    cover_csr_priv_debug_enter_resethaltreq: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] resethaltreq_debug_enter_taken);

    // enter debug after resethaltreq, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_resethaltreq: cover property (@(posedge clk) disable iff (~resetn)
        debug_resethalt_req ##[1:$] ~(debug_reset_taken_retr | soft_reset_taken_retr) throughout(instr_retired[->2:$] ##[1:$]
                                                                                                      haltreq_debug_enter_taken ##[1:$] 
                                                                                                      debug_exit_taken ##[1:$] 
                                                                                                      instr_retired));
                                                                                                                  
    assert_csr_priv_debug_resethaltreq_must_debug: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_resethalt_req |-> ##[1:$]  (~debug_resethalt_req | debug_mode));
                                                               
                                                               
     assert_csr_priv_debug_resethaltreq_must_ack: assert property (@(posedge clk) disable iff (~resetn) 
                                                               debug_resethalt_req |-> ##[0:$]  (~debug_resethalt_req |debug_resethalt_ack));                                                                                                                                                                         

    
                                                                                                                                                                                                                                        

    // ebreak
    cover_csr_priv_debug_enter_ebreak: cover property (@(posedge clk) disable iff (~resetn)
                                                      instr_retired[->2:$] ##[1:$] ebreak_debug_enter_taken);

    // enter debug after ebreak, exit debug mode                                                    
    cover_csr_priv_debug_enter_exit_ebreak: cover property (@(posedge clk) disable iff (~resetn)
                                                     ~(debug_reset_taken_retr | soft_reset_taken_retr) throughout(instr_retired[->2:$] ##[1:$] 
                                                                                                                 ebreak_debug_enter_taken ##[1:$] 
                                                                                                                 debug_exit_taken ##[1:$] 
                                                                                                                 instr_retired));
                                         
  end
  endgenerate  
  
  cover_csr_priv_simultaneous_irq_sw_ext_both_handled: cover property (@(posedge clk) disable iff (~resetn)  
          ext_meip throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]
          (~ext_msip throughout((trap_return & instr_completing_retr) ##[1:$] interrupt_taken ##[1:$] (trap_return & instr_completing_retr)))));

  cover_csr_priv_simultaneous_irq_sw_ext_nested_sub01: cover property (@(posedge clk) disable iff (~resetn) 
          (ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip))); 

  cover_csr_priv_simultaneous_irq_sw_ext_nested_sub1: cover property (@(posedge clk) disable iff (~resetn) 
          (ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr) ##[0:$] interrupt_taken))) );             
            
  cover_csr_priv_simultaneous_irq_sw_ext_nested: cover property (@(posedge clk) disable iff (~resetn) 
          ((ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr) ##[0:$] interrupt_taken)))) ##[1:$] (trap_return & instr_completing_retr));    
          
  cover_csr_priv_simultaneous_irq_sw_ext_nested_stall: cover property (@(posedge clk) disable iff (~resetn) 
          ((ext_meip & ie_msie & ie_meie & ~trap_return) throughout((interrupt_taken & ext_msip & ext_meip) ##[1:$]         
          (~ext_msip throughout((status_mie & instr_completing_retr & irq_stall_lsu_req) ##[1:$] interrupt_taken)))) ##[1:$] (trap_return & instr_completing_retr));  
          
  // cover back to back CSR write then read to same location
  
  sequence seq_csr_write(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_csr_read(prop_addr);       
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_back_to_back_write_then_read_same(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid) ##1 
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  sequence seq_csr_write_then_read_same(prop_addr);
       ((csr_alu_wr_op_sel == csr_alu_wr_op_swap) & (csr_op_addr == prop_addr) & csr_op_addr_valid) ##[1:3] 
       ((csr_alu_rd_op_sel != csr_alu_rd_op_none) & (csr_op_addr == prop_addr) & csr_op_addr_valid);
  endsequence
  
  logic [11:0] nd_prop_addr;
  assume_prop_csr_addr_stable: assume property (@(posedge clk) disable iff (~resetn) 
                                                ##1 $stable(nd_prop_addr));
                                                
  cover_csr_trace_back_to_back_write_then_read_same_any: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(nd_prop_addr));
                                                                                                                        
  cover_csr_trace_write_then_read_same_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write_then_read_same(l_core_csr_addr_tdata1));                                                              
                                                                                                                            
  cover_csr_trace_back_to_back_write_then_read_same_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(l_core_csr_addr_tdata1)); 
                                                               
  cover_csr_trace_read_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_read(l_core_csr_addr_tdata1));
 
  cover_csr_trace_write_tdata1: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write(l_core_csr_addr_tdata1));    
                                                               
  cover_csr_trace_write_then_read_same_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write_then_read_same(l_core_csr_addr_tselect));                                                              
                                                                                                                            
  cover_csr_trace_back_to_back_write_then_read_same_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_back_to_back_write_then_read_same(l_core_csr_addr_tselect)); 
                                                               
  cover_csr_trace_read_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_read(l_core_csr_addr_tselect));
 
  cover_csr_trace_write_tselect: cover property (@(posedge clk) disable iff (~resetn) 
                                                               seq_csr_write(l_core_csr_addr_tselect));                                                                                                                          
                                                               
`endif 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:      miv_rv32_csr_state_reg.sv
//
//   Purpose:   standard CSR register state bit, machine mode access only
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module  miv_rv32_csr_gpr_state_reg
//********************************************************************************
// Parameter description

  #(
    parameter WIDTH = 1,
    parameter FIELD_RESET_EN = 0,
    parameter FIELD_RESET_VAL = 0
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    input wire logic                clk,
    input wire logic                resetn,
    
    input wire logic                init_wr_en,               
    input wire logic [WIDTH-1:0]    init_wr_data,             
    input wire logic                machine_implicit_wr_en,   
    input wire logic [WIDTH-1:0]    machine_implicit_wr_data, 
    input wire logic                machine_sw_wr_en,         
    input wire logic [WIDTH-1:0]    machine_sw_wr_data,         
    
    output logic [WIDTH-1:0]        state_val                 
  ); 
    


//********************************************************************************
// localparams
  

// Declarations



  
// Internal nets

//********************************************************************************
// Main code
//********************************************************************************

  // select data to write
  // priority based (decreasing) : 
  //  - invalidate
  //  - init
  //  - implicit
  //  - software
  
  logic [WIDTH-1:0] wr_data;
  logic wr_en_data;
  logic wr_en_valid;
  
  logic               implicit_wr_en;   
  logic [WIDTH-1:0]   implicit_wr_data; 
  logic               sw_wr_en;         
  logic [WIDTH-1:0]   sw_wr_data;       

// implicit wr mux  
  assign implicit_wr_en = machine_implicit_wr_en;                                 
  assign implicit_wr_data = machine_implicit_wr_data;                           
    
// sw wr mux (for when other modes supported) 
  assign sw_wr_en = machine_sw_wr_en;
  assign sw_wr_data = machine_sw_wr_data;                             
                                                                      
  generate if(FIELD_RESET_EN) begin : gen_init_term                                                                      
    assign wr_data =  init_wr_en ? init_wr_data :
                                   implicit_wr_en ? implicit_wr_data :
                                                    sw_wr_en ? sw_wr_data : {WIDTH{1'b0}};

    assign wr_en_data = init_wr_en | implicit_wr_en | sw_wr_en;
  end
  else
  begin : gen_no_init_term
    assign wr_data =  implicit_wr_en ? implicit_wr_data :
                                   sw_wr_en ? sw_wr_data : {WIDTH{1'b0}};

    assign wr_en_data = implicit_wr_en | sw_wr_en; 
  end
  endgenerate     


// state                

    
  generate if(FIELD_RESET_EN) begin : gen_bit_reset // async reset
  
    always @(posedge clk)
    begin
      if(~resetn)
      begin
        state_val      <= FIELD_RESET_VAL[WIDTH-1:0];     
      end
      else begin
        if(wr_en_data)
            state_val  <= wr_data;  
      end
    end   
    
  end // end generate gen_bit_reset
  else
  begin :gen_bit_no_reset
  
    always @(posedge clk)
    begin
      if(wr_en_data)
            state_val  <= wr_data;  
    end   
  
  
  end // end generate gen_bit_no_reset
  endgenerate

  
                                                                 

 

endmodule


`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_csr_privarch.sv
//
//   Purpose: Core CSRs and priveleged state
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_gpr
  //****************************************************************************
  // Parameter description
  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                         clk,
  input  wire logic                         resetn,     
  input  wire logic                         gpr_wr_valid,     
  output logic                              gpr_wr_ready,     
  input  wire logic [4:0]                   gpr_wr_sel,       
  input  wire logic [L_XLEN-1:0]            gpr_wr_data,      
  input  wire logic                         gpr_rs1_rd_valid, 
  output logic                              gpr_rs1_rd_ready, 
  input  wire logic [4:0]                   gpr_rs1_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs1_rd_data,
  output logic                              gpr_rs1_rd_data_valid,   
  input  wire logic                         gpr_rs2_rd_valid, 
  output logic                              gpr_rs2_rd_ready, 
  input  wire logic [4:0]                   gpr_rs2_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs2_rd_data,
  output logic                              gpr_rs2_rd_data_valid,
  output logic                              gpr_correctable_ecc_irq_src,     
  output logic                              gpr_uncorrectable_ecc_irq_src            
 
);  

  
//******************************************************************************
// Declarations

  logic  [L_XLEN-1:0]            gp_reg [32];
  logic  [31:0]                  gpr_wr_en;
  logic  [L_XLEN-1:0]            gp_reg_rd_data_rs1;
  logic  [L_XLEN-1:0]            gp_reg_rd_data_rs2;


//******************************************************************************
// Main code

  //x0 is always 0.
  assign gp_reg[0] = {L_XLEN{1'b0}};

  genvar i_gp_reg;
  generate  
  for (i_gp_reg = 1; i_gp_reg <= 31; i_gp_reg++) begin : gen_gp_regs
  
    assign gpr_wr_en[i_gp_reg] = gpr_wr_valid & (gpr_wr_sel == i_gp_reg[4:0]);
    
    always @(posedge clk)
    begin
      if(gpr_wr_en[i_gp_reg])
        gp_reg[i_gp_reg] <= gpr_wr_data;
    end
    
  end
  endgenerate
  
  assign gpr_wr_ready = 1'b1; // can always accept writes in this implemnetation when operand (wr data) is valid
  
  //read mux
  always @*
  begin
    gp_reg_rd_data_rs1 = {L_XLEN{1'b0}};
    gp_reg_rd_data_rs2 = {L_XLEN{1'b0}};
    for(int i = 0; i <= 31; i++) 
    begin
      if(gpr_rs1_rd_valid & (gpr_rs1_rd_sel == i[4:0]))
        gp_reg_rd_data_rs1 = gp_reg[i];
      if(gpr_rs2_rd_valid & (gpr_rs2_rd_sel == i[4:0]))
        gp_reg_rd_data_rs2 = gp_reg[i];
    end
  end
  
  assign gpr_rs1_rd_data        = gp_reg_rd_data_rs1;
  assign gpr_rs1_rd_data_valid  = gpr_rs1_rd_valid;     // Pass-through in reg based version, but may not be in ram based version
  assign gpr_rs2_rd_data        = gp_reg_rd_data_rs2;
  assign gpr_rs2_rd_data_valid  = gpr_rs2_rd_valid;     // Pass-through in reg based version, but may not be in ram based version
  assign gpr_rs1_rd_ready       = 1'b1; // can always return reads immediately in this implmemtation for both ports
  assign gpr_rs2_rd_ready        = 1'b1; 
  
  // Curerntly no ecc on register based version of GPR
  // If implemented, exception bit asserted when GPR read and ECC error - if ECC schem does not support correction,
  // or correctable ECC error notification is required, the corerctable exception bit should be tied to 0
  // and only uncorrectbale bit used.
  assign gpr_correctable_ecc_irq_src = 1'b0;  
  assign gpr_uncorrectable_ecc_irq_src = 1'b0;  

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS



`endif 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_gpr_ram.sv
//
//   Purpose: Core CSRs and priveleged state
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype wire

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_gpr_ram
  //****************************************************************************
  // Parameter description
  #(
    parameter ECC_ENABLE = 0,
	parameter l_core_cfg_gpr_fwd_hzd = 0
  )
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                         clk,
  input  wire logic                         resetn,     
  input  wire logic                         gpr_wr_valid,     
  output logic                              gpr_wr_ready,     
  input  wire logic [4:0]                   gpr_wr_sel,       
  input  wire logic [L_XLEN-1:0]            gpr_wr_data,      
  input  wire logic                         gpr_rs1_rd_valid, 
  output logic                              gpr_rs1_rd_ready, 
  input  wire logic [4:0]                   gpr_rs1_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs1_rd_data,
  output logic                              gpr_rs1_rd_data_valid,   
  input  wire logic                         gpr_rs2_rd_valid, 
  output logic                              gpr_rs2_rd_ready, 
  input  wire logic [4:0]                   gpr_rs2_rd_sel,   
  output logic[L_XLEN-1:0]                  gpr_rs2_rd_data,
  output logic                              gpr_rs2_rd_data_valid,
  output logic                              gpr_correctable_ecc_irq_src,     
  output logic                              gpr_uncorrectable_ecc_irq_src,

  input  wire logic                         gpr_ram_init_soft_debug_reset, //signal to re-init gpr ram on a soft or debug reset
  output logic                              gpr_ram_init_done //gpr ram init done output signal
);

//******************************************************************************
// Declarations
   logic        rs1_rd_hzd;
   logic        rs2_rd_hzd;
   logic [4:0]  gpr_wr_sel_reg;
   logic [4:0]  gpr_rs1_rd_sel_reg;
   logic [4:0]  gpr_rs2_rd_sel_reg;
   logic        gpr_rs1_rd_valid_reg;
   logic        gpr_rs2_rd_valid_reg;
   logic        gpr_wr_valid_reg;
   logic        gpr_wr_valid_int;
   logic [31:0] rs1_data_o;
   logic [31:0] rs2_data_o;

   logic [1:0] ecc_aerr_int;
   logic [1:0] ecc_berr_int;
   logic [1:0] ecc_err;
   
   //gpr ram init nets
   logic [31:0] gpr_ram_init_data;
   logic [4:0]  gpr_ram_init_addr;
   logic        gpr_ram_init_write_en;
   
   //gpr ram mux nets
   logic [31:0] gpr_mux_data;
   logic [4:0]  gpr_mux_addr;
   logic        gpr_mux_write_en;

//******************************************************************************
// Main code
  assign gpr_rs1_rd_data_valid = gpr_rs1_rd_valid_reg  & !rs1_rd_hzd & (gpr_rs1_rd_sel_reg == gpr_rs1_rd_sel);
  assign gpr_rs2_rd_data_valid = gpr_rs2_rd_valid_reg  & !rs2_rd_hzd & (gpr_rs2_rd_sel_reg == gpr_rs2_rd_sel);
  assign rs1_rd_hzd            = (gpr_wr_valid & (gpr_rs1_rd_sel == gpr_wr_sel)) | (gpr_wr_valid_reg & (gpr_rs1_rd_sel == gpr_wr_sel_reg) & l_core_cfg_gpr_fwd_hzd);
  assign rs2_rd_hzd            = (gpr_wr_valid & (gpr_rs2_rd_sel == gpr_wr_sel)) | (gpr_wr_valid_reg & (gpr_rs2_rd_sel == gpr_wr_sel_reg) & l_core_cfg_gpr_fwd_hzd);
  assign gpr_wr_valid_int      = (gpr_wr_sel != 5'b0) & gpr_wr_valid;
  assign gpr_rs1_rd_ready      = gpr_rs1_rd_data_valid;
  assign gpr_rs2_rd_ready      = gpr_rs2_rd_data_valid;
  assign gpr_rs1_rd_data       = rs1_data_o;
  assign gpr_rs2_rd_data       = rs2_data_o;
  assign gpr_wr_ready          = 1'b1;
     
  always @ (posedge clk or negedge resetn)
    begin
      if(!resetn) begin
	      gpr_wr_sel_reg       <= 5'b0;
          gpr_wr_valid_reg     <= 1'b0;
          gpr_rs1_rd_sel_reg   <= 5'b0;
          gpr_rs2_rd_sel_reg   <= 5'b0;
          gpr_rs1_rd_valid_reg <= 1'b0;
          gpr_rs2_rd_valid_reg <= 1'b0;
      end else begin
	      gpr_wr_sel_reg       <= gpr_wr_sel;
          gpr_wr_valid_reg     <= gpr_wr_valid;
          gpr_rs1_rd_sel_reg   <= (gpr_rs1_rd_valid) ? gpr_rs1_rd_sel : gpr_rs1_rd_sel_reg;
          gpr_rs2_rd_sel_reg   <= (gpr_rs2_rd_valid) ? gpr_rs2_rd_sel : gpr_rs2_rd_sel_reg;
          gpr_rs1_rd_valid_reg <= gpr_rs1_rd_valid;
          gpr_rs2_rd_valid_reg <= gpr_rs2_rd_valid;
      end
    end

  generate
  if(ECC_ENABLE)    
    begin : gen_gpr_ecc
    
      //GPR RAM INIT MODULE
      miv_rv32_gpr_ram_init
      //******************************************************************
      // Parameter description
      #(
      .ECC_ENABLE                       (1)
      )
      u_gpr_init_0
      //******************************************************************
      // Signal description
      (
      .clk                              (clk),
      .resetn                           (resetn),
      .debug_soft_reset                 (gpr_ram_init_soft_debug_reset),
      .init_done                        (gpr_ram_init_done),
      .data                             (gpr_ram_init_data),
      .addr                             (gpr_ram_init_addr),
      .write_en                         (gpr_ram_init_write_en)
      );
      
      
      //RAM INPUT MUX
      miv_rv32_gpr_ram_mux
      u_gpr_mux_0
      //******************************************************************
      // Signal description
      (
      .clk(clk),
      .resetn(resetn),
      .mux_sel(gpr_ram_init_done),
      .addr_0(gpr_ram_init_addr),
      .data_0(gpr_ram_init_data),
      .write_en_0(gpr_ram_init_write_en),
      .addr_1(gpr_wr_sel),
      .data_1(gpr_wr_data),
      .write_en_1(gpr_wr_valid),
      .addr_out(gpr_mux_addr),
      .data_out(gpr_mux_data),
      .write_en_out(gpr_mux_write_en)
      );
      
      //GPR ECC RAM
      miv_rv32_gpr_ecc_enc_dec
      //******************************************************************
      // Parameter description
      #(
        .RAM_DEPTH                      (32),
        .ADDR_WIDTH                     (5),
        .DATA_WIDTH                     (32)
       )
      u_gpr_ecc_0
      //******************************************************************
      // Signal description
      (
        .arstb                          (resetn),
        .aclk                           (clk),
        .aaddr                          (gpr_rs1_rd_sel),
        .aceb                           (gpr_rs1_rd_valid),
        .brstb                          (resetn),
        .bclk                           (clk),
        .baddr                          (gpr_rs2_rd_sel),
        .bceb                           (gpr_rs2_rd_valid),
        .ret1n                          (resetn),
        .pg_override                    (1'b0),
        .ecc_bypass                     (1'b0),
        .ram_err_inject                 (2'b00),
        .adout                          (rs1_data_o),
        .bdout                          (rs2_data_o),
        .ecc_aerr                       (), // open
        .ecc_aerr_int                   (ecc_aerr_int),  // open
        .ecc_berr                       (), // open
        .ecc_berr_int                   (ecc_berr_int),  // open
        .waddr                          (gpr_mux_addr),
        .wen                            (gpr_mux_write_en),
        .wdin                           (gpr_mux_data)
      );  
      
      always @ (*)
      begin
          if(~gpr_ram_init_done) //prevent ECC error signals from asserting while GPR RAM is initialising
            begin
                gpr_correctable_ecc_irq_src = 1'b0;  
                gpr_uncorrectable_ecc_irq_src = 1'b0;
            end
          else //allow ECC error signals to assert once GPR RAM is no longer initialising
            begin
                gpr_correctable_ecc_irq_src = (ecc_aerr_int[0] || ecc_berr_int[0]);  
                gpr_uncorrectable_ecc_irq_src = (ecc_aerr_int[1] || ecc_berr_int[1]);
            end
      end
      
    end
  else
    begin : gen_gpr
      miv_rv32_gpr_ram_array
      //******************************************************************
      // Parameter description
      #(
        .mem_depth                     (32),
        .addr_width_gpr                (5),
        .d_width                       (L_XLEN)
       )
      u_gpr_array_0
      //******************************************************************
      // Signal description
      (
            // Inputs
            .clk           ( clk              ),
            .raddr0        ( gpr_rs1_rd_sel   ),
            .raddr1        ( gpr_rs2_rd_sel   ),
            .waddr0        ( gpr_wr_sel       ),
            .waddr1        ( 5'b0             ),
            .we0           ( gpr_wr_valid_int ),
            .we1           ( 1'b0             ),
            .data0         ( gpr_wr_data      ),
            .data1         ( 32'b0            ),
            // Outputs
            .q0          ( rs1_data_o ),
            .q1          ( rs2_data_o )
            );
     
      assign gpr_correctable_ecc_irq_src = 1'b0;  
      assign gpr_uncorrectable_ecc_irq_src = 1'b0;  
	  assign ecc_aerr_int = 2'b0;
      assign ecc_berr_int = 2'b0;
      assign ecc_err = 2'b0;
	  assign gpr_ram_init_done = 1'b1;
	end
  endgenerate


 
//******************************************************************************
// properties
`ifdef core_RTL_PROPS



`endif 
endmodule
module miv_rv32_gpr_ram_array(data0,
                                data1,
                                raddr0,
                                raddr1,
                                waddr0, 
                                waddr1,
                                we0,
                                we1,
                                clk,
                                q0,
                                q1);

    parameter d_width = 8;
    parameter addr_width_gpr = 32;
    parameter mem_depth = 65536;

    input [d_width-1:0] data0, data1;
    input [addr_width_gpr-1:0] waddr0, waddr1, raddr0, raddr1;
    input we0, we1, clk;

    output [d_width-1:0] q0;
    output [d_width-1:0] q1;

    reg [d_width-1:0] mem [mem_depth-1:0];

    reg [d_width-1:0] q0, q1;

    always @(posedge clk) begin 
        if (we0)
            mem[waddr0] <= data0;
        if (we1) 
            mem[waddr1] <= data1;
    end 

    always @(posedge clk) begin 
        q0 <= (raddr0 == 0) ?  0 : mem[raddr0];
        q1 <= (raddr1 == 0) ?  0 : mem[raddr1];
    end 
endmodule
// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_gpr_ram_init
    //****************************************************************************
    // Parameter description
    #(
    parameter ECC_ENABLE = 1 
    )
    //******************************************************************************
    // Port Description
    (
    input clk,
    input resetn,
    input debug_soft_reset,
    output reg init_done,
    output reg [31:0] data,
    output reg [4:0] addr,
    output reg write_en

    );
    //******************************************************************************  
    // Declarations
    reg [1:0] init_state;

    //******************************************************************************
    // Main code
    generate
        if(ECC_ENABLE)
        begin
            always @ (posedge clk)
                begin
                    if(~resetn)
                        begin
                        init_state <= 2'b0;
                        data <= 32'b0;
                        addr <= 5'b0;
                        write_en <= 1'b0;
                        init_done <= 1'b0;
                        end
                    else
                        begin
                            case(init_state)
                                2'd0: begin //STATE 0: INIT START
                                      $display("Initialisation of GPR RAM - Start");
                                      init_state <= 2'd1; //move to state 1: init in progress
                                      data <= 32'b0;
                                      addr <= 5'b0;
                                      write_en <= 1'b1;
                                      init_done <= 1'b0;
                                      end
                                      
                                2'd1: begin //STATE 1: INIT IN PROGRESS
                                      if(addr == 5'b11111) //end of gprs reached, init done 
                                        begin
                                            init_state <= 2'd2; //move to init 2: init done
                                            data <= 32'b0;
                                            addr <= 5'b0;
                                            init_done <= 1'b1; //gpr ram init done
                                            $display("Initialisation of GPR RAM - Complete");
                                        end
                                      else 
                                        begin
                                            addr <= addr + 1'b1; //increment to next address
                                            init_state <= 2'b1; //init still in progress
                                        end
                                      end
                                      
                                2'd2: begin //STATE 2: INIT DONE
                                        init_state <= 2'd2;
                                        
                                        if (debug_soft_reset) //if init is complete and a soft reset or debug reset is triggered, go to init start
                                            begin
                                                init_state <= 2'd0;
                                            end
                                      end
                            default: begin  //DEFAULT STATE
                                        init_state <= 2'd0;
                                        data <= 32'b0;
                                        addr <= 5'b1;
                                        init_done <= 1'b0;
                                     end
                            endcase
                        end
                end
        end
        else
        begin
            always @ (*)
                begin
                    init_state <= 2'b0;
                    data <= 32'b0;
                    addr <= 5'b0;
                    write_en <= 1'b0;
                    init_done <= 1'b1;
                end
        end
    endgenerate
endmodule


// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_gpr_ram_mux
    //******************************************************************************
    // Parameter description
    #(
    parameter ECC_ENABLE = 1 
    )
    //******************************************************************************
    // Port Description
    (
    input clk,
    input resetn,
    input mux_sel,
    
    input [4:0]  addr_0,
    input [31:0] data_0,
    input write_en_0,
    
    input [4:0]  addr_1,
    input [31:0] data_1,
    input write_en_1, 
   
    output reg [4:0] addr_out,
    output reg [31:0] data_out,
    output reg write_en_out
    );
    //******************************************************************************
    // Main code
    
    always @ (*)
        begin
            case(mux_sel)
            1'b0: begin
                  addr_out <= addr_0;
                  data_out <= data_0;
                  write_en_out <= write_en_0;
                  end
            1'b1: begin
                  addr_out <= addr_1;
                  data_out <= data_1;
                  write_en_out <= write_en_1;
                  end
            
         default: begin
                  addr_out <= 5'b0;
                  data_out <= 32'b0;
                  write_en_out <= 1'b0;
                  end
            endcase
        end
endmodule
// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: core_1rq_reg.sv
//
//   Purpose: Core IRQ capture and pending hold register bit
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_irq_reg
  //****************************************************************************
  // Parameter description
  #(parameter IRQ_STICKY_CAPTURE                  = 0
   )
  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic           clk,
  input  wire logic           resetn,     
  input  wire logic           interrupt_commit,
  input  wire logic           interrupt_src,  
  input  wire logic           interrupt_enable, 
  input  wire logic           interrupt_clr,
  output logic                interrupt_captured,
  output logic                interrupt_pending,  
  output logic                interrupt_taken          
 
);  

  
//******************************************************************************
// Declarations

  logic set_interrupt_capture;
  logic clr_interrupt_capture;
  logic interrupt_capture_reg;



//******************************************************************************
// Main code

  // capture interrupt request
  // optionally can be sticky
  // need to use registered version in any case as generates stall to the ex phase so timing critical.
  // If the capture is required to be sticky, then interrupt_capture_clr_en can be used. Where it is not required it 
  // should be tied high
    
  assign set_interrupt_capture  = interrupt_src;
  
  generate if(IRQ_STICKY_CAPTURE) 
  begin: gen_sticky_irq
    assign clr_interrupt_capture  = interrupt_clr;
  end
  else begin: gen_non_sticky_irq
    assign clr_interrupt_capture  = interrupt_commit;
  end
  endgenerate
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      interrupt_capture_reg <= 1'b0;
    else
      if(set_interrupt_capture | clr_interrupt_capture)
        interrupt_capture_reg <= set_interrupt_capture;
  end    
    
  assign interrupt_captured = interrupt_capture_reg;
  
  // When no outstanding LSU requests, and request completing, or no requests in retire stage, interrupt can be taken if still pending and enabled
  

    
  assign interrupt_pending = interrupt_commit & interrupt_capture_reg;
  
  assign interrupt_taken   =  interrupt_pending & interrupt_enable;
  
 

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS



`endif 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_priv_irq.sv
//
//   Purpose: Core interrupt handling logic
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_priv_irq
  //****************************************************************************
  // Parameter description
  #(parameter l_core_num_sys_ext_irqs = 7,
    parameter l_core_cfg_gpr_ecc_uncorrectable_irq = 0,
    parameter l_core_cfg_gpr_ecc_correctable_irq   = 0
    )
  
//******************************************************************************
// Port Description
   (
   
   // clk/reset
  input  wire logic                        clk,
  input  wire logic                        resetn,        
  input  wire logic                        debug_mode,                    
  input  wire logic                        lsu_op_os,                      
  input  wire logic                        instr_completing_retr,         
  input  wire logic                        instr_valid_retr,              
  input  wire logic                        instr_lsu_op_retr,           
  input  wire logic [L_XLEN-1:0]           ie,                            
  input  wire logic                        global_enable,                 
  input  wire logic                        dcsr_stepie,                   
  input  wire logic                        dcsr_step,
  input  wire logic                        ip_read,                     
                              
  input  wire logic                        base_irq_src_ext,  
  input  wire logic                        base_irq_src_timer,     
  input  wire logic                        base_irq_src_sw,              
  input  wire logic [7:0]                  sys_ext_irq_src,               
  input  wire logic                        gpr_uncorrectable_ecc_irq_src, 
  input  wire logic                        gpr_uncorrectable_ecc_irq_clr,
  input  wire logic                        gpr_correctable_ecc_irq_src,  
  input  wire logic                        gpr_correctable_ecc_irq_clr,
  input  wire logic                        instret_count_irq_src, 
  input  wire logic                        instret_count_irq_clr, 
  input  wire logic                        cycle_count_irq_src, 
  input  wire logic                        cycle_count_irq_clr,
  input  wire logic                        hpm_count_irq_src, 
  input  wire logic                        hpm_count_irq_clr,
                              
  output logic                             irq_stall_lsu_req,
  output logic                             irq_abort_lsu_req,
  output logic                             locally_enabled_irq_captured,             
  output logic                             irq_taken,                   
  output logic                             base_ip_ext,    
  output logic                             base_ip_timer,
  output logic                             base_ip_sw,   
  output logic [7:0]                       sys_ext_ip,  
  output logic                             gpr_correctable_ecc_ip,   
  output logic                             gpr_uncorrectable_ecc_ip,      
  output logic                             instret_count_ip,
  output logic                             cycle_count_ip,
  output logic                             hpm_count_ip,           
  output logic [4:0]                       cause_excpt_code_irq          

                               
);  

  
//******************************************************************************
// Declarations

  logic                         irq_ext_enable;  
  logic                         irq_timer_enable;  
  logic                         irq_sw_enable; 
  logic                         interrupt_lsu_stall_ext;
  logic                         interrupt_lsu_stall_timer;
  logic                         interrupt_lsu_stall_sw;
  logic                         interrupt_captured_ext;
  logic                         interrupt_captured_timer;
  logic                         interrupt_captured_sw;
  logic                         interrupt_captured_local_en_ext;
  logic                         interrupt_captured_local_en_timer;
  logic                         interrupt_captured_local_en_sw;
  logic                         interrupt_taken_ext;
  logic                         interrupt_taken_timer;
  logic                         interrupt_taken_sw;
  logic                         interrupt_could_commit;
  
  logic [7:0]                   interrupt_lsu_stall_ext_sys;
  logic [7:0]                   interrupt_captured_local_en_ext_sys;
  logic [7:0]                   interrupt_pending_ext_sys;
  logic [7:0]                   interrupt_taken_ext_sys;  
        
  logic                         interrupt_lsu_stall_ecc_uncorrectable;
  logic                         interrupt_captured_local_en_ecc_uncorrectable;
  logic                         interrupt_pending_ecc_uncorrectable;  
  logic                         interrupt_taken_ecc_uncorrectable;        
  logic                         interrupt_lsu_stall_ecc_correctable;
  logic                         interrupt_captured_local_en_ecc_correctable;
  logic                         interrupt_pending_ecc_correctable;  
  logic                         interrupt_taken_ecc_correctable;  
         
  logic                         interrupt_lsu_stall_instret_count;
  logic                         interrupt_captured_local_en_instret_count;
  logic                         interrupt_pending_instret_count;  
  logic                         interrupt_taken_instret_count;        
  logic                         interrupt_lsu_stall_cycle_count;
  logic                         interrupt_captured_local_en_cycle_count;
  logic                         interrupt_pending_cycle_count;  
  logic                         interrupt_taken_cycle_count;         
  logic                         interrupt_lsu_stall_hpm_count;
  logic                         interrupt_captured_local_en_hpm_count;
  logic                         interrupt_pending_hpm_count;  
  logic                         interrupt_taken_hpm_count; 


  
//******************************************************************************
// Main code  

  // Interrupt taken when:
  // - asserted
  // - not masked globally (status.mie), 
  // - not masked by the correspondingie register bit,
  // - if debug step enabled then only if dcsr_stepie is asserted
  // note interrupts are not captured/latched so source must hold asserted.
  
  
  // Need to ensure interupt occurs (interrupt_taken asserted) only when an instruction is completing
  // to ensure handling trap instruction is inserted without anything outstanding in the retr stage.
  // However interrupt must take priority over new instructions and must happen if no instructions in flight
  
  // interrupt_pending is used to block LSU requests in the EX stage (to prevent stores being issued for an instruction that is subsequently dropped 
  // due to the interrupt being taken in the retr stage). 
  // This means it must only be asserted when:
  //  - there is no valid instruction in EX stage
  //  - there is a valid instruction in EX stage that is not a store (simplified to any LSU op, also loads may have side effects so also must complete)
  //  - there is a valid store instruction but the LSU has not yet accepted the request
  // The cleanest/simplest way to ensure this, is as with the retr stage, to only update when the ex stage has no valid instruction, or an instruction 
  // is completing (which means any store is already accepted by retr, and therefore will prevent the interrupt being taken until it is complete)
  // Deassertion is simpler since when an interrupt is taken, the retr stage will flush all pipeline stages, so there can be no requests to the LSU in progress
  // in the EX stage
  

  
  assign irq_ext_enable   = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[11];
  assign irq_timer_enable = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[7];
  assign irq_sw_enable    = global_enable & (dcsr_stepie | ~dcsr_step) & (~debug_mode) & ie[3];  
  
  assign interrupt_could_commit = (~lsu_op_os) &
                                  (instr_completing_retr & instr_valid_retr);
                                  
// Base External interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )  
  u_miv_rv32_irq_reg_ext
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_ext           ),
    .interrupt_enable            (irq_ext_enable             ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_ext     ),
    .interrupt_pending           (base_ip_ext                ),
    .interrupt_taken             (interrupt_taken_ext        )
  );
  
  assign interrupt_lsu_stall_ext          = interrupt_captured_ext & irq_ext_enable;
  assign interrupt_captured_local_en_ext  = interrupt_captured_ext & ie[11];

// Base timer interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )  
  u_miv_rv32_irq_reg_timer
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_timer         ),
    .interrupt_enable            (irq_timer_enable           ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_timer   ),
    .interrupt_pending           (base_ip_timer              ),
    .interrupt_taken             (interrupt_taken_timer      )
  );
  
  assign interrupt_lsu_stall_timer          = interrupt_captured_timer & irq_timer_enable;
  assign interrupt_captured_local_en_timer  = interrupt_captured_timer & ie[7];

// Base software interrupt  
  miv_rv32_irq_reg
  #(
    .IRQ_STICKY_CAPTURE     (0)  // 
  )
  u_miv_rv32_irq_reg_sw
  (
    .clk                         (clk                        ),
    .resetn                      (resetn                     ),
    .interrupt_commit            (interrupt_could_commit     ),
    .interrupt_src               (base_irq_src_sw            ),
    .interrupt_enable            (irq_sw_enable              ),
    .interrupt_clr               (1'b0                       ),
    .interrupt_captured          (interrupt_captured_sw      ),
    .interrupt_pending           (base_ip_sw                 ),
    .interrupt_taken             (interrupt_taken_sw         )
  );    
  
  assign interrupt_lsu_stall_sw           = interrupt_captured_sw & irq_sw_enable;
  assign interrupt_captured_local_en_sw   = interrupt_captured_sw & ie[3];
                                  
// External system interrupt(s)                                  
  genvar i_ext_sys_irq;
  generate  
  for (i_ext_sys_irq = 0; i_ext_sys_irq < 8; i_ext_sys_irq++) begin : gen_ext_sys_irq
  
    if(i_ext_sys_irq < l_core_num_sys_ext_irqs) begin : gen_ext_sys_irq_bit
      
      logic interrupt_captured_ext_sys;
      logic irq_ext_sys_enable;
    
      assign irq_ext_sys_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[24+i_ext_sys_irq];
    
      miv_rv32_irq_reg
      #(
        .IRQ_STICKY_CAPTURE     (0)  
      )
      u_miv_rv32_irq_reg_ext_sys
      (
        .clk                         (clk                                       ),
        .resetn                      (resetn                                    ),
        .interrupt_commit            (interrupt_could_commit                    ),
        .interrupt_src               (sys_ext_irq_src[i_ext_sys_irq]            ),
        .interrupt_enable            (irq_ext_sys_enable                        ),
        .interrupt_clr               (1'b0                                      ),
        .interrupt_captured          (interrupt_captured_ext_sys                ),
        .interrupt_pending           (interrupt_pending_ext_sys[i_ext_sys_irq]  ),
        .interrupt_taken             (interrupt_taken_ext_sys[i_ext_sys_irq]    )
      );    
      
      assign interrupt_lsu_stall_ext_sys[i_ext_sys_irq]         = interrupt_captured_ext_sys & irq_ext_sys_enable;
      assign interrupt_captured_local_en_ext_sys[i_ext_sys_irq] = interrupt_captured_ext_sys & ie[24+i_ext_sys_irq];
     
    end
    else begin : ngen_ext_sys_irq_bit

      assign interrupt_lsu_stall_ext_sys[i_ext_sys_irq]          = 1'b0; 
      assign interrupt_captured_local_en_ext_sys[i_ext_sys_irq]  = 1'b0; 
      assign interrupt_pending_ext_sys[i_ext_sys_irq]            = 1'b0;  
      assign interrupt_taken_ext_sys[i_ext_sys_irq]              = 1'b0;  
  
    end
  end
  endgenerate

// GPR ECC uncorrectable   
  generate if(l_core_cfg_gpr_ecc_uncorrectable_irq) begin : gen_ecc_uncorrectable_irq

    logic                         irq_ecc_uncorrectable_enable;  
    logic                         interrupt_captured_ecc_uncorrectable; 
  
    assign irq_ecc_uncorrectable_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[16];
  
    miv_rv32_irq_reg
    #(
    .IRQ_STICKY_CAPTURE     (1)  // 
    )  
    u_miv_rv32_irq_reg_ecc_uncorrectable_irq
    (
      .clk                         (clk                                  ),
      .resetn                      (resetn                               ),
      .interrupt_commit            (interrupt_could_commit               ),
      .interrupt_src               (gpr_uncorrectable_ecc_irq_src        ),
      .interrupt_enable            (irq_ecc_uncorrectable_enable         ),
      .interrupt_clr               (gpr_uncorrectable_ecc_irq_clr        ),
      .interrupt_captured          (interrupt_captured_ecc_uncorrectable ),
      .interrupt_pending           (interrupt_pending_ecc_uncorrectable  ),
      .interrupt_taken             (interrupt_taken_ecc_uncorrectable    )
    );    
    
    assign interrupt_lsu_stall_ecc_uncorrectable          = interrupt_captured_ecc_uncorrectable & irq_ecc_uncorrectable_enable;
    assign interrupt_captured_local_en_ecc_uncorrectable  = interrupt_captured_ecc_uncorrectable & ie[16];
   
  end
  else begin : ngen_ecc_uncorrectable_irq
      
    assign interrupt_lsu_stall_ecc_uncorrectable          = 1'b0;  
    assign interrupt_captured_local_en_ecc_uncorrectable  = 1'b0;
    assign interrupt_pending_ecc_uncorrectable            = 1'b0; 
    assign interrupt_taken_ecc_uncorrectable              = 1'b0; 
  
  end
  endgenerate

// GPR ECC correctable  
  generate if(l_core_cfg_gpr_ecc_correctable_irq) begin : gen_ecc_correctable_irq
            
    logic irq_ecc_correctable_enable; 
    logic interrupt_captured_ecc_correctable;
    
    assign irq_ecc_correctable_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[17];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)   
    ) 
    u_miv_rv32_irq_reg_ecc_correctable_irq
    (
      .clk                         (clk                                ),
      .resetn                      (resetn                             ),
      .interrupt_commit            (interrupt_could_commit             ),
      .interrupt_src               (gpr_correctable_ecc_irq_src        ),
      .interrupt_enable            (irq_ecc_correctable_enable         ),
      .interrupt_clr               (gpr_correctable_ecc_irq_clr        ),
      .interrupt_captured          (interrupt_captured_ecc_correctable ),
      .interrupt_pending           (interrupt_pending_ecc_correctable  ),
      .interrupt_taken             (interrupt_taken_ecc_correctable    )
    );    
    
    assign interrupt_lsu_stall_ecc_correctable          = interrupt_captured_ecc_correctable & irq_ecc_correctable_enable;
    assign interrupt_captured_local_en_ecc_correctable  = interrupt_captured_ecc_correctable & irq_ecc_correctable_enable;
   
  end
  else begin : ngen_ecc_correctable_irq
      
    assign interrupt_lsu_stall_ecc_correctable          = 1'b0;  
    assign interrupt_captured_local_en_ecc_correctable  = 1'b0;
    assign interrupt_pending_ecc_correctable            = 1'b0;    
    assign interrupt_taken_ecc_correctable              = 1'b0;      
  
  end
  endgenerate
  
  // Instruction retired count LSB set  
  generate if(l_core_cfg_instret_count_irq) begin : gen_instret_count_irq
  
    logic irq_instret_count_enable;
    logic interrupt_captured_instret_count;
  
    assign irq_instret_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[19];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    ) 
    u_miv_rv32_irq_reg_instret_count_irq
    (
      .clk                         (clk                              ),
      .resetn                      (resetn                           ),
      .interrupt_commit            (interrupt_could_commit           ),
      .interrupt_src               (instret_count_irq_src            ),
      .interrupt_enable            (irq_instret_count_enable         ),
      .interrupt_clr               (instret_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_instret_count ),
      .interrupt_pending           (interrupt_pending_instret_count  ),
      .interrupt_taken             (interrupt_taken_instret_count    )
    );    
    
    assign interrupt_lsu_stall_instret_count          = interrupt_captured_instret_count & irq_instret_count_enable;
    assign interrupt_captured_local_en_instret_count  = interrupt_captured_instret_count & ie[19];
   
  end
  else begin : ngen_instret_count_irq
     
    assign interrupt_lsu_stall_instret_count          = 1'b0;  
    assign interrupt_captured_local_en_instret_count  = 1'b0;
    assign interrupt_pending_instret_count            = 1'b0;    
    assign interrupt_taken_instret_count              = 1'b0;      
  
  end
  endgenerate
  
  // Cycle count LSB set  
  generate if(l_core_cfg_cycle_count_irq) begin : gen_cycle_count_irq
      
    logic irq_cycle_count_enable; 
    logic interrupt_captured_cycle_count;
  
    assign irq_cycle_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[20];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    )
    u_miv_rv32_irq_reg_cycle_count_irq
    (
      .clk                         (clk                            ),
      .resetn                      (resetn                         ),
      .interrupt_commit            (interrupt_could_commit         ),
      .interrupt_src               (cycle_count_irq_src            ),
      .interrupt_enable            (irq_cycle_count_enable         ),
      .interrupt_clr               (cycle_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_cycle_count ),
      .interrupt_pending           (interrupt_pending_cycle_count  ),
      .interrupt_taken             (interrupt_taken_cycle_count    )
    );    
    
    assign interrupt_lsu_stall_cycle_count          = interrupt_captured_cycle_count & irq_cycle_count_enable;
    assign interrupt_captured_local_en_cycle_count  = interrupt_captured_cycle_count & ie[20];
   
  end
  else begin : ngen_cycle_count_irq
       
    assign interrupt_lsu_stall_cycle_count          = 1'b0;  
    assign interrupt_captured_local_en_cycle_count  = 1'b0;
    assign interrupt_pending_cycle_count            = 1'b0;    
    assign interrupt_taken_cycle_count              = 1'b0;      
  
  end
  endgenerate
  
  // any hpm count LSB set  
  generate if(l_core_cfg_hpm_count_irq) begin : gen_hpm_count_irq
      
    logic irq_hpm_count_enable;
    logic interrupt_captured_hpm_count;
  
    assign irq_hpm_count_enable          = global_enable & (dcsr_stepie | ~dcsr_step) &(~debug_mode) & ie[21];
  
    miv_rv32_irq_reg
    #(
      .IRQ_STICKY_CAPTURE     (1)  // 
    )  
    u_miv_rv32_irq_reg_hpm_count_irq
    (
      .clk                         (clk                          ),
      .resetn                      (resetn                       ),
      .interrupt_commit            (interrupt_could_commit       ),
      .interrupt_src               (hpm_count_irq_src            ),
      .interrupt_enable            (irq_hpm_count_enable         ),
      .interrupt_clr               (hpm_count_irq_clr            ),
      .interrupt_captured          (interrupt_captured_hpm_count ),
      .interrupt_pending           (interrupt_pending_hpm_count  ),
      .interrupt_taken             (interrupt_taken_hpm_count    )
    );    
    
    assign interrupt_lsu_stall_hpm_count          = interrupt_captured_hpm_count & irq_hpm_count_enable;
    assign interrupt_captured_local_en_hpm_count  = interrupt_captured_hpm_count & ie[21];
   
  end
  else begin : ngen_hpm_count_irq
      
    assign interrupt_lsu_stall_hpm_count          = 1'b0;  
    assign interrupt_captured_local_en_hpm_count  = 1'b0;
    assign interrupt_pending_hpm_count            = 1'b0;    
    assign interrupt_taken_hpm_count              = 1'b0;      
  
  end
  endgenerate
  
  // stall the LSU request in EX stage if there is a captured interrupt that may cause an interrupt when it commits
  // Cannot allow the load/store to proceed as it may never happen if an interrupt is taken
  // Cannot abort the load/store because the interrupt may not happen if the instruction in the retr stage disables the interrupt,
  // therefore stall the lsu operation until the operation in the retr stage completes (also have to include the lsu os
  // term because interrupts will not be commited when there are outstanding load/stores/fences), then allow the load/store operation to
  // complete, but suppress load-store request (needs to complete so interrupt can commit and update MEPC)
  
  assign irq_stall_lsu_req        = (interrupt_lsu_stall_ext |
                                    interrupt_lsu_stall_timer | 
                                    interrupt_lsu_stall_sw |
                                    (|interrupt_lsu_stall_ext_sys) |
                                    interrupt_lsu_stall_ecc_uncorrectable |
                                    interrupt_lsu_stall_ecc_correctable |
                                    interrupt_lsu_stall_instret_count |
                                    interrupt_lsu_stall_cycle_count |
                                    interrupt_lsu_stall_hpm_count ) & (instr_valid_retr | lsu_op_os);   
                                    
  assign irq_abort_lsu_req        = (interrupt_lsu_stall_ext |
                                    interrupt_lsu_stall_timer | 
                                    interrupt_lsu_stall_sw |
                                    (|interrupt_lsu_stall_ext_sys) |
                                    interrupt_lsu_stall_ecc_uncorrectable |
                                    interrupt_lsu_stall_ecc_correctable |
                                    interrupt_lsu_stall_instret_count |
                                    interrupt_lsu_stall_cycle_count |
                                    interrupt_lsu_stall_hpm_count ) & ~(instr_valid_retr | lsu_op_os);                                                                                       
  
  assign irq_taken                = interrupt_taken_ext | 
                                    interrupt_taken_timer | 
                                    interrupt_taken_sw |
                                    (|interrupt_taken_ext_sys) |
                                    interrupt_taken_ecc_uncorrectable |
                                    interrupt_taken_ecc_correctable |
                                    interrupt_taken_instret_count |
                                    interrupt_taken_cycle_count |
                                    interrupt_taken_hpm_count;
                                    
  assign locally_enabled_irq_captured     = interrupt_captured_local_en_ext | 
                                            interrupt_captured_local_en_timer | 
                                            interrupt_captured_local_en_sw |
                                            (|interrupt_captured_local_en_ext_sys) |
                                            interrupt_captured_local_en_ecc_uncorrectable |
                                            interrupt_captured_local_en_ecc_correctable |
                                            interrupt_captured_local_en_instret_count |
                                            interrupt_captured_local_en_cycle_count |
                                            interrupt_captured_local_en_hpm_count;                                                                            
                                                 
  assign cause_excpt_code_irq     = interrupt_taken_sw ? 5'd3 :
                                      interrupt_taken_timer ? 5'd7 :
                                        interrupt_taken_ext ? 5'd11 : 
                                          interrupt_taken_ecc_uncorrectable ? 5'd16 :
                                            interrupt_taken_ecc_correctable ? 5'd17 :
                                              interrupt_taken_instret_count ? 5'd18 :
                                                interrupt_taken_cycle_count ? 5'd19 :
                                                  interrupt_taken_hpm_count ? 5'd20 :
                                                    interrupt_taken_ext_sys[0] ? 5'd24 : 
                                                      interrupt_taken_ext_sys[1] ? 5'd25 :  
                                                        interrupt_taken_ext_sys[2] ? 5'd26 :
                                                          interrupt_taken_ext_sys[3] ? 5'd27 :
                                                            interrupt_taken_ext_sys[4] ? 5'd28 :
                                                              interrupt_taken_ext_sys[5] ? 5'd29 :
                                                                interrupt_taken_ext_sys[6] ? 5'd30 :
                                                                  interrupt_taken_ext_sys[7] ? 5'd31 : 5'd0;
                                    
  
  assign sys_ext_ip               = interrupt_pending_ext_sys;  
  assign gpr_correctable_ecc_ip   = interrupt_pending_ecc_correctable; 
  assign gpr_uncorrectable_ecc_ip = interrupt_pending_ecc_uncorrectable;   
  assign instret_count_ip         = interrupt_pending_instret_count; 
  assign cycle_count_ip           = interrupt_pending_cycle_count; 
  assign hpm_count_ip             = interrupt_pending_hpm_count; 
                                            
  


 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // if the LSU is talled waiting for an interrupt to be possibly taken, then must be able to commit an interrupt eventually in order to clear the 
  // stall (either because the interrupt is taken or is disabled in the retr stage)
  assert_priv_irq_stall_must_commit: assert property (@(posedge clk) disable iff (~resetn) 
                                                      irq_stall_lsu_req |-> ##[0:$] interrupt_could_commit);
  
  assert_priv_irq_stall_must_unstall: assert property (@(posedge clk) disable iff (~resetn)
                                                       irq_stall_lsu_req |-> ##[1:$] ~irq_stall_lsu_req);

  cover_csr_priv_irq_simultaneous_irq_sw_ext: cover property (@(posedge clk) disable iff (~resetn)
                                                              interrupt_taken_ext & base_ip_sw & base_ip_ext);   
                                                              

                                                               

 
`endif 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_expipe.sv
//
//   Purpose: core Execution pipeline
//            Contains the main blocks of the control and execution datapath
//            Fetch, Load-store, and memory protection are outsidfe this block to allow
//            this block (and the aformentioned blocks) to be formally verified in isolation
//            core is logically a 4 stage pipeline
//              - Fetch
//              - Decode
//              - Execute
//              - Retire (Memory-Commit)
//
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_core_cfg_pkg::*;

module miv_rv32_expipe
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH          = 32,
    parameter D_ADDR_WIDTH          = 32,
    parameter I_DATA_BYTES          = 4,
    parameter D_DATA_BYTES          = 4,
	parameter l_core_cfg_hw_debug           = 0,
    parameter l_core_cfg_num_triggers       = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_macc_multiplier = 0,
	parameter l_core_cfg_hw_compressed      = 0,
	parameter l_core_reset_vector           = 32'h6000_0000,
    parameter l_core_static_mtvec_base      = 32'h6000_0034,
    parameter l_core_cfg_static_mtvec_base  = 0,
    parameter l_core_cfg_static_mtvec_mode  = 0,
    parameter l_core_static_mtvec_mode      = 0,
	parameter l_core_num_sys_ext_irqs       = 7,
	parameter l_core_cfg_time_count_width   = 0,
    parameter l_core_cfg_lsu_fwd            = 1'b1,
    parameter l_core_cfg_csr_fwd            = 1'b1,
    parameter l_core_cfg_exu_fwd            = 1'b1,
	parameter l_core_cfg_gpr_type           = 0,
	parameter ECC_ENABLE                         = 0
   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                core_soft_reset,   
  output      logic                                gpr_uncorrectable_ecc_error,
  input  wire logic [(L_XLEN*2)-1:0]               time_count,
  input  wire logic [L_XLEN-1:0]                   hart_id,
  
  // Fetch Unit Interface
  output      logic                                ifu_expipe_fetch_en,
  output      logic                                ifu_expipe_req_branch_excpt_req_valid,
  output      logic                                ifu_expipe_req_branch_excpt_req_fenci,
  output      logic                                ifu_expipe_req_fenci_proceed,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_ready,    
  output      logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr,  // bcu result
  output      logic                                ifu_expipe_req_flush,
  output      logic [1:0]                          ifu_expipe_req_priv,
  input wire  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_resp_next_vaddr,
   
  input wire  logic                                ifu_expipe_resp_valid,
  output      logic                                ifu_expipe_resp_ready,
  input wire  logic [31:0]                         ifu_expipe_resp_ireg,
  input wire  logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr,
  input wire  logic                                ifu_expipe_resp_ireg_vaddr_valid,
  input wire  logic                                ifu_expipe_resp_compressed,
  input wire  logic                                ifu_expipe_resp_access_fault,  
  input wire  logic                                ifu_expipe_resp_access_mem_error,
  input wire  logic                                ifu_expipe_resp_access_parity_error,
  input wire  logic                                ifu_expipe_resp_access_misalign_error,
  input wire  logic                                ifu_expipe_resp_access_aborted,  
  
  
  // Memory Management Unit Interface
  
  // Load-Store Unit Interface
  output      logic                                lsu_flush,
  input wire  logic                                lsu_op_os,
  input wire  logic                                lsu_ld_op_os,   
  input wire  logic                                lsu_fence_op_os,
  output      logic                                lsu_req_valid,  
  input wire  logic                                lsu_req_ready,  
  output      logic[D_ADDR_WIDTH-1:0]              lsu_req_addr,
  output      logic                                lsu_req_addr_valid,
  output      logic [(D_DATA_BYTES*8)-1:0]         lsu_req_wr_data, 
  output      logic                                lsu_req_wr_data_valid,
  output      t_lsu_op                             lsu_req_op,   
   
  input wire  logic                                lsu_resp_valid,
  output      logic                                lsu_resp_ready, 
  input wire  logic [(D_DATA_BYTES*8)-1:0]         lsu_resp_rd_data,
  input wire  logic                                lsu_resp_ld_addr_misalign,     
  input wire  logic                                lsu_resp_ld_access_fault,      
  input wire  logic                                lsu_resp_str_amo_addr_misalign,
  input wire  logic                                lsu_resp_str_amo_access_fault, 
  input wire  logic                                lsu_resp_access_mem_error,
  input wire  logic                                lsu_resp_access_parity_error,
  input wire  logic                                lsu_resp_access_aborted, 
          
  
  // Debug Unit Interface
  input  wire  logic                               debug_reset,
  input  wire  logic                               debug_core_reset,
  input  wire  logic                               debug_active,
  input  wire  logic [L_XLEN-1:0]                  debug_csr_gpr_req_wr_data,       
  output logic                                     debug_csr_req_ready,  
  input  wire  logic                               debug_csr_req_valid,   
  input  wire  logic                               debug_csr_req_wr_en,        
  input  wire  logic                               debug_csr_req_rd_en,        
  input  wire logic [11:0]                         debug_csr_req_addr,        
  output logic [L_XLEN-1:0]                        debug_csr_resp_rd_data, 
  output logic                                     debug_csr_resp_valid, 
  input  wire  logic                               debug_csr_resp_ready,    // not currently used. must always be ready to accept responses when debug request made      
  input  wire  logic                               debug_gpr_req_valid, 
  output logic                                     debug_gpr_req_ready,     
  input  wire  logic                               debug_gpr_req_wr_en,        
  input  wire  logic                               debug_gpr_req_rd_en,        
  input  wire logic [4:0]                          debug_gpr_req_addr,      
  output logic [L_XLEN-1:0]                        debug_gpr_resp_rd_data,                                                                           
  output logic                                     debug_gpr_resp_valid,                           
  input  wire  logic                               debug_gpr_resp_ready,   // not currently used. must always be ready to accept responses when debug request made                            
  input  wire logic                                debug_halt_req,   
  output logic                                     debug_halt_ack,
  input  wire logic                                debug_resethalt_req,   
  output logic                                     debug_resethalt_ack,  
  input  wire logic                                debug_resume_req,   
  output logic                                     debug_resume_ack,
  output logic                                     debug_mode,   
  
  // Interrupt (LIC) Interface     
  
  input wire  logic                                m_sw_irq,
  input wire  logic                                m_timer_irq,
  input wire  logic                                m_external_irq,       
  input wire  logic [7:0]                          sys_ext_irq_src,         
  
  // Direct State Interface
  
  // Formal Trace Interface
  
  output logic [L_XLEN-1:0]                        formal_trace_instr,
  output logic [L_XLEN-1:0]                        formal_trace_pc,
  output logic                                     formal_trace_reset_taken,  
  output logic                                     formal_trace_instr_retire,
  
  //gpr ram init done signal to hold cpu in soft reset while init takes place
  output logic                                     gpr_ram_init_done
  );
   


  
//******************************************************************************
// Declarations
//  localparam HW_TRIGGER                                         = 1;
//  localparam l_core_cfg_num_triggers                       = (HW_TRIGGER) ? 2 : 0;
  localparam l_core_cfg_trigger_bus_width                  = (l_core_cfg_num_triggers > 0) ? l_core_cfg_num_triggers : 1;
  localparam logic l_core_cfg_gpr_ecc_uncorrectable_irq    = ECC_ENABLE;
  localparam logic l_core_cfg_gpr_ecc_correctable_irq      = ECC_ENABLE;
  localparam l_core_cfg_gpr_fwd_hzd                        = l_core_cfg_lsu_fwd | l_core_cfg_exu_fwd;
  
// FE pipeline stage signals
  logic                         flush_fe;

// DE pipeline stage signals
  t_expipe_stage_state                          stage_state_de;
  t_expipe_stage_state                          next_stage_state_de;
  logic                                         instr_valid_de;
  logic                                         instr_completing_de;
  logic                                         instr_accepted_de; 
  logic                                         instr_req_de;
  logic                                         next_stage_ready_de; 
  logic                                         stage_ready_de;
  logic                                         flush_de; 
  logic                                         update_ex_retr_ctrl_attbs_de;
  logic                                         force_trap_branch_de;
  logic                                         force_core_soft_reset_branch_de;
  logic                                         force_debug_exit_branch_de;
  logic                                         force_debug_nop_de;
  logic                                         fence_i_in_progress;
  logic                                         csr_trigger_wr_hzd_de;
  logic                                         trigger_breakpoint_de;
  logic                                         trigger_op_addr_valid_de;
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_req_de;
  logic                                         implicit_pseudo_instr_de;
  logic                                         debug_enter_req_de;
  logic                                         step_instruction_valid_de;
  
  logic                                         fetch_valid_de;
  logic                                         fetch_error_de;  
  
  logic                                         gpr_wr_en_de;     
  logic [4:0]                                   gpr_wr_sel_de;     
  logic                                         gpr_rs1_rd_valid_de;
  logic [4:0]                                   gpr_rs1_rd_sel_de;  
  logic                                         gpr_rs2_rd_valid_de; 
  logic [4:0]                                   gpr_rs2_rd_sel_de; 
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_de;
  
  logic [11:0]                                  sw_csr_addr_de;    
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_de;      
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_de; 
  logic                                         csr_rd_en_valid_de;
  logic                                         csr_wr_en_valid_de;
  
  logic                                         exu_op_abort_de;    
  t_exu_alu_operand0_sel                        operand0_mux_sel_de;
  t_exu_alu_operand1_sel                        operand1_mux_sel_de;
  t_exu_alu_op_sel                              alu_op_sel_de;             
  t_exu_shifter_op_sel                          shifter_unit_op_sel_de;     
  t_exu_shifter_places_sel                      shifter_unit_places_sel_de;    
  t_exu_shifter_operand_sel                     shifter_unit_operand_sel_de;
  t_exu_bcu_operand0_sel                        bcu_operand0_mux_sel_de;
  t_exu_bcu_operand1_sel                        bcu_operand1_mux_sel_de;
  t_exu_bcu_op_sel                              bcu_op_sel_de;            
  t_exu_alu_result_mux_sel                      exu_result_mux_sel_de;  
  
  t_branch_cond                                 branch_cond_de; 
  logic                                         fence_i_de;
  logic                                         fence_de;     
  t_lsu_op                                      lsu_op_de;  
  logic                                         wfi_de;  
  logic [L_XLEN-1:0]                            immediate_de;
  logic                                         illegal_instr_de;
  logic                                         csr_rd_illegal_de;
  logic                                         csr_wr_illegal_de;
  logic                                         illegal_instr_csr_de;
  logic                                         m_env_call_de;
  logic                                         m_ret_de;
  logic                                         d_ret_de;
  logic                                         dbreak_de;
  logic                                         stall_de;
  logic                                         gpr_rs1_stall_de;
  logic                                         gpr_rs2_stall_de;
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_fwd_de;      
  logic                                         gpr_rs1_rd_data_fwd_valid_de;
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_fwd_de;      
  logic                                         gpr_rs2_rd_data_fwd_valid_de;
  
// EX pipeline stage signals  
  t_expipe_stage_state                          stage_state_ex;
  t_expipe_stage_state                          next_stage_state_ex;
  logic                                         instr_valid_ex;
  logic                                         instr_completing_ex;
  logic                                         instr_can_complete_ex;
  logic                                         instr_accepted_ex; 
  logic                                         instr_req_ex;
  logic                                         next_stage_ready_ex; 
  logic                                         stage_ready_ex;
  logic                                         gpr_rd_rs1_completing_ex;
  logic                                         gpr_rd_rs2_completing_ex;   
  logic                                         gpr_rd_rs1_complete_ex; 
  logic                                         gpr_rd_rs2_complete_ex;
  logic                                         alu_op_completing_ex;  
  logic                                         alu_op_complete_ex;  
  logic                                         shift_op_completing_ex;    
  logic                                         shift_op_complete_ex; 
  logic                                         bcu_op_completing_ex;  
  logic                                         bcu_op_complete_ex; 
  logic                                         lsu_op_completing_ex;
  logic                                         lsu_op_complete_ex;
  logic                                         update_ctrl_attbs_ex; 
  
  logic                                         gpr_rs1_stall_ex;
  logic                                         gpr_rs2_stall_ex;   
  logic                                         trap_cause_hzd_ex;
  logic                                         epc_hzd_ex;       
  logic                                         trap_vec_hzd_ex;  
  logic                                         gpr_rs1_fwd_exu;
  logic                                         gpr_rs1_fwd_csr;
  logic                                         gpr_rs1_fwd_lsu;
  logic                                         gpr_rs1_stall_lsu;
  logic                                         gpr_rs1_stall_csr;
  logic                                         gpr_rs1_stall_exu;
  logic                                         gpr_rs2_fwd_exu;
  logic                                         gpr_rs2_fwd_csr;
  logic                                         gpr_rs2_fwd_lsu;
  logic                                         gpr_rs2_stall_lsu;
  logic                                         gpr_rs2_stall_csr;
  logic                                         gpr_rs2_stall_exu;
  
  logic                                         de_ex_pipe_implicit_pseudo_instr_ex;
  logic                                         de_ex_pipe_fence_i_ex;
  logic                                         de_ex_pipe_fence_ex;
  logic                                         de_ex_pipe_wfi_ex;
  logic                                         de_ex_pipe_i_access_fault_ex;
  logic                                         de_ex_pipe_i_access_mem_error_ex;
  logic                                         de_ex_pipe_i_access_parity_error_ex;
  logic                                         de_ex_pipe_i_access_misalign_error_ex;
  logic                                         de_ex_pipe_illegal_instr_ex;
  logic                                         de_ex_pipe_m_env_call_ex;
  logic                                         de_ex_pipe_trap_ret_ex;
  logic                                         de_ex_pipe_dbreak_ex;
  logic [L_XLEN-1:0]                            de_ex_pipe_immediate_ex;
  logic [31:0]                                  de_ex_pipe_curr_instr_enc_ex;
  logic [L_XLEN-1:0]                            de_ex_pipe_curr_pc_ex;
  logic                                         trap_pending_ex;
  logic                                         de_ex_pipe_any_trigger_ex;
  logic [l_core_cfg_trigger_bus_width-1:0] de_ex_pipe_trigger_ex;
  logic                                         de_ex_pipe_debug_enter_req_ex;
  logic                                         instr_inhibit_ex;
  logic                                         implicit_pseudo_instr_ex;  
  logic                                         fence_i_ex;  
  logic                                         fence_ex;  
  logic                                         wfi_ex;    
  logic                                         i_access_fault_ex;       
  logic                                         i_access_mem_error_ex;   
  logic                                         i_access_parity_error_ex;
  logic                                         i_access_misalign_error_ex;
  logic                                         illegal_instr_ex;
  logic                                         sw_csr_rd_illegal_ex;
  logic                                         m_env_call_ex;
  logic                                         trap_ret_ex;
  logic                                         dbreak_ex;
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_ex;
  logic                                         debug_enter_req_ex;
  logic [L_XLEN-1:0]                            immediate_ex;
  logic [31:0]                                  curr_instr_enc_ex;
  logic [L_XLEN-1:0]                            curr_pc_ex;
  logic                                         flush_ex;  
  
  logic                                         de_ex_pipe_gpr_wr_en_ex;  
  logic                                         de_ex_pipe_gpr_rs1_rd_valid_ex;
  logic                                         de_ex_pipe_gpr_rs2_rd_valid_ex;
  logic [4:0]                                   de_ex_pipe_gpr_wr_sel_ex;  
  logic [4:0]                                   de_ex_pipe_gpr_rs1_rd_sel_ex; 
  logic [4:0]                                   de_ex_pipe_gpr_rs2_rd_sel_ex;
  t_gpr_wr_mux_sel                              de_ex_pipe_gpr_wr_mux_sel_ex; 
  logic [L_XLEN-1:0]                            de_ex_pipe_gpr_rs1_rd_data_ex;      
  logic [L_XLEN-1:0]                            de_ex_pipe_gpr_rs2_rd_data_ex;      
  logic                                         de_ex_pipe_gpr_rs1_rd_data_valid_ex;
  logic                                         de_ex_pipe_gpr_rs2_rd_data_valid_ex;
  logic                                         gpr_wr_en_ex;     
  logic [4:0]                                   gpr_wr_sel_ex;     
  logic                                         gpr_rs1_rd_valid_ex;
  logic [4:0]                                   gpr_rs1_rd_sel_ex;  
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_ex;
  logic                                         gpr_rs1_rd_data_valid_ex;
  logic [L_XLEN-1:0]                            gpr_rs1_rd_data_fwd_ex;
  logic                                         gpr_rs1_rd_data_fwd_valid_ex;
  logic [L_XLEN-1:0]                            lsu_resp_rd_data_fwd;
  logic                                         lsu_resp_valid_fwd;
  logic                                         gpr_rs2_rd_valid_ex;
  logic [4:0]                                   gpr_rs2_rd_sel_ex; 
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_ex;
  logic                                         gpr_rs2_rd_data_valid_ex;
  logic [L_XLEN-1:0]                            gpr_rs2_rd_data_fwd_ex;
  logic                                         gpr_rs2_rd_data_fwd_valid_ex;
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_ex;   
 
  t_csr_alu_rd_op_sel                           de_ex_pipe_sw_csr_rd_op_ex;
  t_csr_alu_wr_op_sel                           de_ex_pipe_sw_csr_wr_op_ex;
  logic [11:0]                                  de_ex_pipe_sw_csr_addr_ex;
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_ex;     
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_ex;
  logic [11:0]                                  sw_csr_addr_ex;    
  
  logic                                         exu_op_abort_ex;
  logic                                         ex_retr_exu_res_accept_retr;
  t_exu_alu_op_sel                              de_ex_pipe_alu_op_sel_ex;
  t_exu_shifter_op_sel                          de_ex_pipe_shifter_unit_op_sel_ex;
  t_exu_alu_operand0_sel                        de_ex_pipe_operand0_mux_sel_ex;
  t_exu_alu_operand1_sel                        de_ex_pipe_operand1_mux_sel_ex;
  t_exu_shifter_places_sel                      de_ex_pipe_shifter_unit_places_sel_ex;
  t_exu_shifter_operand_sel                     de_ex_pipe_shifter_unit_operand_sel_ex;
  t_exu_alu_result_mux_sel                      de_ex_pipe_exu_result_mux_sel_ex;
  t_exu_alu_op_sel                              alu_op_sel_ex;
  t_exu_shifter_op_sel                          shifter_unit_op_sel_ex;
  t_exu_alu_operand0_sel                        operand0_mux_sel_ex;
  t_exu_alu_operand1_sel                        operand1_mux_sel_ex;
  t_exu_shifter_places_sel                      shifter_unit_places_sel_ex;
  t_exu_shifter_operand_sel                     shifter_unit_operand_sel_ex;
  t_exu_alu_result_mux_sel                      exu_result_mux_sel_ex;
  logic                                         exu_result_valid_ex;
  logic [L_XLEN-1:0]                            exu_result_ex;
  t_exu_flags                                   exu_result_flags_ex;
  logic [L_XLEN-1:0]                            align_result_ex;
  logic                                         align_result_valid_ex;
  logic                                         exu_update_result_reg;
  logic                                         exu_op_ready_ex;
  logic [L_XLEN-1:0]                            lsu_addr_result_ex;
  logic                                         lsu_addr_result_valid_ex;  
  logic                                         lsu_op_str_ex; 
  logic                                         lsu_req_stall_ex;     
  
  t_exu_bcu_op_sel                              de_ex_pipe_bcu_op_sel_ex;
  t_branch_cond                                 de_ex_pipe_branch_cond_ex;
  t_exu_bcu_operand0_sel                        de_ex_pipe_bcu_operand0_mux_sel_ex;
  t_exu_bcu_operand1_sel                        de_ex_pipe_bcu_operand1_mux_sel_ex;
  t_exu_bcu_op_sel                              bcu_op_sel_ex;
  t_branch_cond                                 branch_cond_ex;
  logic                                         branch_taken_ex;
  t_exu_bcu_operand0_sel                        bcu_operand0_mux_sel_ex;
  t_exu_bcu_operand1_sel                        bcu_operand1_mux_sel_ex;
  logic [L_XLEN-1:0]                            bcu_operand_trap_cause_ex;
  logic [L_XLEN-1:0]                            bcu_operand_trap_vec_ex;
  logic [L_XLEN-1:0]                            bcu_result_ex;
  logic                                         bcu_result_valid_ex;
  
  t_lsu_op                                      de_ex_pipe_lsu_op_ex;
  t_lsu_op                                      lsu_op_ex;
  t_lsu_op                                      lsu_op_ex_pipe_reg;
  t_lsu_op                                      lsu_op_ex_pipe;
  logic                                         instr_is_lsu_ldstr_ex;
  logic                                         instr_is_lsu_ldstr_reg_ex;
  
// RETR pipeline stage signals 
  t_expipe_stage_state                          stage_state_retr;
  t_expipe_stage_state                          next_stage_state_retr;
  logic                                         instr_req_retr;
  logic                                         exu_res_req_retr;
  logic                                         instr_valid_retr;
  logic                                         instr_completing_retr;
  logic                                         instr_accepted_retr; 
  logic                                         stage_ready_retr; 
//  logic                                         stage_ready_reg_retr;
  logic                                         update_ctrl_attbs_retr;
  logic                                         exu_result_reg_ready_retr;
  logic                                         flush_retr;
  logic                                         stall_retr;
  logic                                         irq_stall_lsu_req_retr;
  logic                                         irq_abort_lsu_req_retr;
  logic                                         wfi_waiting_retr;
  logic                                         trap_pending_retr;
    
  logic                                         ex_retr_pipe_implicit_pseudo_instr_retr;
  logic                                         ex_retr_pipe_fence_i_retr;  
  logic                                         ex_retr_pipe_wfi_retr;
  logic                                         ex_retr_pipe_i_access_fault_retr;
  logic                                         ex_retr_pipe_i_access_mem_error_retr;
  logic                                         ex_retr_pipe_i_access_parity_error_retr;
  logic                                         ex_retr_pipe_i_access_misalign_error_retr;
  logic                                         ex_retr_pipe_illegal_instr_retr;
  logic                                         ex_retr_pipe_m_env_call_retr;
  logic                                         ex_retr_pipe_trap_ret_retr;
  logic                                         ex_retr_pipe_dbreak_retr; 
  logic [l_core_cfg_trigger_bus_width-1:0] ex_retr_pipe_trigger_retr;
  logic [31:0]                                  ex_retr_pipe_curr_instr_enc_retr;
  logic [L_XLEN-1:0]                            ex_retr_pipe_curr_pc_retr; 
  logic                                         ex_retr_pipe_exu_result_valid_retr;
  logic [L_XLEN-1:0]                            ex_retr_pipe_exu_result_retr;
  logic                                         implicit_pseudo_instr_retr;
  logic                                         fence_i_retr;  
  logic                                         wfi_retr;
  logic                                         i_access_fault_retr;
  logic                                         i_access_mem_error_retr;
  logic                                         i_access_parity_error_retr;
  logic                                         i_access_misalign_error_retr;
  logic                                         illegal_instr_retr;
  logic                                         m_env_call_retr;
  logic                                         trap_ret_retr;
  logic                                         dbreak_retr; 
  logic [l_core_cfg_trigger_bus_width-1:0] trigger_retr;  
  logic                                         debug_enter_req_retr;
  logic [31:0]                                  curr_instr_enc_retr;
  logic [L_XLEN-1:0]                            curr_pc_retr; 
  logic                                         instr_retire_retr; 
  logic                                         exu_result_valid_retr;
  logic [L_XLEN-1:0]                            exu_result_retr;
  logic [L_XLEN-1:0]                            debug_csr_gpr_req_wr_data_dbgpipe; 
  logic                                         debug_csr_req_wr_en_dbgpipe;  
  logic                                         debug_csr_req_rd_en_dbgpipe;  
  logic [11:0]                                  debug_csr_req_addr_dbgpipe;

  logic                                         gpr_wr_completing_retr; 
  logic                                         gpr_wr_complete_retr;
  logic                                         ex_retr_pipe_gpr_wr_en_retr;
  logic [4:0]                                   ex_retr_pipe_gpr_wr_sel_retr;
  t_gpr_wr_mux_sel                              ex_retr_pipe_gpr_wr_mux_sel_retr;
  logic                                         gpr_wr_en_retr;
  logic [4:0]                                   gpr_wr_sel_retr;
  t_gpr_wr_mux_sel                              gpr_wr_mux_sel_retr;
  logic [L_XLEN-1:0]                            gpr_wr_data_retr;
  logic                                         gpr_wr_valid_retr;
  logic                                         gpr_wr_ready_retr;    
    
  logic                                         gpr_wr_valid_mux;        
  logic [4:0]                                   gpr_wr_sel_mux;       
  logic [L_XLEN-1:0]                            gpr_wr_data_mux;      
  logic                                         gpr_rs1_rd_valid_mux; 
  logic [4:0]                                   gpr_rs1_rd_sel_mux;    
  logic                                         gpr_rs2_rd_valid_mux;
  logic [4:0]                                   gpr_rs2_rd_sel_mux;    
  logic                                         gpr_wr_ready_sig;
  logic                                         gpr_rs1_rd_ready_sig;  
  logic[L_XLEN-1:0]                             gpr_rs1_rd_data_sig;
  logic                                         gpr_rs1_rd_data_valid_sig;  
  logic                                         gpr_rs2_rd_ready_sig; 
  logic[L_XLEN-1:0]                             gpr_rs2_rd_data_sig;
  logic                                         gpr_rs2_rd_data_valid_sig; 
 logic                                          gpr_rs2_rd_valid_dbgpipe;
 logic [4:0]                                    gpr_rs2_rd_sel_dbgpipe;  
 logic                                          gpr_rs2_rd_valid_stg;
 logic [4:0]                                    gpr_rs2_rd_sel_stg; 
   
  logic                                         trap_taken_retr;
  logic                                         soft_reset_taken_retr;
  logic                                         soft_reset_taken_unmasked_retr;
  logic                                         vectored_interrupt_taken_retr;
  logic                                         csr_priv_mtvec_excpt_vectored_retr;
  logic                                         interrupt_taken_retr;
  logic                                         soft_reset_pending_retr;
  logic                                         next_soft_reset_pending_retr;
  
  logic [11:0]                                  ex_retr_pipe_sw_csr_addr_retr; 
  t_csr_alu_wr_op_sel                           ex_retr_pipe_sw_csr_wr_op_retr; 
  t_csr_alu_rd_op_sel                           ex_retr_pipe_sw_csr_rd_op_retr; 
  logic [11:0]                                  sw_csr_addr_retr;
  t_csr_alu_wr_op_sel                           sw_csr_wr_op_retr; 
  t_csr_alu_rd_op_sel                           sw_csr_rd_op_retr; 
  logic [L_XLEN-1:0]                            sw_csr_rd_data_retr;
  logic                                         sw_csr_rd_data_valid_retr; 
  logic                                         csr_completing_retr;
  logic                                         csr_complete_retr;  
  logic                                         csr_result_reg_ready_retr;  
  logic                                         sw_csr_op_ready_retr;
  logic                                         csr_explicit_wr_retr;
  logic [L_XLEN-1:0]                            csr_priv_misa_retr;
  logic [4:0]                                   csr_priv_cause_excpt_code_retr;
  logic [L_XLEN-1:0]                            csr_priv_mtvec_excpt_vec_retr;
  logic [L_XLEN-1:0]                            csr_priv_mtvec_epc_retr;
  logic [L_XLEN-1:0]                            csr_priv_dpc_retr;
  logic [1:0]                                   priv_mode_retr; 
  logic                                         debug_mode_retr;
  logic                                         debug_enter_retr;
  logic                                         debug_mode_retire_mask_retr;
  logic                                         debug_exit_retr; 
  logic                                         cfg_hw_mul_en_retr;  
  logic                                         cfg_hw_div_en_retr;     
  logic                                         cfg_atomics_en_retr;    
  logic                                         cfg_compressed_en_retr;
  
  logic                                         lsu_op_completing_retr;
  logic                                         lsu_op_complete_retr;  
  t_lsu_op                                      ex_retr_pipe_lsu_op_retr;
  t_lsu_op                                      lsu_op_retr;
  logic                                         lsu_req_stall_retr;
  logic                                         instr_is_lsu_op_retr;
  
  
  logic                                         bus_error_i_irq_src;          
  logic                                         parity_error_i_irq_src;       
  logic                                         bus_error_d_irq_src;          
  logic                                         parity_error_d_irq_src;      
  logic                                         gpr_uncorrectable_ecc_irq_src;
  logic                                         gpr_correctable_ecc_irq_src;
 
  //signal to trigger init of gpr ram when there is a soft reset or debug reset
  logic                                         gpr_ram_init_soft_debug_reset; 

//******************************************************************************
// Main code

  //--------------------------------------------------------
  // Pipeline
  //--------------------------------------------------------
  
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  // Fetch stage (FE)
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  
  // The fetch stage requests a 32 bit memory fetch from memory (even when compressed instructions fetched/executed)
  // Branches/exceptions/soft-reset will immediately cause the instructions currently fetched/being decoded to be flushed and fetching to occur  
  // at the branch/exception/reset target address generated in the ex stage
  // fence.i will be treated as a branch to the next instruction after the fence.i, such that the pipeline before the fence.i 
  // will be flushed and instructions refeteched after the fence.i has been indicated as completing in the retr stage
  
   //--------------------------------------------------------
  // Instruction fetch unit interface
  //--------------------------------------------------------
  // The fetch stage is entirely handled in the seperate instruction fetch unit to simplify independent formal verification and make IFU interchangeable for more capability 
  assign flush_fe = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; 
  
  assign ifu_expipe_fetch_en                   = ~debug_mode_retr; 
  assign ifu_expipe_req_branch_excpt_req_valid = branch_taken_ex; 
  assign ifu_expipe_req_branch_excpt_req_fenci = fence_i_ex  & ~instr_inhibit_ex;
  assign ifu_expipe_req_branch_excpt_vaddr     = {bcu_result_ex[I_ADDR_WIDTH-1:1],1'b0};
  assign ifu_expipe_req_flush                  = flush_fe;                             
  assign ifu_expipe_req_priv                   = priv_mode_retr;

 
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++
  // Decode stage (DE)
  //+++++++++++++++++++++++++++
  //+++++++++++++++++++++++++++ 
  
  // The decode stage returns a 32 bit memory fetch from memory, aligns (where required 
  // for compressed instructions and halfword aligned uncompressed instructions), and decodes the returned
  // instruction.
  // To avoid stalling the fetch stage (and requiring additional buffering), in the case of a hazard caused 
  // by an instruction in the retr stage changing MISA which may cause the current instruction to be decoded differently,
  // the fe stage will instead refetch the instruction such that it can be decoded correctly when the MISA update becomes 
  // visible
  // Insert an instruction if nothing fetched and debug entry request such that it propagates through the pipe as a nop pseudo-instruction
  // (decoder will decode nop because ifu_expipe_resp_valid) not assrted, then overide request generation)
  
  //--------------------------------------------------------
  // Stage handshaking/control
  //--------------------------------------------------------
   
  
  assign instr_req_de  = (ifu_expipe_resp_valid & ~flush_de) 
                         | force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de | 
                         force_debug_nop_de;
  
  assign instr_accepted_de   = instr_req_de & stage_ready_de;
  
  assign stall_de = csr_trigger_wr_hzd_de |
                    gpr_rs1_stall_de |
                    gpr_rs2_stall_de; 
  
  always @*
  begin
    case(stage_state_de)
      expipe_stage_state_ready : 
      begin
        next_stage_state_de = (instr_accepted_de & !(instr_completing_de | flush_de)) ? expipe_stage_state_busy : expipe_stage_state_ready;
        //instr_accepted_de   = instr_req_de & stage_ready_ex & ~csr_trigger_wr_hzd_de;
        stage_ready_de      = stage_ready_ex & ~stall_de;
        instr_valid_de      = instr_req_de;
        
      end
    
      expipe_stage_state_busy : 
      begin
        //next_stage_state_de = instr_req_de ? expipe_stage_state_busy : (instr_completing_de | flush_de) ? expipe_stage_state_ready : stage_state_de;
        next_stage_state_de = (stage_ready_ex & ~stall_de) ? expipe_stage_state_ready : stage_state_de;
        //next_stage_state_de = (instr_completing_de | flush_de) ? expipe_stage_state_ready : stage_state_de;
        //instr_accepted_de   = 1'b0;
        stage_ready_de      = 1'b0;
        instr_valid_de      = 1'b1;
      end
    
      default :
        begin
        next_stage_state_de = expipe_stage_state_ready;
        //instr_accepted_de   = 1'b0;
        stage_ready_de      = 1'b0;
        instr_valid_de      = 1'b0;
      end
    endcase
  end 

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_de  <= expipe_stage_state_ready;
    else
      stage_state_de  <= next_stage_state_de;     
  end    
    
  assign flush_de            = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; // 
  assign instr_completing_de = instr_accepted_ex;
  
  // Hazards
  //--------------
  
  
  // Trigger logic
  //--------------
  // Trigger comparison is done in DE stage because specification requires tha trigger occurs _before_ instruction execution
  // By performing in DE stage, trigger can be handled by the pipeline just as an EBREAK instruction  
  // If trigger compare registers are to be written by CSR instruction in EX or RETR stage, need to stall DE stage until write completes
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_de
    assign csr_trigger_wr_hzd_de    =  (((sw_csr_addr_ex   == l_core_csr_addr_tselect) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata1) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata2) |
                                         (sw_csr_addr_ex   == l_core_csr_addr_tdata3)) & (sw_csr_wr_op_ex != csr_alu_wr_op_none)) |
                                       (((sw_csr_addr_retr == l_core_csr_addr_tselect) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata1) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata2) |
                                         (sw_csr_addr_retr == l_core_csr_addr_tdata3)) & (sw_csr_wr_op_retr != csr_alu_wr_op_none));                                 

    
    assign trigger_op_addr_valid_de = ifu_expipe_resp_valid & 
                                      ~(flush_de | stall_de | force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
    
  end else
  begin : ngen_trig_de
  
    assign csr_trigger_wr_hzd_de = 1'b0;
    assign trigger_op_addr_valid_de = 1'b0;
    
  end
  endgenerate    
  
  // enable step pending when valid (non-pseudo instruction) accepted by ex phase
  assign step_instruction_valid_de = instr_accepted_ex & ~implicit_pseudo_instr_de;


  //--------------------------------------------------------
  // Instruction fetch unit interface
  //--------------------------------------------------------
  
  assign ifu_expipe_resp_ready  = stage_ready_de;  
  
  assign fetch_error_de         = ifu_expipe_resp_access_fault |  
                                  ifu_expipe_resp_access_mem_error |
                                  ifu_expipe_resp_access_parity_error |
                                  ifu_expipe_resp_access_misalign_error |
                                  ifu_expipe_resp_access_aborted; 

  
  //--------------------------------------------------------
  // Instruction decoder unit instance
  //--------------------------------------------------------
  
 
  
  // inhibit decode, but still propagate valid through the pipeline such that the trap gets handled in retr                    
  assign fetch_valid_de = ifu_expipe_resp_valid & ~fetch_error_de;   
  
  // decoder will generate the decode to handle the trap action (branch to exception vector)
  // Also need to overide vectored interrupt handling (though trap has priority), and bcu_operand1_sel to be the address of the 
  // instruction in de instead of exvec - in order to pass this into the bcu in the ex stage, use imm
  
  assign force_core_soft_reset_branch_de  = soft_reset_taken_retr;
  assign force_trap_branch_de             = trap_taken_retr;
  assign force_debug_exit_branch_de       = debug_exit_retr; 
  
  // don't force a debug entry nop if a fence_i is in progress as the next address may be invalid
  // wait for the fence_i to complete
  assign fence_i_in_progress              = (fence_i_ex & instr_valid_ex) | (fence_i_retr & instr_valid_retr);
  assign force_debug_nop_de               = debug_enter_req_de & (~ifu_expipe_resp_valid) & (~fence_i_in_progress);  
                                                                                              
  assign implicit_pseudo_instr_de = (force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de) | force_debug_nop_de ;
  
  miv_rv32_idecode  
  #(
   .GEN_DECODE_RV32I                 (l_core_cfg_hw_integer),
   .GEN_DECODE_RV32M                 (l_core_cfg_hw_multiply_divide),
   .GEN_DECODE_RV32C                 (l_core_cfg_hw_compressed)
  )

  u_idecode_0
  (
  .clk                               (clk                             ),
  .resetn                            (resetn                          ),
  .core_reset                        (force_core_soft_reset_branch_de ),   
  .trap_taken                        (force_trap_branch_de            ), 
  .debug_exit                        (force_debug_exit_branch_de      ),
  .vectored_interrupt_taken          (vectored_interrupt_taken_retr   ),
  .cfg_hw_mul_en                     (cfg_hw_mul_en_retr              ), 
  .cfg_hw_div_en                     (cfg_hw_div_en_retr              ),
  .cfg_atomics_en                    (cfg_atomics_en_retr             ), // Currently not supported in core
  .cfg_compressed_en                 (cfg_compressed_en_retr          ),
  .idecode_ready                     (/*open*/                        ), // Fully combinatorial for now so handled externally
  .debug_mode                        (debug_mode_retr                 ),
  .priv_mode                         (priv_mode_retr                  ),
  .instruction                       (ifu_expipe_resp_ireg            ),
  .instruction_valid                 (fetch_valid_de                  ),
  .instruction_compressed            (ifu_expipe_resp_compressed      ),
  .mnemonic                          (/*open*/                        ), // Used for debug only
  .immediate                         (immediate_de                    ),
  .illegal_instr                     (illegal_instr_de                ),
  .m_env_call                        (m_env_call_de                   ),
  .m_ret                             (m_ret_de                        ),
  .d_ret                             (d_ret_de                        ),
  .dbreakpoint                       (dbreak_de                       ),
  .gpr_wr_valid                      (gpr_wr_en_de                    ),
  .gpr_wr_sel                        (gpr_wr_sel_de                   ),
  .gpr_rs1_rd_valid                  (gpr_rs1_rd_valid_de             ),
  .gpr_rs1_rd_sel                    (gpr_rs1_rd_sel_de               ),
  .gpr_rs2_rd_valid                  (gpr_rs2_rd_valid_de             ),
  .gpr_rs2_rd_sel                    (gpr_rs2_rd_sel_de               ),
  .gpr_wr_mux_sel                    (gpr_wr_mux_sel_de               ),
  .sw_csr_addr                       (sw_csr_addr_de                  ),
  .sw_csr_wr_op                      (sw_csr_wr_op_de                 ),
  .sw_csr_rd_op                      (sw_csr_rd_op_de                 ),
  .operand0_mux_sel                  (operand0_mux_sel_de             ),
  .operand1_mux_sel                  (operand1_mux_sel_de             ),
  .alu_op_sel                        (alu_op_sel_de                   ),
  .shifter_operand_sel               (shifter_unit_operand_sel_de     ),
  .shifter_unit_places               (shifter_unit_places_sel_de      ),
  .shifter_unit_op_sel               (shifter_unit_op_sel_de          ),
  .bcu_operand0_mux_sel              (bcu_operand0_mux_sel_de         ),
  .bcu_operand1_mux_sel              (bcu_operand1_mux_sel_de         ),
  .bcu_op_sel                        (bcu_op_sel_de                   ),
  .exu_result_mux_sel                (exu_result_mux_sel_de           ),
  .branch_cond                       (branch_cond_de                  ),
  .fence_i                           (fence_i_de                      ),
  .fence                             (fence_de                        ), 
  .lsu_op                            (lsu_op_de                       ),
  .wfi                               (wfi_de                          )
  );
  
  // Check for illegal CSR access in the DE stage
  // Because all CSR accesses in core are determined only by address as Core
  // is machine mode only, can perform checks in advance of retire stage which simplifies
  // trap suppression of load-stores
  
  assign csr_rd_en_valid_de = (sw_csr_rd_op_de != csr_alu_rd_op_none); 
  assign csr_wr_en_valid_de = (sw_csr_wr_op_de != csr_alu_wr_op_none); 
  
    miv_rv32_csr_decode
    #(
      .CHECK_ILLEGAL     (1)  // 
    )
    u_miv_rv32_csr_decode_de_0
    (
      .clk                         (clk                 ),
      .resetn                      (resetn              ),
      .debug_mode                  (1'b0                ), // only checking for normal executing mode accesses 
      .csr_rd_addr                 (sw_csr_addr_de      ),
      .csr_rd_en_valid             (csr_rd_en_valid_de  ),
      .csr_wr_addr                 (sw_csr_addr_de      ),
      .csr_wr_en_valid             (csr_wr_en_valid_de  ),
      .csr_reg_rd_sel              (                    ),  // open, Only checking for illegal access in DE stage
      .csr_reg_wr_sel              (                    ),  // open, Only checking for illegal access in DE stage
      .csr_rd_illegal              (csr_rd_illegal_de   ),  
      .csr_wr_illegal              (csr_wr_illegal_de   )      
    ); 

  assign illegal_instr_csr_de = illegal_instr_de |
                                csr_rd_illegal_de |
                                csr_wr_illegal_de;
                                
  // if l_core_cfg_gpr_rd_ex = 0, read the GPRs in the DE stage. This makes decode timing harder, adds additional stalls for lsu and csr accesses
  // and creates additional forwarding paths and pipeline registers, but in some cases may improve EX stage timing if RAM read timing is fast compared 
  // to logic speed.
  
  generate if (l_core_cfg_lsu_fwd)
  begin : gen_rs1_lsu_fwd_data_assign
    
    assign lsu_resp_rd_data_fwd = lsu_resp_rd_data;
    assign lsu_resp_valid_fwd   = lsu_resp_valid;
    
  end
  else begin : gen_rs1_lsu_stall_data_assign
  
    assign lsu_resp_rd_data_fwd = {L_XLEN{1'b0}};
    assign lsu_resp_valid_fwd   = 1'b0;                                   
  
  end
  endgenerate
  
  generate if (!l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_de
  
    logic gpr_rs1_fwd_exu_ex_de;
    logic gpr_rs1_stall_csr_ex_de;
    logic gpr_rs1_stall_lsu_ex_de;
    logic gpr_rs1_fwd_exu_retr_de;
    logic gpr_rs1_fwd_csr_retr_de;
    logic gpr_rs1_fwd_lsu_retr_de;
    logic gpr_rs2_fwd_exu_ex_de;
    logic gpr_rs2_stall_csr_ex_de;
    logic gpr_rs2_stall_lsu_ex_de;
    logic gpr_rs2_fwd_exu_retr_de;
    logic gpr_rs2_fwd_csr_retr_de;
    logic gpr_rs2_fwd_lsu_retr_de;  
    
    // determine if GPR read result should be forwarded from later stage or from GPR 
    // do not forward reads from x0, as the result will always be 0, even if the sat being written to it is not.
    // EX stage forwarding has priority over retr stage forwarding
    // cannot forward LSU or CSR results from EX stage as they are not known until RETR stage, so have to stall
    // 
  
    assign gpr_rs1_fwd_exu_ex_de       = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs1_stall_csr_ex_de     = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_csr);                            
  
    assign gpr_rs1_stall_lsu_ex_de     = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) &   
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs1_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_lsu);     
                                         
    assign gpr_rs1_stall_de            =  gpr_rs1_stall_csr_ex_de |  
                                          gpr_rs1_stall_lsu_ex_de |
                                          (instr_valid_de & gpr_rs1_rd_valid_de & ~gpr_rs1_rd_ready_sig) |
                                          (instr_valid_de & gpr_rs1_rd_valid_de & ~gpr_rs1_rd_data_fwd_valid_de);                       
                                      
    assign gpr_rs1_fwd_exu_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs1_fwd_csr_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                              
  
    assign gpr_rs1_fwd_lsu_retr_de   = (instr_valid_de & gpr_rs1_rd_valid_de & (gpr_rs1_rd_sel_de != 5'd0)) &   
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);    
                                       
    always @*
    begin
       casez({gpr_rs1_fwd_lsu_retr_de,gpr_rs1_fwd_csr_retr_de,gpr_rs1_fwd_exu_retr_de,gpr_rs1_fwd_exu_ex_de})
         4'b0000 : // No forwarding
         begin
           gpr_rs1_rd_data_fwd_de        = gpr_rs1_rd_data_sig;      
           gpr_rs1_rd_data_fwd_valid_de  = gpr_rs1_rd_data_valid_sig;
         end
         4'b???1 : // EXU forward (ex stage)
         begin
           gpr_rs1_rd_data_fwd_de        = exu_result_ex;       // REVISIT make sure this works for multistage ops in EXU
           gpr_rs1_rd_data_fwd_valid_de  = exu_result_valid_ex;
         end
         4'b1000 : // LSU forward (retr stage only)
         begin
           gpr_rs1_rd_data_fwd_de        = lsu_resp_rd_data_fwd;
           gpr_rs1_rd_data_fwd_valid_de  = lsu_resp_valid_fwd;  
         end
         4'b0100 : // CSR forward (retr stage only)
         begin
           gpr_rs1_rd_data_fwd_de        = sw_csr_rd_data_retr;      
           gpr_rs1_rd_data_fwd_valid_de  = sw_csr_rd_data_valid_retr;
         end
         4'b0010 : // EXU forward (retr stage)
         begin
           gpr_rs1_rd_data_fwd_de        = exu_result_retr;      
           gpr_rs1_rd_data_fwd_valid_de  = exu_result_valid_retr;
         end
         default : // illegal
         begin
           gpr_rs1_rd_data_fwd_de        = {L_XLEN{1'b0}};      
           gpr_rs1_rd_data_fwd_valid_de  = 1'b1;
         end
       endcase
     end        
     
    assign gpr_rs2_fwd_exu_ex_de       = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs2_stall_csr_ex_de     = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) & 
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_csr);                            
  
    assign gpr_rs2_stall_lsu_ex_de     = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) &   
                                         (instr_valid_ex & gpr_wr_en_ex) & (gpr_rs2_rd_sel_de == gpr_wr_sel_ex) & (gpr_wr_mux_sel_ex == gpr_wr_mux_sel_lsu);     
                                         
    assign gpr_rs2_stall_de            =  gpr_rs2_stall_csr_ex_de |  
                                          gpr_rs2_stall_lsu_ex_de  |
                                          (instr_valid_de & gpr_rs2_rd_valid_de & ~gpr_rs2_rd_ready_sig) |
                                          (instr_valid_de & gpr_rs2_rd_valid_de & ~gpr_rs2_rd_data_fwd_valid_de);                        
                                      
    assign gpr_rs2_fwd_exu_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
                                
    assign gpr_rs2_fwd_csr_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) & 
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                              
  
    assign gpr_rs2_fwd_lsu_retr_de   = (instr_valid_de & gpr_rs2_rd_valid_de & (gpr_rs2_rd_sel_de != 5'd0)) &   
                                       (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_de == gpr_wr_sel_retr) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);    
                                       
    always @*
    begin
       casez({gpr_rs2_fwd_lsu_retr_de,gpr_rs2_fwd_csr_retr_de,gpr_rs2_fwd_exu_retr_de,gpr_rs2_fwd_exu_ex_de})
         4'b0000 : // No forwarding
         begin
           gpr_rs2_rd_data_fwd_de        = gpr_rs2_rd_data_sig;      
           gpr_rs2_rd_data_fwd_valid_de  = gpr_rs2_rd_data_valid_sig;
         end
         4'b???1 : // EXU forward (ex stage)
         begin
           gpr_rs2_rd_data_fwd_de        = exu_result_ex;       // REVISIT make sure this works for multistage ops in EXU
           gpr_rs2_rd_data_fwd_valid_de  = exu_result_valid_ex;
         end
         4'b1000 : // LSU forward (retr stage only)
         begin
           gpr_rs2_rd_data_fwd_de        = lsu_resp_rd_data;
           gpr_rs2_rd_data_fwd_valid_de  = lsu_resp_valid;
         end
         4'b0100 : // CSR forward (retr stage only)
         begin
           gpr_rs2_rd_data_fwd_de        = sw_csr_rd_data_retr;      
           gpr_rs2_rd_data_fwd_valid_de  = sw_csr_rd_data_valid_retr;
         end
         4'b0010 : // EXU forward (retr stage)
         begin
           gpr_rs2_rd_data_fwd_de        = exu_result_retr;      
           gpr_rs2_rd_data_fwd_valid_de  = exu_result_valid_retr;
         end
         default : // illegal
         begin
           gpr_rs2_rd_data_fwd_de        = {L_XLEN{1'b0}};      
           gpr_rs2_rd_data_fwd_valid_de  = 1'b1;
         end
       endcase
     end                                                                 
  
  end
  else begin : ngen_read_gpr_de
    assign gpr_rs1_rd_data_fwd_de        = {L_XLEN{1'b0}};     
    assign gpr_rs1_rd_data_fwd_valid_de  = 1'b0;
    assign gpr_rs1_stall_de              = 1'b0;
    assign gpr_rs2_rd_data_fwd_de        = {L_XLEN{1'b0}};     
    assign gpr_rs2_rd_data_fwd_valid_de  = 1'b0;
    assign gpr_rs2_stall_de              = 1'b0;
  end  
  endgenerate


  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  // Execute stage (EX)
  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  
  // The execute stage executes the instruction decoded in the previous stage.
  // Arithmetic and logical operations as well as branch decision computation will be performed in the EXU
  // Load/Store operations will be performed in the LSU
  // Branch/exception target computation will be performed in the BCU
  // pipeline controls from de to ex-stage
  //
  // need to mask controls with instruction valid to deal with case where a valid instruction is decoded
  // but then suppressed due to a flush
  
  // Execution FSM
  // Instructions may comprise the result of several units results sequentially (eg store uses shift unit for alignment and alu for store address
  // computation which then are inputs to the LSU)
  // Execution may also take multiple cycles (eg (optionally) multi-cycle multiply, divide, shift)
  // The decoded operation for each unit determines if a unit is perfoming an operation for the given instruction, the ordering of operations
  // is fixed (eg GPR/CSR read -> ALU/shift/BCU -> LSU -> GPR/CSR write), though not all units required for all operations. 

  
  //---------------------------------------------------------------------------------------
  //---------------------------------------------------------------------------------------

  assign instr_req_ex  = instr_accepted_de | 
                         force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de;
  
  always @*
  begin
    case(stage_state_ex)
      expipe_stage_state_ready : 
      begin
        next_stage_state_ex = instr_req_ex ? expipe_stage_state_busy : expipe_stage_state_ready;
        instr_accepted_ex   = instr_req_ex;
        stage_ready_ex      = 1'b1;
        instr_valid_ex      = 1'b0;
      end
    
      expipe_stage_state_busy : 
      begin
        next_stage_state_ex = instr_req_ex ? expipe_stage_state_busy : (instr_completing_ex | flush_ex) ? expipe_stage_state_ready : stage_state_ex;
        instr_accepted_ex   = instr_req_ex & (instr_completing_ex | flush_ex);
        stage_ready_ex      = (instr_completing_ex | flush_ex);
        instr_valid_ex      = 1'b1;
      end
    
      default :
        begin
        next_stage_state_ex = expipe_stage_state_ready;
        instr_accepted_ex   = 1'b0;
        stage_ready_ex      = 1'b0;
        instr_valid_ex      = 1'b0;
      end
    endcase
  end
  

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_ex  <= expipe_stage_state_ready;
    else
      stage_state_ex  <= next_stage_state_ex;     
  end    
  
  // inhibit instruction if a trap or debug entry is going to occur
  // cannot block pseudo operations as the trap branch is itself an pseudo operation 
  assign instr_inhibit_ex      = (((trap_pending_retr | trap_pending_ex) & ~implicit_pseudo_instr_ex) | 
                                  debug_enter_req_ex |
                                  (irq_abort_lsu_req_retr & instr_is_lsu_ldstr_reg_ex)) &
                                 instr_valid_ex;
  
  assign instr_can_complete_ex =   (gpr_rd_rs1_complete_ex   &
                                    gpr_rd_rs2_complete_ex   &
                                    alu_op_complete_ex       &
                                    shift_op_complete_ex     &
                                    bcu_op_complete_ex   &
                                    lsu_op_complete_ex);
                                  
  assign instr_completing_ex  = instr_can_complete_ex & stage_ready_retr;                               
  
  assign update_ctrl_attbs_ex = instr_accepted_ex; 
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
    // pipeline controls
      de_ex_pipe_implicit_pseudo_instr_ex    <= implicit_pseudo_instr_de;  // tell ex stage that this is an inserted not fetched instruction
      de_ex_pipe_fence_i_ex                  <= fence_i_de;
      de_ex_pipe_fence_ex                    <= fence_de;
      de_ex_pipe_wfi_ex                      <= wfi_de;  
      de_ex_pipe_i_access_fault_ex           <= ifu_expipe_resp_access_fault & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_i_access_mem_error_ex       <= ifu_expipe_resp_access_mem_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);   
      de_ex_pipe_i_access_parity_error_ex    <= ifu_expipe_resp_access_parity_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_i_access_misalign_error_ex  <= ifu_expipe_resp_access_misalign_error & ~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de);
      de_ex_pipe_illegal_instr_ex            <= illegal_instr_csr_de;
      de_ex_pipe_m_env_call_ex               <= m_env_call_de;
      de_ex_pipe_trap_ret_ex                 <= (m_ret_de  | d_ret_de) ;
      de_ex_pipe_dbreak_ex                   <= dbreak_de;         
      de_ex_pipe_immediate_ex                <= immediate_de;
      de_ex_pipe_curr_instr_enc_ex           <= ifu_expipe_resp_ireg & {32{~(force_trap_branch_de | force_core_soft_reset_branch_de | force_debug_exit_branch_de)}};
       
    end    
  end
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_pipe_reg_de_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_trigger_ex <= trigger_req_de;
      end
    end
    
    assign de_ex_pipe_any_trigger_ex = |de_ex_pipe_trigger_ex;
    assign trigger_ex                = de_ex_pipe_trigger_ex & {l_core_cfg_num_triggers{instr_valid_ex}};
    
  end
  else begin : ngen_trig_pipe_reg_de_ex
  
    assign de_ex_pipe_any_trigger_ex = 1'b0;
    
  end
  endgenerate
  
  // mark instruction if debug entry is requested
  // this will suppress load-stores in the ex phase and any state updates in the retr stage
  generate if(l_core_cfg_hw_debug)
  begin : gen_pipe_debug_enter_req_de_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_debug_enter_req_ex <= debug_enter_req_de; 
        de_ex_pipe_curr_pc_ex         <= force_debug_nop_de ? ifu_expipe_resp_next_vaddr : ifu_expipe_resp_ireg_vaddr;
      end
    end
    
    assign debug_enter_req_ex          = de_ex_pipe_debug_enter_req_ex & instr_valid_ex;
    
  end
  else begin : ngen_pipe_debug_enter_req_de_ex
  
    assign debug_enter_req_ex = 1'b0;
    
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin
        de_ex_pipe_curr_pc_ex                  <= ifu_expipe_resp_ireg_vaddr;
      end
    end
    
  end
  endgenerate
    
  assign trap_pending_ex             = de_ex_pipe_i_access_fault_ex |
                                       de_ex_pipe_i_access_mem_error_ex |
                                       de_ex_pipe_i_access_parity_error_ex |
                                       de_ex_pipe_i_access_misalign_error_ex |
                                       de_ex_pipe_illegal_instr_ex |
                                       de_ex_pipe_m_env_call_ex |
                                       de_ex_pipe_dbreak_ex |
                                       de_ex_pipe_any_trigger_ex;  // treat trigger as an exception in this stage as has same effect (inhibits lsu ops)
   
  assign implicit_pseudo_instr_ex    = de_ex_pipe_implicit_pseudo_instr_ex & instr_valid_ex;
  assign fence_i_ex                  = de_ex_pipe_fence_i_ex & instr_valid_ex;
  assign fence_ex                    = de_ex_pipe_fence_ex & instr_valid_ex;
  assign wfi_ex                      = de_ex_pipe_wfi_ex & instr_valid_ex;
  assign i_access_fault_ex           = de_ex_pipe_i_access_fault_ex & instr_valid_ex;
  assign i_access_mem_error_ex       = de_ex_pipe_i_access_mem_error_ex & instr_valid_ex;
  assign i_access_parity_error_ex    = de_ex_pipe_i_access_parity_error_ex & instr_valid_ex;
  assign i_access_misalign_error_ex  = de_ex_pipe_i_access_misalign_error_ex & instr_valid_ex;
  assign illegal_instr_ex            = de_ex_pipe_illegal_instr_ex  & instr_valid_ex;
  assign m_env_call_ex               = de_ex_pipe_m_env_call_ex & instr_valid_ex;
  assign trap_ret_ex                 = de_ex_pipe_trap_ret_ex & instr_valid_ex;
  assign dbreak_ex                   = de_ex_pipe_dbreak_ex & instr_valid_ex;
  assign immediate_ex                = de_ex_pipe_immediate_ex;
  assign curr_instr_enc_ex           = de_ex_pipe_curr_instr_enc_ex;
  assign curr_pc_ex                  = de_ex_pipe_curr_pc_ex;
  
  assign flush_ex                    = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr; 
    
  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_rs1_ex
    // gpr forwarding paths 
    // Do not forward if the rd/wr is x0 as the value from the read would always be 0, but if the exu/csr result is forwarded, then this may be non-0 
    
   // gpr rs1
    if (l_core_cfg_exu_fwd)
    begin : gen_rs1_exu_fwd
   
      assign gpr_rs1_fwd_exu   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
      assign gpr_rs1_stall_exu = 1'b0; 
    end
    else begin : gen_rs1_exu_stall
      assign gpr_rs1_fwd_exu   = 1'b0;
      assign gpr_rs1_stall_exu = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
    end
    //endgenerate                           
                              
    // Optionally forward CSR result as it may arrive late, and contributes to a long path, particularly from debugger. If forwarding is disabled, hazard will cause stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0                           

    if (l_core_cfg_csr_fwd)
    begin : gen_rs1_csr_fwd                            
      assign gpr_rs1_fwd_csr   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                                  
      assign gpr_rs1_stall_csr = 1'b0;
      
    end
    else begin : gen_rs1_csr_stall
    
      assign gpr_rs1_fwd_csr   = 1'b0;
      assign gpr_rs1_stall_csr =  ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);
    end
    //endgenerate

   
    // Optionally forward LSU load result as it may arrive late in the retr cycle. If forwarding is disabled, hazard will cause LSU stall instead.
    // Don't need to stall if the rd is from x0 as this will always be 0
    if (l_core_cfg_lsu_fwd)
    begin : gen_rs1_lsu_fwd
    
      assign gpr_rs1_fwd_lsu    = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
      assign gpr_rs1_stall_lsu  = 1'b0;
            
    end
    else begin : gen_rs1_lsu_stall
    
      assign gpr_rs1_fwd_lsu    = 1'b0;
      assign gpr_rs1_stall_lsu  = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs1_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs1_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs1_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu);                                 
   
    end
    //endgenerate
   
    
                           
                                             
   always @*
   begin
      unique case({gpr_rs1_fwd_exu,gpr_rs1_fwd_csr,gpr_rs1_fwd_lsu})
        3'b000 : // No forwarding
        begin
          gpr_rs1_rd_data_fwd_ex        = gpr_rs1_rd_data_ex;      
          gpr_rs1_rd_data_fwd_valid_ex  = gpr_rs1_rd_data_valid_ex;
        end
        3'b001 : // LSU forward
        begin
          gpr_rs1_rd_data_fwd_ex        = lsu_resp_rd_data_fwd;
          gpr_rs1_rd_data_fwd_valid_ex  = lsu_resp_valid_fwd;
        end
        3'b010 : // CSR forward
        begin
          gpr_rs1_rd_data_fwd_ex        = sw_csr_rd_data_retr;      
          gpr_rs1_rd_data_fwd_valid_ex  = sw_csr_rd_data_valid_retr;
        end
        3'b100 : // EXU forward
        begin
          gpr_rs1_rd_data_fwd_ex        = exu_result_retr;      
          gpr_rs1_rd_data_fwd_valid_ex  = exu_result_valid_retr;
        end
        default : // illegal
        begin
          gpr_rs1_rd_data_fwd_ex        = {L_XLEN{1'b0}};      
          gpr_rs1_rd_data_fwd_valid_ex  = 1'b1;
        end
      endcase
    end
    
    assign gpr_rs1_stall_ex = gpr_rs1_stall_lsu | gpr_rs1_stall_csr | gpr_rs1_stall_exu;
    
  end
  else begin : ngen_read_gpr_rs1_ex
  
  // read GPRs in DE stage and pipeline
  
  
    assign gpr_rs1_rd_data_fwd_ex        = gpr_rs1_rd_data_ex;      
    assign gpr_rs1_rd_data_fwd_valid_ex  = gpr_rs1_rd_data_valid_ex;
    assign gpr_rs1_stall_ex              = 1'b0;
    
  end
  endgenerate
  
 
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_read_gpr_rs2_ex
                               
    // gpr rs2
    if (l_core_cfg_exu_fwd)
    begin : gen_rs2_exu_fwd
   
      assign gpr_rs2_fwd_exu   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
      assign gpr_rs2_stall_exu = 1'b0; 
    end
    else begin : gen_rs2_exu_stall
      assign gpr_rs2_fwd_exu   = 1'b0;
      assign gpr_rs2_stall_exu = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu);
    end
    //endgenerate 
                                                     

    if (l_core_cfg_csr_fwd)
    begin : gen_rs2_csr_fwd                            
      assign gpr_rs2_fwd_csr   = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                  (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);                                  
      assign gpr_rs2_stall_csr = 1'b0;
      
    end
    else begin : gen_rs2_csr_stall
    
      assign gpr_rs2_fwd_csr   = 1'b0;
      assign gpr_rs2_stall_csr =  ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr);
    end
    //endgenerate                            
                              
    if (l_core_cfg_lsu_fwd)
    begin : gen_rs2_lsu_fwd
    
      assign gpr_rs2_fwd_lsu    = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
      assign gpr_rs2_stall_lsu  = 1'b0;
      
    end
    else begin : gen_rs2_lsu_stall
    
      assign gpr_rs2_fwd_lsu    = 1'b0;
      assign gpr_rs2_stall_lsu  = ((stage_state_ex == expipe_stage_state_busy) & de_ex_pipe_gpr_rs2_rd_valid_ex) & 
                                   (instr_valid_retr & gpr_wr_en_retr) & (gpr_rs2_rd_sel_ex == gpr_wr_sel_retr) & (gpr_rs2_rd_sel_ex != 5'b0) & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu); 
   
    end
    //endgenerate                          
                                                
    always @*
    begin
      unique case({gpr_rs2_fwd_exu,gpr_rs2_fwd_csr,gpr_rs2_fwd_lsu})
        3'b000 : // No forwarding
        begin
          gpr_rs2_rd_data_fwd_ex        = gpr_rs2_rd_data_ex;      
          gpr_rs2_rd_data_fwd_valid_ex  = gpr_rs2_rd_data_valid_ex;
        end
        3'b001 : // LSU forward
        begin
          gpr_rs2_rd_data_fwd_ex        = lsu_resp_rd_data_fwd;
          gpr_rs2_rd_data_fwd_valid_ex  = lsu_resp_valid_fwd;  
        end
        3'b010 : // CSR forward
        begin
          gpr_rs2_rd_data_fwd_ex        = sw_csr_rd_data_retr;      
          gpr_rs2_rd_data_fwd_valid_ex  = sw_csr_rd_data_valid_retr;
        end
        3'b100 : // EXU forward
        begin
          gpr_rs2_rd_data_fwd_ex        = exu_result_retr;      
          gpr_rs2_rd_data_fwd_valid_ex  = exu_result_valid_retr;
        end
        default : // illegal
        begin
          gpr_rs2_rd_data_fwd_ex        = {L_XLEN{1'b0}};      
          gpr_rs2_rd_data_fwd_valid_ex  = 1'b1;
        end
      endcase
    end    
    
    assign gpr_rs2_stall_ex = gpr_rs2_stall_lsu | gpr_rs2_stall_csr | gpr_rs2_stall_exu;
    
  end
  else begin : ngen_read_gpr_rs2_ex
  
  // read GPRs in DE stage and pipeline
    assign gpr_rs2_rd_data_fwd_ex        = gpr_rs2_rd_data_ex;      
    assign gpr_rs2_rd_data_fwd_valid_ex  = gpr_rs2_rd_data_valid_ex;
    assign gpr_rs2_stall_ex              = 1'b0;
    
  end
  endgenerate                      

  
  // PC is from the current fetched instruction in the pipeline, so no hazard possible, branches will cause flush to ensure correct PC is aligned in EX stage
  
  assign trap_cause_hzd_ex = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand0_mux_sel_ex == bcu_operand0_trap_cause)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mcause))); 
    
  assign epc_hzd_ex        = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand1_mux_sel_ex == bcu_operand1_epc)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mepc)));   
                             
  assign trap_vec_hzd_ex   = ((stage_state_ex == expipe_stage_state_busy) & (de_ex_pipe_bcu_op_sel_ex == bcu_op_add) & 
                              (de_ex_pipe_bcu_operand1_mux_sel_ex == bcu_operand1_exvec)) & 
                             ((instr_valid_retr & (sw_csr_wr_op_retr != csr_alu_wr_op_none) & (sw_csr_addr_retr == l_core_csr_addr_mtvec)));                                                

  // resetvec is static in core, so no hazard on resetvec as an operand                              
                                                                                                 
  
  //--------------------------------------------------------
  // GPRs
  //--------------------------------------------------------  
  

// gpr controls //
// GPR writes always occur at the end of the retr stage
// core reads occur in a single cycle and continue as needed (in a RAM based implementation, the RAM must have 
// 1-write, 2 read ports). For multicycle operations, the GPR read of operands must occur at the same time and 
// persist throughout the request phase of the operation.
 
  

  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
      de_ex_pipe_gpr_wr_en_ex             <= gpr_wr_en_de;
      de_ex_pipe_gpr_wr_sel_ex            <= gpr_wr_sel_de; 
      de_ex_pipe_gpr_wr_mux_sel_ex        <= gpr_wr_mux_sel_de;  
    end    
  end

  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_gpr_ex_attbs_rd_ex
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex | gpr_rd_rs1_completing_ex)
        de_ex_pipe_gpr_rs1_rd_valid_ex  <= update_ctrl_attbs_ex ?  gpr_rs1_rd_valid_de : 1'b0;       
    end
    
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)       
        de_ex_pipe_gpr_rs1_rd_sel_ex    <= gpr_rs1_rd_sel_de;     
    end
    
    if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
    begin : gen_debug_gpr_rd_sel_no_pipeline
    
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex)
          de_ex_pipe_gpr_rs2_rd_valid_ex <= update_ctrl_attbs_ex ?  gpr_rs2_rd_valid_de : 1'b0;    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex)
          de_ex_pipe_gpr_rs2_rd_sel_ex   <= gpr_rs2_rd_sel_de;      
      end
      
    end
    else begin : gen_debug_gpr_rd_sel_pipeline
    
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_valid_ex <= debug_mode_retr ? debug_gpr_req_rd_en : (update_ctrl_attbs_ex ?  gpr_rs2_rd_valid_de : 1'b0);    
      end
  
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_sel_ex   <= debug_mode_retr ? debug_gpr_req_addr : gpr_rs2_rd_sel_de;      
      end
      
    end
    // endgenerate gen_debug_gpr_rd_sel_pipeline
    
    assign de_ex_pipe_gpr_rs1_rd_data_ex       = gpr_rs1_rd_data_sig;  
    assign de_ex_pipe_gpr_rs2_rd_data_ex       = gpr_rs2_rd_data_sig; 
    assign de_ex_pipe_gpr_rs1_rd_data_valid_ex = gpr_rs1_rd_data_valid_sig;
    assign de_ex_pipe_gpr_rs2_rd_data_valid_ex = gpr_rs2_rd_data_valid_sig;
  
  end 
  else begin : gen_gpr_ex_attbs_rd_de
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_ex)
      begin            
        de_ex_pipe_gpr_rs1_rd_data_ex       <= gpr_rs1_rd_data_fwd_de;  
        de_ex_pipe_gpr_rs2_rd_data_ex       <= gpr_rs2_rd_data_fwd_de;  
        de_ex_pipe_gpr_rs1_rd_data_valid_ex <= gpr_rs1_rd_data_fwd_valid_de;
        de_ex_pipe_gpr_rs2_rd_data_valid_ex <= gpr_rs2_rd_data_fwd_valid_de;
      end    
    end
    
    assign de_ex_pipe_gpr_rs1_rd_valid_ex = 1'b0;
    assign de_ex_pipe_gpr_rs1_rd_sel_ex = 5'd0;
    
    // only need register for debug gpr read control pipelining select, so only implement if required
    if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
    begin : gen_debug_gpr_rd_sel_no_pipeline_rdde
    
      assign de_ex_pipe_gpr_rs2_rd_valid_ex = 1'b0;
      assign de_ex_pipe_gpr_rs2_rd_sel_ex = 5'd0;
      
    end
    else begin : gen_debug_gpr_rd_sel_pipeline_rdde
      
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex | gpr_rd_rs2_completing_ex | debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_valid_ex      <= debug_mode_retr ? debug_gpr_req_rd_en : 1'b0;       
      end
      
      always @(posedge clk)
      begin
        if(update_ctrl_attbs_ex |  debug_mode_retr)
          de_ex_pipe_gpr_rs2_rd_sel_ex        <= debug_mode_retr ? debug_gpr_req_addr : 5'd0;  
      end

    end
    // endgenerate gen_debug_gpr_rd_sel_pipeline_rdd
    
    
  end
  endgenerate

  assign gpr_wr_en_ex                     = de_ex_pipe_gpr_wr_en_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_wr_sel_ex                    = de_ex_pipe_gpr_wr_sel_ex;
  assign gpr_wr_mux_sel_ex                = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_gpr_wr_mux_sel_ex : gpr_wr_mux_sel_none;
  assign gpr_rs1_rd_valid_ex              = de_ex_pipe_gpr_rs1_rd_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_rs1_rd_sel_ex                = de_ex_pipe_gpr_rs1_rd_sel_ex;
  assign gpr_rs2_rd_valid_ex              = de_ex_pipe_gpr_rs2_rd_valid_ex & (debug_mode_retr | (instr_valid_ex & ~instr_inhibit_ex));
  assign gpr_rs2_rd_sel_ex                = de_ex_pipe_gpr_rs2_rd_sel_ex;
  assign gpr_rs1_rd_data_ex               = de_ex_pipe_gpr_rs1_rd_data_ex;      
  assign gpr_rs2_rd_data_ex               = de_ex_pipe_gpr_rs2_rd_data_ex;      
  assign gpr_rs1_rd_data_valid_ex         = de_ex_pipe_gpr_rs1_rd_data_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
  assign gpr_rs2_rd_data_valid_ex         = de_ex_pipe_gpr_rs2_rd_data_valid_ex & instr_valid_ex & ~instr_inhibit_ex  & ~debug_mode_retr;
  
  // write completes in ex stage when gpr write data (alu result or csr read data) valid, or lsu ld/fence accepted and can be accepted by retr stage

  assign gpr_rd_rs1_completing_ex         = (((alu_op_sel_ex == exu_alu_op_none) | (operand0_mux_sel_ex != exu_op0_rs1) | ex_retr_exu_res_accept_retr) &              
                                             ((shifter_unit_op_sel_ex == exu_shifter_op_none) | (shifter_unit_operand_sel_ex != shifter_operand_rs1) | ex_retr_exu_res_accept_retr) &       
                                             ((lsu_op_ex == lsu_op_none) | lsu_op_complete_ex) &
                                             ((bcu_op_sel_ex == bcu_op_none) | bcu_op_complete_ex)) | instr_inhibit_ex; 
  assign gpr_rd_rs2_completing_ex         = (((alu_op_sel_ex == exu_alu_op_none) | (operand1_mux_sel_ex != exu_op1_rs2) | ex_retr_exu_res_accept_retr) &              
                                             ((shifter_unit_op_sel_ex == exu_shifter_op_none) | ((shifter_unit_operand_sel_ex != shifter_operand_rs2) & (shifter_unit_places_sel_ex != shifter_places_operand_rs2))| ex_retr_exu_res_accept_retr) &       
                                             ((lsu_op_ex == lsu_op_none) | lsu_op_complete_ex) &
                                             ((bcu_op_sel_ex == bcu_op_none) | bcu_op_complete_ex)) | instr_inhibit_ex;
  assign gpr_rd_rs1_complete_ex           = (~gpr_rs1_rd_valid_ex) | gpr_rd_rs1_completing_ex;
  assign gpr_rd_rs2_complete_ex           = (~gpr_rs2_rd_valid_ex) | gpr_rd_rs2_completing_ex;


  //--------------------------------------------------------
  // CSRs
  //--------------------------------------------------------  

  // csr controls  //  
  // All CSR functionality occurs in RETR stage, so just operation pipelining here

  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin
      de_ex_pipe_sw_csr_wr_op_ex     <= sw_csr_wr_op_de; 
      de_ex_pipe_sw_csr_addr_ex      <= sw_csr_addr_de; 
      de_ex_pipe_sw_csr_rd_op_ex     <= sw_csr_rd_op_de;
    end    
  end  
  
  assign sw_csr_addr_ex              = de_ex_pipe_sw_csr_addr_ex;
  assign sw_csr_wr_op_ex             = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_sw_csr_wr_op_ex : csr_alu_wr_op_none;
  assign sw_csr_rd_op_ex             = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_sw_csr_rd_op_ex : csr_alu_rd_op_none;
    
  

  //--------------------------------------------------------
  // Execution unit
  //--------------------------------------------------------  
  
  // exu controls //  
  // core supports one exu request in flight in ex stage until the operation is accepted by the retr stage or lsu 
  // (no pipelined execution of arithmetic operations. though does support multi-cycle execution)
  // EXU requests persists until result is accepted by:
  //  - retr stage pipeline register accepted for all CSR ops
  //  - LSU requested accepted without error for loads and fence operations (address required for MTVAL if an exception) 
  //  - LSU requested accepted without error for stores
  //  - LSU accepted with error for all LSU ops and retr stage pipeline register accepted
  //  - retr stage pipeline register accepted for all ALU and shift ops
  //  - branch accepted for all taken branch ops
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | alu_op_completing_ex)
    begin          
      de_ex_pipe_alu_op_sel_ex               <= update_ctrl_attbs_ex ? alu_op_sel_de : exu_alu_op_none;              
    end    
  end
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | shift_op_completing_ex)
    begin                   
      de_ex_pipe_shifter_unit_op_sel_ex      <= update_ctrl_attbs_ex ? shifter_unit_op_sel_de : exu_shifter_op_none;     
    end    
  end
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin       
      de_ex_pipe_operand0_mux_sel_ex         <= operand0_mux_sel_de;   
      de_ex_pipe_operand1_mux_sel_ex         <= operand1_mux_sel_de;   
      de_ex_pipe_shifter_unit_places_sel_ex  <= shifter_unit_places_sel_de;
      de_ex_pipe_shifter_unit_operand_sel_ex <= shifter_unit_operand_sel_de;      
      de_ex_pipe_exu_result_mux_sel_ex       <= exu_result_mux_sel_de;      
    end    
  end
  
  assign operand0_mux_sel_ex         = de_ex_pipe_operand0_mux_sel_ex;
  assign operand1_mux_sel_ex         = de_ex_pipe_operand1_mux_sel_ex;
  assign alu_op_sel_ex               = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_alu_op_sel_ex : exu_alu_op_none;
  assign shifter_unit_op_sel_ex      = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_shifter_unit_op_sel_ex : exu_shifter_op_none;
  assign shifter_unit_places_sel_ex  = de_ex_pipe_shifter_unit_places_sel_ex;
  assign shifter_unit_operand_sel_ex = de_ex_pipe_shifter_unit_operand_sel_ex;
  assign exu_result_mux_sel_ex       = de_ex_pipe_exu_result_mux_sel_ex;
    
  assign alu_op_completing_ex        = (ex_retr_exu_res_accept_retr &                
                                        ((branch_cond_ex == branch_cond_compare_true) ? bcu_op_complete_ex : 1'b1)) | instr_inhibit_ex;           
  assign alu_op_complete_ex          = (alu_op_sel_ex == exu_alu_op_none)  | alu_op_completing_ex;

  assign shift_op_completing_ex      = ((lsu_op_ex != lsu_op_none) ? lsu_op_complete_ex : ex_retr_exu_res_accept_retr) |  // shift nly needed for store, but no shift op for any
                                       instr_inhibit_ex;                                             // other LSU ops started anyway so simpler to decode any lsu op
                                       
  assign shift_op_complete_ex        = (shifter_unit_op_sel_ex == exu_shifter_op_none) | shift_op_completing_ex;  
  
  // exu may be performing a multicycle operation when a trap is taken, abort the operation and replay (if required) after trap return
  assign exu_op_abort_ex             = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr ;
  
  miv_rv32_exu 
  #(
   .l_core_cfg_hw_multiply_divide(l_core_cfg_hw_multiply_divide),
   .l_core_cfg_hw_macc_multiplier(l_core_cfg_hw_macc_multiplier),
   .l_core_cfg_hw_debug          (l_core_cfg_hw_debug)
   ) 
  u_exu_0
  (
    .clk                            (clk                           ),
    .resetn                         (resetn                        ),
    // controls
    .exu_op_abort                   (exu_op_abort_ex               ), 
    .debug_mode                     (debug_mode_retr               ), 
//    .exu_op_valid
    .exu_op_ready                   (exu_op_ready_ex               ),  // Not currently used 
    .alu_operand0_mux_sel           (operand0_mux_sel_ex           ),
    .alu_operand1_mux_sel           (operand1_mux_sel_ex           ),
    .alu_op_sel                     (alu_op_sel_ex                 ),
    .shifter_unit_op_sel            (shifter_unit_op_sel_ex        ),
    .shifter_unit_places_sel        (shifter_unit_places_sel_ex    ),
    .shifter_operand_sel            (shifter_unit_operand_sel_ex   ),
    .exu_result_mux_sel             (exu_result_mux_sel_ex         ),
    //operands
    .exu_operand_gpr_rs1            (gpr_rs1_rd_data_fwd_ex        ),
    .exu_operand_gpr_rs1_valid      (gpr_rs1_rd_data_fwd_valid_ex  ),
    .exu_operand_gpr_rs2            (gpr_rs2_rd_data_fwd_ex        ),
    .exu_operand_gpr_rs2_valid      (gpr_rs2_rd_data_fwd_valid_ex  ),
    .exu_operand_immediate          (immediate_ex                  ),
    .exu_operand_immediate_valid    (instr_valid_ex                ), 
    .exu_operand_pc                 (curr_pc_ex                    ),
    .exu_operand_pc_valid           (instr_valid_ex                ),
    .acu_result                     (bcu_result_ex                 ),
    .acu_result_valid               (bcu_result_valid_ex           ),
    .debug_wr_data                  (debug_csr_gpr_req_wr_data     ),
    .debug_wr_data_valid            (1'b1                          ),
    // result
    .exu_result                     (exu_result_ex                 ),
    .exu_result_valid               (exu_result_valid_ex           ),
    .exu_result_ready               (1'b1                          ),  
    .exu_result_flags               (exu_result_flags_ex           ),
    .lsu_align_result               (align_result_ex               ),
    .lsu_align_result_valid         (align_result_valid_ex         ),
    .lsu_align_result_ready         (1'b1                          ),  
    .update_result_reg              (exu_update_result_reg         ),
    .exu_result_reg                 (ex_retr_pipe_exu_result_retr  ),
    .exu_result_reg_valid           (ex_retr_pipe_exu_result_valid_retr)
  );
  
  //--------------------------------------------------------
  // Branch computation unit
  //--------------------------------------------------------  
  // bcu controls //  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | bcu_op_completing_ex)
    begin      
      de_ex_pipe_bcu_op_sel_ex            <= update_ctrl_attbs_ex ? bcu_op_sel_de : bcu_op_none;           
      de_ex_pipe_branch_cond_ex           <= update_ctrl_attbs_ex ? branch_cond_de : branch_cond_none;         
    end    
  end  
  
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin      
      de_ex_pipe_bcu_operand0_mux_sel_ex  <= bcu_operand0_mux_sel_de;
      de_ex_pipe_bcu_operand1_mux_sel_ex  <= bcu_operand1_mux_sel_de;          
    end    
  end  
  
  assign bcu_operand0_mux_sel_ex      = de_ex_pipe_bcu_operand0_mux_sel_ex;
  assign bcu_operand1_mux_sel_ex      = de_ex_pipe_bcu_operand1_mux_sel_ex;
  assign bcu_op_sel_ex                = instr_valid_ex ? de_ex_pipe_bcu_op_sel_ex : bcu_op_none;
  assign branch_cond_ex               = instr_valid_ex ? de_ex_pipe_branch_cond_ex : branch_cond_none;                                
  assign bcu_op_complete_ex           = (bcu_op_sel_ex == bcu_op_none) | bcu_op_completing_ex; 
  assign bcu_operand_trap_cause_ex    = {25'd0,csr_priv_cause_excpt_code_retr,2'b00};
  assign bcu_operand_trap_vec_ex      = csr_priv_mtvec_excpt_vec_retr; 
  
    
  // test branch condition
  //----------------------
  
  always @*
  begin
    unique case(branch_cond_ex)
      branch_cond_none : 
      begin 
        branch_taken_ex       = 1'b0;
        bcu_op_completing_ex  = (instr_is_lsu_ldstr_ex  ? (lsu_op_complete_ex & ex_retr_exu_res_accept_retr) : 1'b0) | instr_inhibit_ex;
      end     
      branch_cond_always : 
      begin
        branch_taken_ex       = bcu_result_valid_ex & instr_valid_ex & ~instr_inhibit_ex;
        bcu_op_completing_ex  = (ifu_expipe_req_branch_excpt_req_ready & bcu_result_valid_ex) | 
                                    instr_inhibit_ex; 
      end
      branch_cond_compare_true : 
      begin
        branch_taken_ex       = exu_result_flags_ex.cmp_cond & instr_valid_ex & exu_result_valid_ex & ~instr_inhibit_ex;
        bcu_op_completing_ex  = ((~exu_result_flags_ex.cmp_cond | (ifu_expipe_req_branch_excpt_req_ready & bcu_result_valid_ex)) & exu_result_valid_ex) | 
                                    instr_inhibit_ex; 
      end
      default :      
      begin 
        branch_taken_ex       = 1'b0;
        bcu_op_completing_ex  = 1'b0;
      end
    endcase
  end
  
    
  miv_rv32_bcu
  u_bcu_0
  (
    .clk                            (clk                           ),
    .resetn                         (resetn                        ),
    // controls
    .bcu_operand0_mux_sel           (bcu_operand0_mux_sel_ex       ),
    .bcu_operand1_mux_sel           (bcu_operand1_mux_sel_ex       ),
    .bcu_op_sel                     (bcu_op_sel_ex                 ),
    .bcu_op_ready                   (                              ),  // Currently not used
    //operands
    .bcu_operand_pc                 (curr_pc_ex                    ),
    .bcu_operand_pc_valid           (instr_valid_ex                ),        
    .bcu_operand_gpr_rs1            (gpr_rs1_rd_data_fwd_ex        ), 
    .bcu_operand_gpr_rs1_valid      (gpr_rs1_rd_data_fwd_valid_ex  ),    
    .bcu_operand_trap_cause         (bcu_operand_trap_cause_ex     ),
    .bcu_operand_trap_cause_valid   (~trap_cause_hzd_ex            ),
    .bcu_operand_immediate          (immediate_ex                  ),
    .bcu_operand_immediate_valid    (instr_valid_ex                ), 
    .bcu_operand_epc                (csr_priv_mtvec_epc_retr       ), 
    .bcu_operand_epc_valid          (~epc_hzd_ex                   ),       
    .bcu_operand_dpc                (csr_priv_dpc_retr             ),    
    .bcu_operand_dpc_valid          (1'b1                          ),           
    .bcu_operand_trap_vec           (bcu_operand_trap_vec_ex       ), 
    .bcu_operand_trap_vec_valid     (~trap_vec_hzd_ex              ),  
    .bcu_operand_reset_vec          (l_core_reset_vector      ),
    .bcu_operand_reset_vec_valid    (1'b1                          ),
    // result
    .bcu_result                     (bcu_result_ex                 ),
    .bcu_result_valid               (bcu_result_valid_ex           ),
    .bcu_result_ready               (1'b1                          )  
  );
  
  // BCU also generate load-store address
  assign lsu_addr_result_ex       = bcu_result_ex;
  assign lsu_addr_result_valid_ex = bcu_result_valid_ex;

  //--------------------------------------------------------
  // LSU Interface
  //--------------------------------------------------------    
  // LSU is external to the pipeline to simplify independent formal verification and make LSU interchangeable for more capability
  
// lsu controls 
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex | lsu_op_completing_ex)
    begin    
      de_ex_pipe_lsu_op_ex    <= update_ctrl_attbs_ex ? lsu_op_de : lsu_op_none;    
    end    
  end  
  
  // required to pass the lsu op to the retr stage. In ex stage it may be set to none (to prevent repeated requests) before being
  // accepted by retr stage so use a seperate version (lsu_op_ex_pipe) so retr stage knows to retire an lsu op.
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_ex)
    begin    
      lsu_op_ex_pipe_reg      <= lsu_op_de;   
    end    
  end  
  
  assign lsu_op_ex_pipe         = (instr_valid_ex & ~instr_inhibit_ex) ? lsu_op_ex_pipe_reg : lsu_op_none;
  assign lsu_op_ex              = (instr_valid_ex & ~instr_inhibit_ex) ? de_ex_pipe_lsu_op_ex : lsu_op_none;
  
  assign instr_is_lsu_ldstr_ex  = (lsu_op_ex_pipe == lsu_op_ld_byte_s) |
                                  (lsu_op_ex_pipe == lsu_op_ld_hword_s) |
                                  (lsu_op_ex_pipe == lsu_op_ld_word) |
                                  (lsu_op_ex_pipe == lsu_op_ld_byte_u) |
                                  (lsu_op_ex_pipe == lsu_op_ld_hword_u) |
                                  (lsu_op_ex_pipe == lsu_op_str_byte) |
                                  (lsu_op_ex_pipe == lsu_op_str_word) |
                                  (lsu_op_ex_pipe == lsu_op_str_hword);
                                  
  assign instr_is_lsu_ldstr_reg_ex  = (lsu_op_ex_pipe_reg == lsu_op_ld_byte_s) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_hword_s) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_word) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_byte_u) |
                                      (lsu_op_ex_pipe_reg == lsu_op_ld_hword_u) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_byte) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_word) |
                                      (lsu_op_ex_pipe_reg == lsu_op_str_hword);                              
  
  // lsu op complete in ex stage when request accepted by lsu
  // don't inhibit the request with lsu_flush because may arrive late, instead indicate to lsu to drop the resulting response if already accepted.
  // Also need to prevent store operations (and loads, fences, but the ywill be dropped silently anyhow in retr stage) if there is an exception going to occur
  // on the retiring instruction
  // Exceptions caused by the LSU (access faults) will be dealt with in the LSU and the request suppressed there.
  // Interrupts are imprecise so though they are taken in the retr stage, it does not matter architecturally if a store request has already been made in
  // the EX stage, however if it is made, the interrupt must be taken on the instruction following the store as that is the instruction that is interrupted, not the store.
  // If suppressing the request, need to tell retr stage not to expect a response - this should happen anyhow, since trap_taken_retr will be asserted.
  
  assign lsu_flush              = flush_ex;
                                  
  assign lsu_op_completing_ex   = (lsu_req_ready & lsu_req_valid) | lsu_flush | instr_inhibit_ex;
  assign lsu_op_complete_ex     = (lsu_op_ex == lsu_op_none) | lsu_op_completing_ex;
  
  assign lsu_op_str_ex = (lsu_op_ex_pipe == lsu_op_str_byte) | 
                         (lsu_op_ex_pipe == lsu_op_str_word) |
                         (lsu_op_ex_pipe == lsu_op_str_hword);                                  
  
  generate if(l_core_cfg_spec_load == 0)
  begin : gen_no_spec_after_load
    assign lsu_req_stall_ex  = lsu_ld_op_os |
                               lsu_fence_op_os;
  end else
  begin : gen_spec_load_fence_after_load
    assign lsu_req_stall_ex  = (lsu_ld_op_os & ~lsu_op_str_ex) |
                               lsu_fence_op_os;    
  end
  endgenerate                  
    
  assign lsu_req_valid          =  (lsu_op_ex != lsu_op_none) &
                                   (lsu_addr_result_valid_ex | fence_i_ex | fence_ex) &
                                   ((~lsu_op_str_ex) | align_result_valid_ex) &
                                    ~instr_inhibit_ex &
                                    ~lsu_req_stall_ex &
                                    ~lsu_req_stall_retr; 

  assign lsu_req_addr           = lsu_addr_result_ex;
  assign lsu_req_addr_valid     = lsu_addr_result_valid_ex;
  assign lsu_req_wr_data        = align_result_ex;
  assign lsu_req_wr_data_valid  = align_result_valid_ex;
  assign lsu_req_op             = lsu_op_ex; 
  
  // for a load-store-fence the alu op must be none
  // for a load-store-fence the bcu op must be add
  // for a load-store-fence the branch condition must be none
  // for a fence.i the branch condition must be always
  // fora conditional branch the bcu_op must be add
  // for a load or fence the shift op must be none
  // for a store the shift op must be shift left

  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  // Retire stage (RETR)
  //++++++++++++++++++++++++++++++++
  //++++++++++++++++++++++++++++++++
  
  // The retire stage writes back the result from exu/lsu to memory/gprs/csrs as required
  //
  // Exceptions and interrupts will be evaluated/taken in the retr stage
  // If a trap is taken in the retr stage, the decoder will be forced to decode the "trap" operation (a branch to the exception vector)
  // in the following instruction. The CSRs will be updated in the current ex_retr cycle with the trap information (mcause, mepc) since the 
  // following branch-to-trap-vector computation can only be premepted by another exception which would also need to update the csrs and would also
  // force a following branch-to-trap-vector


  //---------------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------------- 
  
  assign instr_req_retr   = instr_valid_ex & instr_completing_ex & ~flush_retr & ~stall_retr; //
  assign exu_res_req_retr = ((exu_result_mux_sel_ex == exu_alu_result_mux_acu) ? bcu_result_valid_ex : exu_result_valid_ex) & ~stall_retr;
  
  always @*
  begin
    case(stage_state_retr)
      expipe_stage_state_ready : 
      begin
        next_stage_state_retr       = instr_req_retr ? expipe_stage_state_busy : expipe_stage_state_ready;
        instr_accepted_retr         = instr_req_retr;
        ex_retr_exu_res_accept_retr = exu_res_req_retr;
        instr_valid_retr            = 1'b0;
        stage_ready_retr            = ~stall_retr;
      end
    
      expipe_stage_state_busy : 
      begin
        next_stage_state_retr       = instr_req_retr ? expipe_stage_state_busy : instr_completing_retr ? expipe_stage_state_ready : stage_state_retr;
        instr_accepted_retr         = instr_req_retr & instr_completing_retr;
        ex_retr_exu_res_accept_retr = exu_res_req_retr & instr_completing_retr;
        instr_valid_retr            = 1'b1;
        stage_ready_retr            = instr_completing_retr & ~stall_retr;
      end
    
      default :
        begin
        next_stage_state_retr       = expipe_stage_state_ready;
        instr_accepted_retr         = 1'b0;
        ex_retr_exu_res_accept_retr = 1'b0;
        instr_valid_retr            = 1'b0;
        stage_ready_retr            = 1'b0;
      end
    endcase
  end
  

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      stage_state_retr  <= expipe_stage_state_ready;
    else
      stage_state_retr  <= next_stage_state_retr;     
  end    
  
  assign instr_completing_retr = (gpr_wr_complete_retr & 
                                  csr_complete_retr &
                                  lsu_op_complete_retr) | debug_enter_retr;                                 
                                 
  assign flush_retr            = trap_taken_retr | soft_reset_taken_retr | debug_enter_retr | debug_mode_retr;  
  
  assign stall_retr            = wfi_waiting_retr |
                                 debug_mode_retr;                             
  
  assign update_ctrl_attbs_retr = instr_accepted_retr;
   
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_retr)
    begin
    // pipeline controls
      ex_retr_pipe_implicit_pseudo_instr_retr    <= implicit_pseudo_instr_ex;
      ex_retr_pipe_fence_i_retr                  <= fence_i_ex;
      ex_retr_pipe_wfi_retr                      <= wfi_ex;  
      ex_retr_pipe_i_access_fault_retr           <= i_access_fault_ex;           
      ex_retr_pipe_i_access_mem_error_retr       <= i_access_mem_error_ex;       
      ex_retr_pipe_i_access_parity_error_retr    <= i_access_parity_error_ex;    
      ex_retr_pipe_i_access_misalign_error_retr  <= i_access_misalign_error_ex;    
      ex_retr_pipe_illegal_instr_retr            <= illegal_instr_ex; 
      ex_retr_pipe_m_env_call_retr               <= m_env_call_ex; 
      ex_retr_pipe_trap_ret_retr                 <= trap_ret_ex; 
      ex_retr_pipe_dbreak_retr                   <= dbreak_ex;       
      ex_retr_pipe_curr_instr_enc_retr           <= curr_instr_enc_ex; 
    end    
  end
  
  generate if(l_core_cfg_num_triggers > 0)
  begin : gen_trig_pipe_reg_ex_retr
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
      begin
        ex_retr_pipe_trigger_retr <= trigger_ex;
      end
    end
    
    assign trigger_retr = ex_retr_pipe_trigger_retr & {l_core_cfg_trigger_bus_width{instr_valid_retr}};
    
  end
  else begin : ngen_trig_pipe_reg_ex_retr
  
    assign trigger_retr = {l_core_cfg_trigger_bus_width{1'b0}};
    
  end
  endgenerate
  
  generate if(l_core_cfg_hw_debug)
  begin : gen_pipe_debug_enter_req_ex_retr
     
    logic ex_retr_debug_enter_req_retr;
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
        ex_retr_debug_enter_req_retr <= debug_enter_req_ex;
    end
  
    always @(posedge clk)
    begin
      //if(soft_reset_taken_unmasked_retr)
      //  ex_retr_pipe_curr_pc_retr <= l_core_reset_vector;
      //else 
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_curr_pc_retr <= ((branch_cond_ex == branch_cond_always) & debug_enter_req_ex & implicit_pseudo_instr_ex) ? {bcu_result_ex[I_ADDR_WIDTH-1:1],1'b0} : curr_pc_ex;
    end
    
    assign debug_enter_req_retr   = ex_retr_debug_enter_req_retr & instr_valid_retr;
    
  end
  else begin : ngen_pipe_debug_enter_req_ex_retr
  
    assign debug_enter_req_retr   =  1'b0;
    
    always @(posedge clk)
    begin
      //if(soft_reset_taken_unmasked_retr)
      //  ex_retr_pipe_curr_pc_retr <= l_core_reset_vector;
      //else 
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_curr_pc_retr <= curr_pc_ex;  
    end 
    
  end
  endgenerate

  // Fence.i handling. 
  // Fence.i is implemented as a fence followed by a branch to the following instruction.
  // The branch is issued in the ex stage, but held off until the fence operation completes in the retr stage
  
  assign ifu_expipe_req_fenci_proceed  = fence_i_retr & lsu_op_completing_retr & ~debug_mode_retire_mask_retr;
                                          
  assign exu_result_retr               = ex_retr_pipe_exu_result_retr;          
  assign exu_result_valid_retr         = ex_retr_pipe_exu_result_valid_retr & (instr_valid_retr | debug_mode_retr);   
                                                
  assign implicit_pseudo_instr_retr    = ex_retr_pipe_implicit_pseudo_instr_retr;
  assign fence_i_retr                  = ex_retr_pipe_fence_i_retr & instr_valid_retr;
  assign wfi_retr                      = ex_retr_pipe_wfi_retr & instr_valid_retr & ~debug_mode_retire_mask_retr;
  assign i_access_fault_retr           = ex_retr_pipe_i_access_fault_retr & instr_valid_retr;
  assign i_access_mem_error_retr       = ex_retr_pipe_i_access_mem_error_retr & instr_valid_retr;
  assign i_access_parity_error_retr    = ex_retr_pipe_i_access_parity_error_retr & instr_valid_retr;
  assign i_access_misalign_error_retr  = ex_retr_pipe_i_access_misalign_error_retr & instr_valid_retr;
  assign illegal_instr_retr            = ex_retr_pipe_illegal_instr_retr & instr_valid_retr;  
  assign m_env_call_retr               = ex_retr_pipe_m_env_call_retr & instr_valid_retr;
  assign trap_ret_retr                 = ex_retr_pipe_trap_ret_retr & instr_valid_retr & ~debug_mode_retire_mask_retr;
  assign dbreak_retr                   = ex_retr_pipe_dbreak_retr & instr_valid_retr;
  assign curr_instr_enc_retr           = ex_retr_pipe_curr_instr_enc_retr;
  assign curr_pc_retr                  = ex_retr_pipe_curr_pc_retr;   


  // Stage handshaking/control  
  
  assign instr_retire_retr             = instr_completing_retr & instr_valid_retr & ~implicit_pseudo_instr_retr & ~debug_mode_retire_mask_retr; 
  
  // trap taken is only indicated when the instruction retires, however to prevent stores being initiated in the EX stage, need to 
  // determine when a trap is pending instruction completion in case the instruction retire is delayed (by a delayed LSU response)
  // LSU traps will be handled by the LSU, so do not need to include them here, bus errors are imprecise, so again do not need to include
  // them here.
  // Do not need to include interrupts here as they are also imprecise, but if not included must delay interrupts being taken until any stores 
  // in flight complete because otherwise store can occur without instruction that caused it seeming to execute. 
  // May also apply to loads that have read side-effects, so also include loads (fence has no side effects, but simpler to include it)
  // Such that interrupts eventually happen with reasonably predictable latency in a long sequence of stores, prevent new stores when an interrupt 
  // that will be taken is pending.
  
  assign trap_pending_retr                   = (i_access_fault_retr |         
                                                i_access_mem_error_retr |     
                                                i_access_parity_error_retr | 
                                                i_access_misalign_error_retr |
                                                illegal_instr_retr |
                                                m_env_call_retr |   
                                                dbreak_retr); 
              
  //--------------------------------------------------------
  // GPRs
  //--------------------------------------------------------  

  // gpr pipelining and controls //
  // GPR writes always occur at the end of the retr, and in core always in a single cycle,
  // therefore the write operation persists until the write completes when the operand results are valid from 
  // preceding ex stage or lsu

  // Option to select debug CSR/GPR read/write control pipelining.
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_gpr_ctrl_no_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | gpr_wr_completing_retr)
      begin
        ex_retr_pipe_gpr_wr_en_retr       <= update_ctrl_attbs_retr ? gpr_wr_en_ex : 1'b0;    
      end    
    end  
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
      begin
        ex_retr_pipe_gpr_wr_sel_retr      <= gpr_wr_sel_ex;   
        ex_retr_pipe_gpr_wr_mux_sel_retr  <= gpr_wr_mux_sel_ex;   
      end    
    end
  
    assign gpr_wr_valid_mux         = debug_mode_retr ? (debug_gpr_req_wr_en & debug_gpr_req_valid) : gpr_wr_valid_retr; 
    assign gpr_wr_sel_mux           = debug_mode_retr ? debug_gpr_req_addr                          : gpr_wr_sel_retr;
    assign gpr_wr_data_mux          = debug_mode_retr ? debug_csr_gpr_req_wr_data                   : gpr_wr_data_retr;
    
    assign exu_update_result_reg    = ex_retr_exu_res_accept_retr;
    
    assign gpr_rs2_rd_valid_dbgpipe = debug_mode_retr ? (debug_gpr_req_rd_en & debug_gpr_req_valid) : gpr_rs2_rd_valid_stg; 
    assign gpr_rs2_rd_sel_dbgpipe   = debug_mode_retr ? debug_gpr_req_addr                          : gpr_rs2_rd_sel_stg;
    
  end
  else begin : gen_debug_gpr_ctrl_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | gpr_wr_completing_retr | debug_mode_retr)
      begin
        ex_retr_pipe_gpr_wr_en_retr       <= debug_mode_retr ? (debug_gpr_req_wr_en & debug_gpr_req_valid) : 
                                                               (update_ctrl_attbs_retr ? gpr_wr_en_ex : 1'b0);    
      end    
    end  
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | debug_mode_retr)
      begin
        ex_retr_pipe_gpr_wr_sel_retr      <= debug_mode_retr ? debug_gpr_req_addr : gpr_wr_sel_ex;   
        ex_retr_pipe_gpr_wr_mux_sel_retr  <= debug_mode_retr ? gpr_wr_mux_sel_exu : gpr_wr_mux_sel_ex;   
      end    
    end
  
    assign gpr_wr_valid_mux      = gpr_wr_valid_retr; 
    assign gpr_wr_sel_mux        = gpr_wr_sel_retr;
    assign gpr_wr_data_mux       = gpr_wr_data_retr;
    
    assign exu_update_result_reg = ex_retr_exu_res_accept_retr | debug_mode_retr; 
    
    assign gpr_rs2_rd_valid_dbgpipe = debug_mode_retr ? gpr_rs2_rd_valid_ex : gpr_rs2_rd_valid_stg; 
    assign gpr_rs2_rd_sel_dbgpipe   = debug_mode_retr ? gpr_rs2_rd_sel_ex   : gpr_rs2_rd_sel_stg;
    
  end
  endgenerate
  
  assign gpr_wr_en_retr         = ex_retr_pipe_gpr_wr_en_retr & (instr_valid_retr | debug_mode_retr);
  assign gpr_wr_sel_retr        = ex_retr_pipe_gpr_wr_sel_retr;
  assign gpr_wr_mux_sel_retr    = ex_retr_pipe_gpr_wr_mux_sel_retr;  
  assign gpr_wr_complete_retr   = (~gpr_wr_en_retr) | gpr_wr_completing_retr;

  
 // GPR write data mux

  always @*
  begin
    case(gpr_wr_mux_sel_retr)
      gpr_wr_mux_sel_none :       
      begin
        gpr_wr_data_retr        = {L_XLEN{1'b0}};
        gpr_wr_valid_retr       = 1'b0;
        gpr_wr_completing_retr  = 1'b1;
      end  
      gpr_wr_mux_sel_lsu :       
      begin
        gpr_wr_data_retr        = lsu_resp_rd_data;
        gpr_wr_valid_retr       = lsu_resp_valid & gpr_wr_en_retr & ~flush_retr;        
        gpr_wr_completing_retr  = gpr_wr_ready_retr & lsu_resp_valid & gpr_wr_en_retr;
      end  
      gpr_wr_mux_sel_exu :       
      begin
        gpr_wr_data_retr        = exu_result_retr; 
        gpr_wr_valid_retr       = gpr_wr_en_retr & exu_result_valid_retr & (debug_mode_retr | ~flush_retr);
        gpr_wr_completing_retr  = gpr_wr_ready_retr & exu_result_valid_retr & gpr_wr_en_retr;
      end  
      gpr_wr_mux_sel_csr :       
      begin
        gpr_wr_data_retr        = sw_csr_rd_data_retr;      
        gpr_wr_valid_retr       = sw_csr_rd_data_valid_retr & gpr_wr_en_retr & ~flush_retr;
        gpr_wr_completing_retr  = (gpr_wr_ready_retr & sw_csr_rd_data_valid_retr & gpr_wr_en_retr); 
      end  
      default :        
      begin
        gpr_wr_data_retr        = {L_XLEN{1'b0}};
        gpr_wr_valid_retr       = 1'b0;
        gpr_wr_completing_retr  = 1'b1;
      end                    
    endcase
  end 
  
  // Debug read path currently muxed into rs2 path as this is likely less critical than rs1
  
  generate if (l_core_cfg_gpr_rd_ex)
  begin : gen_gpr_ex_ctrls_rd_ex
    assign gpr_rs1_rd_valid_mux = gpr_rs1_rd_valid_ex & ~gpr_rs1_stall_ex;
    assign gpr_rs1_rd_sel_mux   = gpr_rs1_rd_sel_ex;
    assign gpr_rs2_rd_valid_stg = (gpr_rs2_rd_valid_ex & ~gpr_rs2_stall_ex);
    assign gpr_rs2_rd_sel_stg   = gpr_rs2_rd_sel_ex;
  end
  else begin : gen_gpr_ex_ctrls_rd_de
    assign gpr_rs1_rd_valid_mux = instr_valid_de & gpr_rs1_rd_valid_de;
    assign gpr_rs1_rd_sel_mux   = gpr_rs1_rd_sel_de;
    assign gpr_rs2_rd_valid_stg = instr_valid_de & gpr_rs2_rd_valid_de;
    assign gpr_rs2_rd_sel_stg   = gpr_rs2_rd_sel_de;
  end
  endgenerate
  
  
  assign gpr_rs2_rd_valid_mux = gpr_rs2_rd_valid_dbgpipe;
  assign gpr_rs2_rd_sel_mux   = gpr_rs2_rd_sel_dbgpipe; 
  
  generate
  if(l_core_cfg_gpr_type == 1)
    begin : gen_gpr
      miv_rv32_gpr
      u_gpr_0
     (
      .clk                            (clk                          ),
      .resetn                         (resetn                       ),
      .gpr_wr_valid                   (gpr_wr_valid_mux             ),
      .gpr_wr_ready                   (gpr_wr_ready_sig             ),
      .gpr_wr_sel                     (gpr_wr_sel_mux               ),
      .gpr_wr_data                    (gpr_wr_data_mux              ),
      .gpr_rs1_rd_valid               (gpr_rs1_rd_valid_mux         ),
      .gpr_rs1_rd_ready               (gpr_rs1_rd_ready_sig         ),
      .gpr_rs1_rd_sel                 (gpr_rs1_rd_sel_mux           ),
      .gpr_rs1_rd_data                (gpr_rs1_rd_data_sig          ),
      .gpr_rs1_rd_data_valid          (gpr_rs1_rd_data_valid_sig    ),
      .gpr_rs2_rd_valid               (gpr_rs2_rd_valid_mux         ),
      .gpr_rs2_rd_ready               (gpr_rs2_rd_ready_sig         ),
      .gpr_rs2_rd_sel                 (gpr_rs2_rd_sel_mux           ),
      .gpr_rs2_rd_data                (gpr_rs2_rd_data_sig          ),
      .gpr_rs2_rd_data_valid          (gpr_rs2_rd_data_valid_sig    ),
      .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src  ), 
      .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src)
     );
	 
	 assign gpr_ram_init_done = 1'b1;
    end
  else
    begin : gen_gpr_ram
      miv_rv32_gpr_ram #( .l_core_cfg_gpr_fwd_hzd (l_core_cfg_gpr_fwd_hzd),
                            .ECC_ENABLE                  (ECC_ENABLE                 )
						  )
      u_gpr_0
     (
      .clk                            (clk                          ),
      .resetn                         (resetn                       ),
      .gpr_wr_valid                   (gpr_wr_valid_mux             ),
      .gpr_wr_ready                   (gpr_wr_ready_sig             ),
      .gpr_wr_sel                     (gpr_wr_sel_mux               ),
      .gpr_wr_data                    (gpr_wr_data_mux              ),
      .gpr_rs1_rd_valid               (gpr_rs1_rd_valid_mux         ),
      .gpr_rs1_rd_ready               (gpr_rs1_rd_ready_sig         ),
      .gpr_rs1_rd_sel                 (gpr_rs1_rd_sel_mux           ),
      .gpr_rs1_rd_data                (gpr_rs1_rd_data_sig          ),
      .gpr_rs1_rd_data_valid          (gpr_rs1_rd_data_valid_sig    ),
      .gpr_rs2_rd_valid               (gpr_rs2_rd_valid_mux         ),
      .gpr_rs2_rd_ready               (gpr_rs2_rd_ready_sig         ),
      .gpr_rs2_rd_sel                 (gpr_rs2_rd_sel_mux           ),
      .gpr_rs2_rd_data                (gpr_rs2_rd_data_sig          ),
      .gpr_rs2_rd_data_valid          (gpr_rs2_rd_data_valid_sig    ),
      .gpr_correctable_ecc_irq_src    (gpr_correctable_ecc_irq_src  ), 
      .gpr_uncorrectable_ecc_irq_src  (gpr_uncorrectable_ecc_irq_src),
      .gpr_ram_init_done              (gpr_ram_init_done),
      .gpr_ram_init_soft_debug_reset  (gpr_ram_init_soft_debug_reset)
     );
    end
endgenerate
 
  assign gpr_wr_ready_retr            = gpr_wr_ready_sig & ~debug_mode_retr;
  assign gpr_uncorrectable_ecc_error  = gpr_uncorrectable_ecc_irq_src;
  
  assign debug_gpr_req_ready          = debug_mode_retr;
  assign debug_gpr_resp_rd_data       = gpr_rs2_rd_data_sig;
  assign debug_gpr_resp_valid         = gpr_rs2_rd_data_valid_sig & debug_mode_retr;
  
  
 
 //--------------------------------------------------------
  // CSRs
  //--------------------------------------------------------  

  // Trap handling //
  
  // if a trap is taken, CSRs will be updated in retr cycle they occur on, the decoder will be overidden to 
  // decode the "trap" instruction which computes the exception branch target and initiates a branch operation
  // software (explicit) CSR read/writes, GPR writes and LSU operations will be inhibited.

  assign vectored_interrupt_taken_retr    = interrupt_taken_retr & csr_priv_mtvec_excpt_vectored_retr;
  
  // pipelining and controls
  

  
  assign sw_csr_addr_retr              = ex_retr_pipe_sw_csr_addr_retr;
  assign sw_csr_wr_op_retr             = instr_valid_retr ? ex_retr_pipe_sw_csr_wr_op_retr : csr_alu_wr_op_none;  
  assign sw_csr_rd_op_retr             = instr_valid_retr ? ex_retr_pipe_sw_csr_rd_op_retr : csr_alu_rd_op_none;  
  assign csr_completing_retr           = ((sw_csr_wr_op_retr != csr_alu_wr_op_none) | (sw_csr_rd_op_retr != csr_alu_rd_op_none)) & sw_csr_op_ready_retr;
  assign csr_complete_retr             = ((sw_csr_wr_op_retr == csr_alu_wr_op_none) & (sw_csr_rd_op_retr == csr_alu_rd_op_none)) | csr_completing_retr;
  
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_csr_ctrl_no_pipeline
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | csr_completing_retr)
      begin
        ex_retr_pipe_sw_csr_wr_op_retr   <= update_ctrl_attbs_retr ? sw_csr_wr_op_ex : csr_alu_wr_op_none;
        ex_retr_pipe_sw_csr_rd_op_retr   <= update_ctrl_attbs_retr ? sw_csr_rd_op_ex : csr_alu_rd_op_none;
      end    
    end   
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr)
        ex_retr_pipe_sw_csr_addr_retr    <= sw_csr_addr_ex;    
    end  
  
    assign debug_csr_gpr_req_wr_data_dbgpipe  = debug_csr_gpr_req_wr_data;
    assign debug_csr_req_wr_en_dbgpipe        = debug_csr_req_wr_en & debug_csr_req_valid;     
    assign debug_csr_req_rd_en_dbgpipe        = debug_csr_req_rd_en & debug_csr_req_valid;     
    assign debug_csr_req_addr_dbgpipe         = debug_csr_req_addr;  
  end
  else begin : gen_debug_csr_ctrl_pipeline 
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | csr_completing_retr | debug_mode_retr)
      begin
        ex_retr_pipe_sw_csr_wr_op_retr   <= debug_mode_retr ? ((debug_csr_req_wr_en & debug_csr_req_valid)? csr_alu_wr_op_swap : csr_alu_wr_op_none) :
                                                              (update_ctrl_attbs_retr ? sw_csr_wr_op_ex : csr_alu_wr_op_none);
        ex_retr_pipe_sw_csr_rd_op_retr   <= debug_mode_retr ? ((debug_csr_req_rd_en & debug_csr_req_valid) ? csr_alu_rd_op_rd : csr_alu_rd_op_none) : 
                                                              (update_ctrl_attbs_retr ? sw_csr_rd_op_ex : csr_alu_rd_op_none);
      end    
    end   
  
    always @(posedge clk)
    begin
      if(update_ctrl_attbs_retr | debug_mode_retr)
        ex_retr_pipe_sw_csr_addr_retr    <= debug_mode_retr ? debug_csr_req_addr : sw_csr_addr_ex;    
    end  
    
    assign debug_csr_gpr_req_wr_data_dbgpipe  = ex_retr_pipe_exu_result_retr;
    assign debug_csr_req_wr_en_dbgpipe        = (ex_retr_pipe_sw_csr_wr_op_retr == csr_alu_wr_op_swap);    // re-use swap encoding to indicate debug write
    assign debug_csr_req_rd_en_dbgpipe        = (ex_retr_pipe_sw_csr_rd_op_retr == csr_alu_rd_op_rd);     
    assign debug_csr_req_addr_dbgpipe         = ex_retr_pipe_sw_csr_addr_retr;  
  end
  endgenerate
  
  assign debug_csr_req_ready = debug_mode_retr;
  
  miv_rv32_csr_privarch
  #(
     .I_ADDR_WIDTH                              (I_ADDR_WIDTH                              ),
	 .l_core_reset_vector                  (l_core_reset_vector                  ),
     .l_core_cfg_hw_multiply_divide        (l_core_cfg_hw_multiply_divide        ),
     .l_core_cfg_hw_compressed             (l_core_cfg_hw_compressed             ),
     .l_core_static_mtvec_base             (l_core_static_mtvec_base             ),
     .l_core_cfg_static_mtvec_base         (l_core_cfg_static_mtvec_base         ),
     .l_core_cfg_static_mtvec_mode         (l_core_cfg_static_mtvec_mode         ),
     .l_core_static_mtvec_mode             (l_core_static_mtvec_mode             ),
	 .l_core_num_sys_ext_irqs              (l_core_num_sys_ext_irqs              ),
	 .l_core_cfg_time_count_width          (l_core_cfg_time_count_width          ),
	 .l_core_cfg_num_triggers              (l_core_cfg_num_triggers              ),
	 .l_core_cfg_trigger_bus_width         (l_core_cfg_trigger_bus_width         ),
	 .l_core_cfg_gpr_ecc_uncorrectable_irq (l_core_cfg_gpr_ecc_uncorrectable_irq ),
     .l_core_cfg_gpr_ecc_correctable_irq   (l_core_cfg_gpr_ecc_correctable_irq   ),
     .l_core_cfg_hw_debug                  (l_core_cfg_hw_debug                  )

  )
  u_csr_privarch_0
  (
    .clk                                      (clk                               ),                                                                    
    .resetn                                   (resetn                            ),                                                                          
    .soft_reset                               (core_soft_reset || ~gpr_ram_init_done ), //must hold the cpu in reset while initialising gpr ram
    .debug_soft_reset                         (debug_core_reset                  ),                                                                   
    .debug_reset                              (debug_reset                       ),                                                             
    .hart_id                                  (hart_id                           ), 
    .instr_completing_retr                    (instr_completing_retr             ),                                                            
    .instr_valid_retr                         (instr_valid_retr                  ),                                                                          
    .cycle_executed                           (~debug_mode_retr                  ),                                                 
    .time_count                               (time_count                        ),                                                            
    .instr_retired                            (instr_retire_retr                 ),                                                            
    .instr_wfi                                (wfi_retr                          ),                                                            
    .wfi_waiting                              (wfi_waiting_retr                  ),                                                            
    .instr_lsu_op_retr                        (instr_is_lsu_op_retr              ),  
    .lsu_op_os                                (lsu_op_os                         ),
    .irq_stall_lsu_req                        (irq_stall_lsu_req_retr            ),
    .irq_abort_lsu_req                        (irq_abort_lsu_req_retr            ),
    .flush                                    (flush_retr                        ),                                                                                                                                                                                   
    .csr_op_gpr_imm                           (exu_result_retr                   ),                                                                    
    .csr_op_gpr_imm_valid                     (exu_result_valid_retr             ), 
    .csr_op_rd_data                           (sw_csr_rd_data_retr               ),  // required for GPR forwarding path when GPR written from CSR
    .csr_op_rd_data_valid                     (sw_csr_rd_data_valid_retr         ),                                                                    
    .csr_op_ready                             (sw_csr_op_ready_retr              ),                                                                    
    .csr_alu_wr_op_sel                        (sw_csr_wr_op_retr                 ),                                                                     
    .csr_alu_rd_op_sel                        (sw_csr_rd_op_retr                 ),                                                                        
    .csr_op_addr                              (sw_csr_addr_retr                  ),                                                                     
    .csr_op_addr_valid                        (1'b1                              ),                                                                
    .ext_msip                                 (m_sw_irq                          ), 
    .ext_mtip                                 (m_timer_irq                       ),                                                                         
    .ext_meip                                 (m_external_irq                    ),  
    .sys_ext_irq_src                          (sys_ext_irq_src                   ),
    .gpr_uncorrectable_ecc_irq_src            (gpr_uncorrectable_ecc_irq_src     ),
    .gpr_correctable_ecc_irq_src              (gpr_correctable_ecc_irq_src       ), 
    .curr_pc                                  (curr_pc_retr                      ),                                                                         
    .curr_instr_enc                           (curr_instr_enc_retr               ),                                                                         
    .curr_ld_addr                             (exu_result_retr                   ), 
    .curr_str_addr                            (exu_result_retr                   ),  
    .excpt_i_addr_misalign                    (i_access_misalign_error_retr      ),                                                                         
    .excpt_i_access_fault                     (i_access_fault_retr               ),                                                                         
    .excpt_illegal_instr                      (illegal_instr_retr                ),                                                                         
    .excpt_breakpoint                         (dbreak_retr                       ),                                                                         
    .excpt_trigger                            (trigger_retr                      ),                                                                         
    .excpt_ld_addr_misalign                   (lsu_resp_ld_addr_misalign         ),                                                               
    .excpt_ld_access_fault                    (lsu_resp_ld_access_fault          ),                                                               
    .excpt_str_amo_addr_misalign              (lsu_resp_str_amo_addr_misalign    ),                                                               
    .excpt_str_amo_access_fault               (lsu_resp_str_amo_access_fault     ),                                                               
    .excpt_m_env_call                         (m_env_call_retr                   ),                                                               
    .excpt_s_env_call                         (1'b0                              ),                                                               
    .excpt_u_env_call                         (1'b0                              ),
    .excpt_bus_error_i                        (i_access_mem_error_retr           ), 
    .excpt_parity_error_i                     (i_access_parity_error_retr        ), 
    .excpt_bus_error_d                        (lsu_resp_access_mem_error         ), 
    .excpt_parity_error_d                     (lsu_resp_access_parity_error      ),                                                              
    .trap_taken                               (trap_taken_retr                   ),                                                               
    .trap_return                              (trap_ret_retr                     ),                                                               
    .extension_context_state                  (2'b00                             ),                                                                                                                                                                                                            
    .debug_csr_op_wr_data                     (debug_csr_gpr_req_wr_data_dbgpipe ),                                                    
    .debug_csr_wr_en                          (debug_csr_req_wr_en_dbgpipe       ),                                                                    
    .debug_csr_rd_en                          (debug_csr_req_rd_en_dbgpipe       ),                                                      
    .debug_csr_op_addr                        (debug_csr_req_addr_dbgpipe        ),                                                      
    .debug_csr_op_rd_data                     (debug_csr_resp_rd_data            ),
    .debug_csr_op_rd_data_valid               (debug_csr_resp_valid              ), 
    .debug_active                             (debug_active                      ),                                                     
    .debug_halt_req                           (debug_halt_req                    ), 
    .debug_halt_ack                           (debug_halt_ack                    ),                                                     
    .debug_resethalt_req                      (debug_resethalt_req               ), 
    .debug_resethalt_ack                      (debug_resethalt_ack               ),                                             
    .debug_resume_req                         (debug_resume_req                  ),                                                      
    .debug_resume_ack                         (debug_resume_ack                  ),  
    .debug_mode_enter_req                     (debug_enter_req_de                ), 
    .debug_instr_debug_enter_req              (debug_enter_req_retr              ),                                      
    .debug_mode_enter                         (debug_enter_retr                  ),
    .debug_mode_retire_mask                   (debug_mode_retire_mask_retr       ),                                             
    .debug_mode_exit                          (debug_exit_retr                   ),                                                                                                                                                                                                  
    .csr_priv_misa                            (csr_priv_misa_retr                ),                                                                   
    .csr_priv_cause_excpt_code                (csr_priv_cause_excpt_code_retr    ),                                                                   
    .csr_priv_mtvec_excpt_vectored            (csr_priv_mtvec_excpt_vectored_retr),                                                                   
    .csr_priv_mtvec_excpt_vec                 (csr_priv_mtvec_excpt_vec_retr     ),                                                                   
    .csr_priv_epc                             (csr_priv_mtvec_epc_retr           ), 
    .csr_priv_dpc                             (csr_priv_dpc_retr                 ),    
    .csr_priv_soft_reset_taken                (soft_reset_taken_unmasked_retr    ),                                                                  
    .csr_priv_interrupt_taken                 (interrupt_taken_retr              ),
    .csr_priv_priv_mode                       (priv_mode_retr                    ), // core only supports machine mode
    .csr_priv_debug_mode                      (debug_mode_retr                   ),                                                                   
    .trigger_instruction_opcode               (ifu_expipe_resp_ireg              ),                                                                   
    .trigger_instruction_address              (ifu_expipe_resp_ireg_vaddr        ),                                                                   
    .trigger_instruction_valid                (trigger_op_addr_valid_de          ),
    .step_instruction_valid                   (step_instruction_valid_de         ),                                                                  
    .trigger_req                              (trigger_req_de                    ),
    .gpr_ram_init_soft_debug_reset            (gpr_ram_init_soft_debug_reset     )                                                                      
                                                                                                                                                  
  );                                                                                                                                              
  
  // outside of the state update in the CSR PRIV block (and formal model), taking a reset whilst in debug mode should have no effect.
  assign soft_reset_taken_retr = soft_reset_taken_unmasked_retr & ~(debug_enter_retr | debug_mode_retr);                                                                                                                                                
  assign debug_mode = debug_mode_retr;                                               
  
  
  assign cfg_hw_mul_en_retr         = csr_priv_misa_retr[12] & l_core_cfg_hw_multiply;
  assign cfg_hw_div_en_retr         = csr_priv_misa_retr[12] & l_core_cfg_hw_divide;  
  assign cfg_atomics_en_retr        = csr_priv_misa_retr[0] & l_core_cfg_hw_atomics;
  assign cfg_compressed_en_retr     = csr_priv_misa_retr[2] & l_core_cfg_hw_compressed;  


  //--------------------------------------------------------
  // LSU Interface
  //--------------------------------------------------------    

// lsu controls 
  always @(posedge clk)
  begin
    if(update_ctrl_attbs_retr | lsu_op_completing_retr)
    begin    
      ex_retr_pipe_lsu_op_retr  <= (update_ctrl_attbs_retr & ~instr_inhibit_ex) ? lsu_op_ex_pipe : lsu_op_none;    
    end    
  end  

  assign lsu_op_retr            = instr_valid_retr ? ex_retr_pipe_lsu_op_retr : lsu_op_none;
  
  assign lsu_op_completing_retr = lsu_resp_ready & lsu_resp_valid;
  assign lsu_op_complete_retr   = (lsu_op_retr == lsu_op_none) | lsu_op_completing_retr;
  
  assign instr_is_lsu_op_retr   = (lsu_op_retr != lsu_op_none);
  
  // LSU is external to the pipeline to simplify independent formal verification 
  // LSU resp always goes to gpr, so ready when expecting LSU response and gpr can be written   
  assign lsu_resp_ready         =  ((((lsu_op_retr == lsu_op_ld_byte_s) |
                                      (lsu_op_retr == lsu_op_ld_hword_s) |
                                      (lsu_op_retr == lsu_op_ld_word) |
                                      (lsu_op_retr == lsu_op_ld_byte_u) |
                                      (lsu_op_retr == lsu_op_ld_hword_u)) & gpr_wr_ready_retr & (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu)) |
                                   (lsu_op_retr == lsu_op_str_byte) |
                                   (lsu_op_retr == lsu_op_str_word) |
                                   (lsu_op_retr == lsu_op_str_hword) |
                                   (lsu_op_retr == lsu_op_fence));

  // input wire  logic                                lsu_resp_access_aborted       // - not currently used 
  
  // Must block LSU requests in the ex stage if the retr stage is going to be unable to accept them.
  // This does not include the lsu response itself as this may be late, and the issue this protects
  // against is being able to not accept an LSU response for the second request - if the first request is the
  // cause of the stall, then inherently the second response cannot be attempting to return as Core
  // requires requests complete in order
  
  assign lsu_req_stall_retr = stall_retr | irq_stall_lsu_req_retr;
    





 
  //--------------------------------------------------------
  // Formal Trace Interface
  //--------------------------------------------------------
  
  assign formal_trace_instr             = curr_instr_enc_retr;
  assign formal_trace_pc                = curr_pc_retr;
  assign formal_trace_reset_taken       = soft_reset_taken_unmasked_retr;  
  assign formal_trace_instr_retire      = instr_retire_retr;  
   
   
 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  // cannot force a reset when in or entering debug mode
  assert_expipe_no_soft_reset_when_debug: assert property (@(posedge clk) disable iff (~resetn)
      force_core_soft_reset_branch_de |-> ~(debug_enter_retr | debug_mode_retr));
  
   
  
  // cannot force a trap branch when in or entering debug mode
  
  assert_expipe_no_trap_branche_when_debug: assert property (@(posedge clk) disable iff (~resetn)
      force_trap_branch_de |-> ~(debug_enter_retr | debug_mode_retr));
  

  // If an instruction is accepted from the IFU, the de_ex pipeline registers must be able to accept it
  assert_expipe_ifu_instr_accept_must_update_de_ex: assert property (@(posedge clk) disable iff (~resetn)
                                                                     (ifu_expipe_resp_ready & ifu_expipe_resp_valid) |-> update_ctrl_attbs_ex);

  // can always accept an LSU response if a request is accepted
  assert_expipe_lsu_req_must_accepte_response: assert property (@(posedge clk) disable iff (~resetn)
                                                                (lsu_req_valid & lsu_req_ready & ~lsu_flush) |-> ##1 lsu_resp_ready);
                                                                       
                                                                       
  // in retr stage, if lsu op is for a load, gpr wr enable must be asserted and must have lsu as the source
  assert_expipe_retr_load_must_write_gpr: assert property (@(posedge clk) disable iff (~resetn)
                                                           ((lsu_op_retr == lsu_op_ld_byte_s) |
                                                            (lsu_op_retr == lsu_op_ld_hword_s) |
                                                            (lsu_op_retr == lsu_op_ld_word) |
                                                            (lsu_op_retr == lsu_op_ld_byte_u) |
                                                            (lsu_op_retr == lsu_op_ld_hword_u)) |-> gpr_wr_en_retr);
                                                            
  assert_expipe_retr_load_must_write_sel_lsu: assert property (@(posedge clk) disable iff (~resetn)
                                                           ((lsu_op_retr == lsu_op_ld_byte_s) |
                                                            (lsu_op_retr == lsu_op_ld_hword_s) |
                                                            (lsu_op_retr == lsu_op_ld_word) |
                                                            (lsu_op_retr == lsu_op_ld_byte_u) |
                                                            (lsu_op_retr == lsu_op_ld_hword_u)) |-> (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_lsu));
                                                            
  // if writing the GPR, then the source can't be none
  assert_expipe_retr_gpr_write_must_have_src: assert property (@(posedge clk) disable iff (~resetn)
                                                               gpr_wr_en_retr |-> (gpr_wr_mux_sel_retr != gpr_wr_mux_sel_none)); 
                                                               
                                                                                                            
                                                             
  // if using exu result in retr stage then exu_result_valid_retr must be asserted
  assert_expipe_retr_using_exu_must_be_valid_gpr: assert property (@(posedge clk) disable iff (~resetn)  
                                                                  (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_exu) & instr_valid_retr |-> exu_result_valid_retr);
                                                                  
  assert_expipe_retr_using_exu_must_be_valid_csr: assert property (@(posedge clk) disable iff (~resetn)  
                                                                  (sw_csr_wr_op_retr != csr_alu_wr_op_none) & instr_valid_retr |-> exu_result_valid_retr); 
                                                                  
  // if a csr op is accepted, csr and gpr must be written or trap taken when instruction completes 
  // (as csr update is atomic, gpr and csr must complete in the same cycle)
  assert_expipe_retr_csr_must_write_or_trap: assert property (@(posedge clk) disable iff (~resetn) 
                                                              (sw_csr_wr_op_retr!= csr_alu_wr_op_none) & instr_valid_retr |-> ##[0:$] (csr_completing_retr | trap_taken_retr));
                                                              
  assert_expipe_retr_csr_gpr_wr_same_cycle: assert property (@(posedge clk) disable iff (~resetn)                                                            
                                                             (gpr_wr_mux_sel_retr == gpr_wr_mux_sel_csr) & gpr_wr_en_retr & instr_valid_retr |-> (csr_completing_retr == gpr_wr_completing_retr));
  
  
  // if a gpr write op is accepted, gpr must be written or trap taken when instruction completes 
  assert_expipe_retr_gpr_must_write_or_trap: assert property (@(posedge clk) disable iff (~resetn) 
                                                              (gpr_wr_en_retr & instr_valid_retr) |-> ##[0:$] (gpr_wr_completing_retr | trap_taken_retr));  
                                                              
                                                              
  
  // if an instruction is accepted it must eventually complete  
  
  assert_expipe_ex_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_valid_ex & ~implicit_pseudo_instr_ex  |-> ##[0:$] (instr_completing_ex | flush_ex));  
                                                              
  assert_expipe_retr_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_valid_retr & ~implicit_pseudo_instr_retr  |-> ##[0:$] (instr_completing_retr | flush_retr));                                                               
                                                              
  assert_expipe_retr2_must_complete: assert property (@(posedge clk) disable iff (~resetn) 
                                                              instr_req_retr & ~implicit_pseudo_instr_retr  |-> ##[1:$] instr_completing_retr);   
                                                              
  // retr stage request must complete in the same cycle any lsu request is returned (because in the case of an exception, the bits are not written until the instruction completes)    
  
  // If a debug halt request is made, eventually enter debug mode
  assert_expipe_debug_halt_req_must_halt: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_halt_req & ~debug_mode |-> ##[0:$] (debug_mode | ~debug_halt_req));
                                                           
  assert_expipe_debug_halt_req_must_ack: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_halt_req & ~debug_mode |-> ##[0:$] (debug_halt_ack | ~debug_halt_req));
  
  // if a debug resume request is made, eventually leave debug mode 
  assert_expipe_debug_resume_req_must_leave: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_resume_req & debug_mode |-> ##[0:$] ((~debug_mode) | (~debug_resume_req)));
                                                           
  assert_expipe_debug_resume_req_must_ack: assert property (@(posedge clk) disable iff (~resetn)
                                                           debug_resume_req & debug_mode |-> ##[0:$] (debug_resume_ack | ~debug_resume_req));  
                                                             
                                                 
                                                                                                              
`endif                                                        

 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_exu.sv
//
//   Purpose:
//   Execution unit for core
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none
import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module  miv_rv32_exu
//********************************************************************************
// Parameter description

  #(
    parameter USE_FORMAL = 1,
    parameter USE_SIM = 1,
	parameter l_core_cfg_hw_debug           = 0,
	parameter l_core_cfg_hw_multiply_divide = 0,
	parameter l_core_cfg_hw_macc_multiplier = 0
 
   )

//********************************************************************************
// Port description

  (
    //inputs
    
    input wire  logic                         clk,
    input wire  logic                         resetn,
    // controls
    input wire  logic                         exu_op_abort, 
    output      logic                         exu_op_ready,
    input wire  logic                         debug_mode,
                  
    input wire  t_exu_alu_operand0_sel        alu_operand0_mux_sel,                 
    input wire  t_exu_alu_operand1_sel        alu_operand1_mux_sel,                 
    input wire  t_exu_alu_op_sel              alu_op_sel,                       
    input wire  t_exu_shifter_operand_sel     shifter_operand_sel,              
    input wire  t_exu_shifter_places_sel      shifter_unit_places_sel,          
    input wire  t_exu_shifter_op_sel          shifter_unit_op_sel,                    
    input wire  t_exu_alu_result_mux_sel      exu_result_mux_sel,         
      //operands
    input wire  logic [L_XLEN-1:0]            exu_operand_gpr_rs1,            
    input wire  logic                         exu_operand_gpr_rs1_valid,      
    input wire  logic [L_XLEN-1:0]            exu_operand_gpr_rs2,            
    input wire  logic                         exu_operand_gpr_rs2_valid,      
    input wire  logic [L_XLEN-1:0]            exu_operand_immediate,          
    input wire  logic                         exu_operand_immediate_valid,             
    input wire  logic [L_XLEN-1:0]            exu_operand_pc,                 
    input wire  logic                         exu_operand_pc_valid,   
    input wire  logic [L_XLEN-1:0]            acu_result,
    input wire  logic                         acu_result_valid, 
    input wire  logic [L_XLEN-1:0]            debug_wr_data, 
    input wire  logic                         debug_wr_data_valid,                  
      // result
           
    output      logic [L_XLEN-1:0]            exu_result,            
    output      logic                         exu_result_valid,  
    input wire  logic                         exu_result_ready,     
    output      t_exu_flags                   exu_result_flags,           
    output      logic [L_XLEN-1:0]            lsu_align_result,      
    output      logic                         lsu_align_result_valid,
    input wire  logic                         lsu_align_result_ready,  
    input wire  logic                         update_result_reg,  
    output      logic [L_XLEN-1:0]            exu_result_reg,            
    output      logic                         exu_result_reg_valid 

  );

//********************************************************************************
// localparams
  localparam cfg_div_en     = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_divide;
  localparam cfg_fast_mul   = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_multiply & (l_core_cfg_hw_macc_multiplier != 0);
  localparam cfg_slow_mul   = l_core_cfg_hw_multiply_divide & l_core_cfg_hw_multiply & (l_core_cfg_hw_macc_multiplier == 0);

// Declarations
  logic [L_XLEN-1:0]            exu_alu_operand0;
  logic                         exu_alu_operand0_valid;
  logic [L_XLEN-1:0]            exu_alu_operand1;
  logic                         exu_alu_operand1_valid;
  logic [L_XLEN-1:0]            exu_shifter_operand;      
  logic                         exu_shifter_operand_valid;
  logic [L_XLEN-1:0]            exu_shifter_places;      
  logic                         exu_shifter_places_valid; 
  logic                         exu_alu_ready;
  
  logic [1:0]                   addr_shift_bits;
  logic                         addr_shift_bits_valid;
  logic [L_XLEN:0]              exu_alu_result; 
  logic                         exu_alu_result_valid;
  logic [L_XLEN-1:0]            shifter_result;      
  logic                         shifter_result_valid;
  logic                         exu_shifter_ready;
  
  logic [L_XLEN-1:0]            exu_mux_result;      
  logic                         exu_mux_result_valid; 
  logic                         exu_mux_result_valid_dbgsel;
  t_exu_flags                   exu_mux_result_flags;
  
  logic [L_XLEN:0]              exu_alu_operand0_int;
  logic [L_XLEN:0]              exu_alu_operand1_int;
  logic [(L_XLEN*2)-2:0]        div_divisor;
  logic [(L_XLEN*2):0]          exu_result_reg_int;  
  logic [(L_XLEN*2):0]          exu_mux_result_dbgsel;
  logic [(L_XLEN*2)-1:0]        slow_mul_result; 
  logic [L_XLEN:0]              exu_alu_operand0_s;
  logic [L_XLEN:0]              exu_alu_operand1_s;
  logic [L_XLEN:0]              exu_alu_operand0_u;
  logic [L_XLEN:0]              exu_alu_operand1_u;
  logic [L_XLEN:0]              mul_mp;
  logic [L_XLEN:0]              mul_mc;
  logic [L_XLEN:0]              mulh_mp;
  logic [L_XLEN:0]              mulh_mc;
  
  logic [L_XLEN-1:0]            div_result;
  logic [1:0]                   operand_sign_det;
  
  logic [L_XLEN-1:0]            mul_div_cnt;
  logic [4:0]                   alu_op_sel_int;
  
  logic                         div_finish;
  logic                         mul_finish;
  logic                         slow_mul_ack;
  logic                         start_mul;
  logic                         start_slow_mul;
  
  logic [L_XLEN-1:0]            dividend;
  logic [L_XLEN-1:0]            quotient;
  logic                         start_div;
  logic                         res_pos_neg;
  logic                         div_ack;
    
  logic [(L_XLEN*2)-1:0]        exu_alu_result_sel; 
  logic                         exu_mux_result_valid_sel; 
  
  logic [(L_XLEN*2)-2:0]        next_dividend_int;
  logic [(L_XLEN*2)-2:0]        dividend_int;
  
  
// Internal nets

//********************************************************************************
// Assignments
//********************************************************************************
  assign exu_result_reg[L_XLEN-1:0] = exu_result_reg_int[L_XLEN-1:0];

  generate
  if(cfg_fast_mul) begin : fast_mul
      assign exu_alu_operand0_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand0_u       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_u       = {L_XLEN+1{1'b0}};
      assign mul_mc                   = {L_XLEN+1{1'b0}};
      assign mul_mp                   = {L_XLEN+1{1'b0}};
      assign mulh_mc                  = {L_XLEN+1{1'b0}};
      assign mulh_mp                  = {L_XLEN+1{1'b0}};
      assign operand_sign_det         = 2'b0;
      assign start_slow_mul           = 1'b0;
      assign start_mul                = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1          | alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1 | 
                                                                                            alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 | alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1));

      assign exu_mux_result_valid_sel = exu_alu_result_valid & mul_finish;
      assign alu_op_sel_int           = alu_op_sel;
      assign exu_alu_operand0_int     = {1'b0, exu_alu_operand0};
      assign exu_alu_operand1_int     = {1'b0, exu_alu_operand1};
      assign slow_mul_result          = {(L_XLEN*2){1'b0}};

      miv_rv32_mul #(.l_core_cfg_hw_macc_multiplier(l_core_cfg_hw_macc_multiplier)
	                  ) miv_rv32_mul_0 ( .clk          (clk),
                                           .resetn       (resetn),
                                           .data_in_0    (exu_alu_operand0),
                                           .data_in_1    (exu_alu_operand1),
                                           .start_mul    (start_mul),
                                           .mul_type     (alu_op_sel),
                                           .data_out     (exu_alu_result_sel),
                                           .valid_result (mul_finish)
         );

  end else if(cfg_slow_mul) begin: slow_mul
      assign exu_alu_operand0_s       = {exu_alu_operand0[L_XLEN-1], exu_alu_operand0[L_XLEN-1:0]};
      assign exu_alu_operand1_s       = {exu_alu_operand1[L_XLEN-1], exu_alu_operand1[L_XLEN-1:0]};
      assign exu_alu_operand0_u       = {1'b0, exu_alu_operand0[L_XLEN-1:0]};
      assign exu_alu_operand1_u       = {1'b0, exu_alu_operand1[L_XLEN-1:0]};
      assign mul_mc                   = (alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) ? mulh_mc : ((alu_op_sel == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1))  ? exu_alu_operand0_u : exu_alu_operand0_s;
      assign mul_mp                   = (alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) ? mulh_mp :  (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1)                                                                            ? exu_alu_operand1_s : exu_alu_operand1_u;
      assign mulh_mc                  = (operand_sign_det == 2'b00) ? exu_alu_operand1_u: (operand_sign_det == 2'b10) ? exu_alu_operand1_s:  (operand_sign_det == 2'b11) ? {{L_XLEN{1'b0}}, (~exu_alu_operand0[L_XLEN-1:0])+1} : exu_alu_operand0_s;
      assign mulh_mp                  = (operand_sign_det == 2'b00) ? exu_alu_operand0_u: (operand_sign_det == 2'b10) ? exu_alu_operand0_u:  (operand_sign_det == 2'b11) ? {{L_XLEN{1'b0}}, (~exu_alu_operand1[L_XLEN-1:0])+1} : exu_alu_operand1_u;
      assign start_slow_mul           = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_multiply_signed_op0_signed_op1          | alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1 | 
                                                                                            alu_op_sel == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 | alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1));
      assign start_mul                = 1'b0;
      assign slow_mul_result          = exu_result_reg_int[(L_XLEN*2)-1:0];
      assign exu_mux_result_valid_sel = (start_slow_mul & (mul_div_cnt[5] | exu_op_abort));  
      assign exu_alu_result_sel       = slow_mul_result;
      assign alu_op_sel_int           = (start_slow_mul & !mul_div_cnt[5]) ? exu_alu_op_add_op0_op1 : alu_op_sel;
      assign exu_alu_operand0_int     = (start_slow_mul) ? mul_mc                              : {1'b0, exu_alu_operand0};
      assign exu_alu_operand1_int     = (start_slow_mul) ? exu_result_reg_int[L_XLEN*2:L_XLEN] : {1'b0, exu_alu_operand1};
      assign mul_finish               = 1'b0;
      assign operand_sign_det[1]      = exu_alu_operand1[L_XLEN-1];
      assign operand_sign_det[0]      = exu_alu_operand0[L_XLEN-1]; 
  end else begin : no_mul
      assign exu_alu_operand0_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_s       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand0_u       = {L_XLEN+1{1'b0}};
      assign exu_alu_operand1_u       = {L_XLEN+1{1'b0}};
      assign mul_mc                   = {L_XLEN+1{1'b0}};
      assign mul_mp                   = {L_XLEN+1{1'b0}};
      assign mulh_mc                  = {L_XLEN+1{1'b0}};
      assign mulh_mp                  = {L_XLEN+1{1'b0}};
      assign operand_sign_det         = 2'b0;
      assign start_slow_mul           = 1'b0;
      assign start_mul                = 1'b0;
      assign alu_op_sel_int           = alu_op_sel;
      assign exu_alu_operand0_int     = exu_alu_operand0;
      assign exu_alu_operand1_int     = exu_alu_operand1;
      assign slow_mul_result          = {(L_XLEN*2){1'b0}};
      assign exu_mux_result_valid_sel = 1'b0;
      assign exu_alu_result_sel       = {(L_XLEN*2){1'b0}};
      assign mul_finish               = 1'b1;
  end
  endgenerate
  
  generate
  if(cfg_div_en) begin : div 
      assign dividend_int = { {(L_XLEN-2){1'b0}}, dividend };
      assign next_dividend_int = dividend_int - div_divisor;
      assign div_finish = ((start_div & (mul_div_cnt[5] | exu_op_abort))) ? 1'b1 : 1'b0;
      assign div_result = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1) | 
                           (alu_op_sel == exu_alu_op_divide_unsigned_op0_unsigned_op1)) ? (res_pos_neg ? -quotient : quotient) : (res_pos_neg ? -dividend : dividend);   
      assign start_div  = (exu_alu_operand0_valid & exu_alu_operand1_valid & (alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | 
                                                                              alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1 | 
                                                                              alu_op_sel == exu_alu_op_divide_unsigned_op0_unsigned_op1 |
                                                                              alu_op_sel == exu_alu_op_remainder_unsigned_op0_unsigned_op1));
  end else begin : no_div     
      assign dividend_int               = {(L_XLEN*2)-2{1'b0}};
      assign next_dividend_int          = {(L_XLEN*2)-2{1'b0}};
      assign div_finish                 = 1'b1;
      assign div_result                 = {L_XLEN{1'b0}};
      assign start_div                  = 1'b0;
  end
  endgenerate
  
//********************************************************************************
// Main code
//********************************************************************************

  // Adder/Logical Unit/Fast-multiplier/Fast-dividr operand multiplexors
  
    // exu_alu_operand0
  always @*
  begin
    case(alu_operand0_mux_sel)
      exu_op0_rs1 :
      begin
        exu_alu_operand0        = exu_operand_gpr_rs1;      
        exu_alu_operand0_valid  = exu_operand_gpr_rs1_valid;
      end
      exu_op0_pc : 
      begin
        exu_alu_operand0        = exu_operand_pc;      
        exu_alu_operand0_valid  = exu_operand_pc_valid;
      end
      default :
      begin
        exu_alu_operand0        = {L_XLEN{1'b0}};
        exu_alu_operand0_valid  = 1'b0;
      end
    endcase
  end
  
    // exu_alu_operand1
  always @*
  begin
    case(alu_operand1_mux_sel)
      exu_op1_rs2 :
      begin
        exu_alu_operand1        = exu_operand_gpr_rs2;      
        exu_alu_operand1_valid  = exu_operand_gpr_rs2_valid;
      end
      exu_op1_imm :
      begin
        exu_alu_operand1        = exu_operand_immediate;       
        exu_alu_operand1_valid  = exu_operand_immediate_valid;
      end
      exu_op1_lit4 :
      begin
        exu_alu_operand1        = 32'd4;     
        exu_alu_operand1_valid  = 1'b1;
      end
      exu_op1_lit2 :
      begin
        exu_alu_operand1        = 32'd2;     
        exu_alu_operand1_valid  = 1'b1;
      end
      default :
      begin
        exu_alu_operand1        = {L_XLEN{1'b0}};
        exu_alu_operand1_valid  = 1'b0;
      end
    endcase
  end
  
    // shifter_operand
  always @*
  begin
    case(shifter_operand_sel)
      shifter_operand_none :
      begin
        exu_shifter_operand        = {L_XLEN{1'b0}};
        exu_shifter_operand_valid  = 1'b1;
      end
      shifter_operand_rs1 :
      begin
        exu_shifter_operand        = exu_operand_gpr_rs1;      
        exu_shifter_operand_valid  = exu_operand_gpr_rs1_valid;
      end
      shifter_operand_rs2 :
      begin
        exu_shifter_operand        = exu_operand_gpr_rs2;     
        exu_shifter_operand_valid  = exu_operand_gpr_rs2_valid;
      end
      default :
      begin
        exu_shifter_operand        = {L_XLEN{1'b0}};
        exu_shifter_operand_valid  = 1'b0;
      end
    endcase
  end
  
    // shifter_places
  always @*
  begin
    case(shifter_unit_places_sel)
      shifter_places_operand_none :
      begin
        exu_shifter_places        = 0;
        exu_shifter_places_valid  = 1'b0;
      end
      shifter_places_operand_addr_byte :
      begin
        exu_shifter_places        = (addr_shift_bits == 2'b11) ? 24 : 
                                      (addr_shift_bits == 2'b10) ? 16 : 
                                        (addr_shift_bits == 2'b01) ? 8 : 0;                                         
        exu_shifter_places_valid  = addr_shift_bits_valid;
      end
      shifter_places_operand_addr_hword :
      begin
        exu_shifter_places        = (addr_shift_bits[1] == 1'b1) ? 16 : 0;                                         
        exu_shifter_places_valid  = addr_shift_bits_valid;
      end
      shifter_places_operand_rs2 :
      begin
        exu_shifter_places        = {{(L_XLEN-5){1'b0}}, exu_operand_gpr_rs2[4:0]};   
        exu_shifter_places_valid  = exu_operand_gpr_rs2_valid;
      end
      shifter_places_operand_imm :
      begin
        exu_shifter_places        = {{(L_XLEN-5){1'b0}}, exu_operand_immediate[4:0]};      
        exu_shifter_places_valid  = exu_operand_immediate_valid;
      end
      shifter_places_operand_noshift :
      begin
        exu_shifter_places        = 0;
        exu_shifter_places_valid  = 1'b1;
      end
      default :
      begin
        exu_shifter_places        = 0;
        exu_shifter_places_valid  = 1'b0;
      end
    endcase
  end

  // arithmetic/logical/shifter units and result multiplexor
  // REVISIT big simple case statement for now - optimize later
  // REVISIT compare results currently computed inline, change to subtract and compute flags

  always @*
  begin
    case(alu_op_sel_int)
      exu_alu_op_none :
      begin
        exu_alu_result        = {L_XLEN+1{1'b0}};
        exu_alu_result_valid  = 1'b0;
        exu_alu_ready         = 1'b1; 
      end
      exu_alu_op_add_op0_op1 :
      begin
        exu_alu_result        = exu_alu_operand0_int + exu_alu_operand1_int;
        exu_alu_result_valid  = exu_alu_operand0_valid & exu_alu_operand1_valid;        
        exu_alu_ready         = exu_result_ready;
      end
      exu_alu_op_sub_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 - exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;               
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_xor_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 ^ exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;               
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_or_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 | exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_and_op0_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_operand0 & exu_alu_operand1;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_multiply_signed_op0_signed_op1 :
      begin  
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[L_XLEN-1:0];
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_multiply_high_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      //exu_alu_op_multiply_unsigned_op0_unsigned_op1 :
      //begin
      //  exu_alu_result[L_XLEN]     = 1'b0;
      //  exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[L_XLEN-1:0] 
      //  exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
      //  exu_alu_ready              = exu_result_ready;
      //end
      exu_alu_op_multiply_high_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      //exu_alu_op_multiply_signed_op0_unsigned_op1 :
      //begin
      //  exu_alu_result[L_XLEN]     = 1'b0;
      //  exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
      //  exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
      //  exu_alu_ready              = exu_result_ready;
      //end
      exu_alu_op_multiply_high_signed_op0_unsigned_op1 :
      begin 
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = exu_alu_result_sel[(L_XLEN*2)-1:L_XLEN];
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_alu_op_divide_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = div_finish;
      end
      exu_alu_op_divide_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;
        exu_alu_ready              = div_finish;
      end
      exu_alu_op_remainder_signed_op0_signed_op1 :
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = div_finish;
      end
      exu_alu_op_remainder_unsigned_op0_unsigned_op1 : 
      begin
        exu_alu_result[L_XLEN]     = 1'b0;
        exu_alu_result[L_XLEN-1:0] = div_result;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = div_finish;
      end      
      exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) < $unsigned(exu_alu_operand1)) ? 33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_lt_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) < $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_gte_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) >= $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_gte_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) >= $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_equal_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) == $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_equal_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) == $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_not_equal_signed_op0_signed_op1 :
      begin
        exu_alu_result             = ($signed(exu_alu_operand0) != $signed(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      exu_cmp_op_compare_not_equal_unsigned_op0_unsigned_op1 :
      begin
        exu_alu_result             = ($unsigned(exu_alu_operand0) != $unsigned(exu_alu_operand1)) ?  33'd1 : 33'd0;
        exu_alu_result_valid       = exu_alu_operand0_valid & exu_alu_operand1_valid;       
        exu_alu_ready              = exu_result_ready;
      end
      default :
      begin
        exu_alu_result             = {L_XLEN+1{1'b0}};
        exu_alu_result_valid       = 1'b0;       
        exu_alu_ready              = 1'b1;
      end
    endcase
  end
  
  // Shift unit
  
  assign addr_shift_bits        = exu_operand_gpr_rs1[1:0] + exu_operand_immediate[1:0];
  assign addr_shift_bits_valid  = exu_operand_gpr_rs1_valid & exu_operand_immediate_valid;
  
  logic [(L_XLEN*2)-1:0]  tmp_ls_operand0;
  logic [(L_XLEN*2)-1:0]  tmp_ms_operand0;
  logic [(L_XLEN*2)-1:0]  tmp_ls_operand0_signed;
  assign tmp_ls_operand0        = {{L_XLEN{1'b0}},exu_shifter_operand} ;
  assign tmp_ms_operand0        = {exu_shifter_operand,{L_XLEN{1'b0}}} ;
  assign tmp_ls_operand0_signed = {{L_XLEN{exu_shifter_operand[L_XLEN-1]}},exu_shifter_operand} ;
  
  always @*
  begin
    case(shifter_unit_op_sel)
    
      exu_shifter_op_none :
      begin
        shifter_result        = {L_XLEN{1'b0}};
        shifter_result_valid  = 1'b0;
        exu_shifter_ready     = 1'b1;
      end
      exu_shifter_op_shift_left : 
      begin
        shifter_result        = tmp_ms_operand0[(((L_XLEN*2)-1) - exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = lsu_align_result_ready & exu_result_ready;  // only shift left used for lsu
      end 
      exu_shifter_op_shift_right :  
      begin
        shifter_result        = tmp_ls_operand0[((L_XLEN-1) + exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = exu_result_ready;
      end   
      exu_shifter_op_arithmetic_shift_right :
      begin
        shifter_result        = tmp_ls_operand0_signed[((L_XLEN-1) + exu_shifter_places) -: L_XLEN];
        shifter_result_valid  = exu_shifter_operand_valid & exu_shifter_places_valid;
        exu_shifter_ready     = exu_result_ready;
      end      
      default
      begin
        shifter_result        = {L_XLEN{1'b0}};
        shifter_result_valid  = 1'b0;
        exu_shifter_ready     = 1'b1;
      end 
    endcase
  end

  
  
  // result mux and register stage - REVISIT no register in core yet until multicycle ops added
  
  
  always @*
  begin
    case(exu_result_mux_sel)
      exu_alu_result_mux_none :
      begin
        exu_mux_result          = {L_XLEN{1'b0}}; 
        exu_mux_result_valid    = 1'b0;
      end
      exu_alu_result_mux_cmp_lit :      // REVISIT computed directly for now, but eventually generate from adder result flags
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_shifter :
      begin
        exu_mux_result          = shifter_result;      
        exu_mux_result_valid    = shifter_result_valid;
      end
      exu_alu_result_mux_adder :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_logical :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_alu_result_valid;
      end
      exu_alu_result_mux_multiplier :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    = exu_mux_result_valid_sel;
      end
      exu_alu_result_mux_divider :
      begin
        exu_mux_result          = exu_alu_result[L_XLEN-1:0];
        exu_mux_result_valid    =  div_finish;
      end
      exu_alu_result_mux_acu :   
      begin
        exu_mux_result          = acu_result;
        exu_mux_result_valid    = acu_result_valid;
      end
      default :
      begin
        exu_mux_result          = {L_XLEN{1'b0}};
        exu_mux_result_valid    = 1'b0;
      end
    endcase
  end
  
  assign exu_mux_result_flags.cmp_cond = exu_alu_result[0];


  // Assign outputs
  
  assign exu_op_ready             = exu_alu_ready & exu_shifter_ready;
  
  assign exu_result               = exu_mux_result;      
  assign exu_result_valid         = exu_mux_result_valid; 
  assign exu_result_flags         = exu_mux_result_flags;
  assign lsu_align_result         = shifter_result;      
  assign lsu_align_result_valid   = shifter_result_valid;
  
  generate if (!(l_core_cfg_debug_reg_ctrl_pipeline & l_core_cfg_hw_debug)) 
  begin : gen_debug_dbg_wrdata_no_pipeline
    assign exu_mux_result_dbgsel        = {{L_XLEN+1{1'b0}}, exu_mux_result};
    assign exu_mux_result_valid_dbgsel  = exu_mux_result_valid;
  end else 
  begin : gen_debug_dbg_wrdata_pipeline 
    assign exu_mux_result_dbgsel        = debug_mode ? {{L_XLEN+1{1'b0}}, debug_wr_data} : {{L_XLEN+1{1'b0}}, exu_mux_result}; 
    assign exu_mux_result_valid_dbgsel  = debug_mode ? debug_wr_data_valid : exu_mux_result_valid;
  end
  endgenerate   
  


  // Multiplier / Divider
  
  logic [(L_XLEN*2):0]          next_exu_result_reg_int;
  logic                         next_slow_mul_ack;      
  logic [L_XLEN-1:0]            next_mul_cnt;  
  logic [L_XLEN-1:0]            next_div_cnt; 
  logic                         next_div_ack;    
  logic [(L_XLEN*2)-2:0]        next_div_divisor;
  logic [L_XLEN-1:0]            next_dividend;   
  logic                         next_res_pos_neg;
  logic [L_XLEN-1:0]            next_quotient;             
  
  // multiplier next state
  always @*
  begin
  
    //defaults
    next_exu_result_reg_int = exu_result_reg_int;
    next_slow_mul_ack       = slow_mul_ack;
    next_mul_cnt            = mul_div_cnt;
      
    if (~debug_mode & (start_slow_mul & (!mul_div_cnt[5] & !exu_op_abort))) 
    begin
      if (!slow_mul_ack) 
      begin
        next_exu_result_reg_int  = {(L_XLEN*2)+1{1'b0}};
        next_slow_mul_ack        = 1'b1;
        next_mul_cnt             = {L_XLEN{1'b0}};
      end else 
      begin
        next_exu_result_reg_int[(L_XLEN*2)]      = mul_mp[mul_div_cnt] ? (((alu_op_sel == exu_alu_op_multiply_high_signed_op0_signed_op1) |  
                                                                          (alu_op_sel == exu_alu_op_multiply_high_signed_op0_unsigned_op1)) ? exu_alu_result[L_XLEN] : 1'b0) : 
                                                                          exu_result_reg_int[(L_XLEN*2)];                
        next_exu_result_reg_int[(L_XLEN*2)-1:0]  = mul_mp[mul_div_cnt] ? {exu_alu_result, exu_result_reg_int[L_XLEN-1:0]} >> 1 :                                                                          
                                                                          exu_result_reg_int[(L_XLEN*2):1];    
        next_slow_mul_ack                        = slow_mul_ack;
        next_mul_cnt                             = mul_div_cnt + 1;
      end
    end else if(update_result_reg | exu_op_abort) 
    begin
      next_exu_result_reg_int = exu_mux_result_dbgsel;   
      next_slow_mul_ack       = 1'b0;
      next_mul_cnt            = {L_XLEN{1'b0}};    
    end 
  end
  
  // divider next state
  always @*
  begin
  
    // defaults
    next_div_ack      = div_ack;
    next_div_divisor  = div_divisor; 
    next_dividend     = dividend;    
    next_res_pos_neg  = res_pos_neg; 
    next_quotient     = quotient;    
    next_div_cnt      = mul_div_cnt;
  
    if(~debug_mode & (start_div & (!mul_div_cnt[5] & !exu_op_abort))) 
    begin
      if(!div_ack) begin
        next_div_divisor = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand1[L_XLEN-1] ? -exu_alu_operand1 : exu_alu_operand1) << L_XLEN-1;
        next_dividend    =  (alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1 | alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand0[L_XLEN-1] ? -exu_alu_operand0 : exu_alu_operand0;                  
        next_res_pos_neg = ((alu_op_sel == exu_alu_op_divide_signed_op0_signed_op1) & (exu_alu_operand0[L_XLEN-1] != exu_alu_operand1[L_XLEN-1]) & |exu_alu_operand1) | ((alu_op_sel == exu_alu_op_remainder_signed_op0_signed_op1) & exu_alu_operand0[L_XLEN-1]);
        next_quotient    = {L_XLEN{1'b0}};
        next_div_ack     = 1'b1;
        next_div_cnt     = {L_XLEN{1'b0}};   
      end else 
      begin
        if (div_divisor <= {{L_XLEN-1{1'b0}}, dividend}) 
        begin
          next_dividend                          = next_dividend_int[L_XLEN-1:0];
          next_quotient[(L_XLEN-1)-mul_div_cnt]  = 1'b1;
        end         
        next_div_divisor  = div_divisor[(L_XLEN*2)-2:0] >> 1; 
        next_div_cnt      = mul_div_cnt + 1;
      end
    end else if(update_result_reg | exu_op_abort) 
    begin
      next_div_ack       = 1'b0;
      next_div_cnt       = {L_XLEN{1'b0}};    
    end 
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      mul_div_cnt        <= {L_XLEN{1'b0}};      
    else   
      mul_div_cnt        <= start_slow_mul ? next_mul_cnt : next_div_cnt;                 
  end 
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      slow_mul_ack       <= 1'b0;     
    else
      slow_mul_ack       <= next_slow_mul_ack;                
  end 
  

  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      div_ack            <= 1'b0;     
    else 
      div_ack            <= next_div_ack;                   
  end 
  
  always @(posedge clk)
  begin
    div_divisor  <= next_div_divisor;
    dividend     <= next_dividend;   
    res_pos_neg  <= next_res_pos_neg;
    quotient     <= next_quotient;          
  end 
  
    
  // output register

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      exu_result_reg_valid <= 1'b0;
    else
      if(update_result_reg)
        exu_result_reg_valid <= exu_mux_result_valid_dbgsel;
  end 
  
  always @(posedge clk)
  begin
    exu_result_reg_int <= next_exu_result_reg_int;               
  end 



//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

   //-------------                                                              
   // covers
   //------------
   
   // helper (stepping-stone/guidepoint) covers for multicycle ops 
   
  localparam MAX_MULT_DIV_STEPS = L_XLEN+1;  
   
  genvar i_cover_muldiv_seq;
  generate
  for (i_cover_muldiv_seq = 0; i_cover_muldiv_seq < MAX_MULT_DIV_STEPS; i_cover_muldiv_seq++) 
  begin : gen_cover_muldiv_seq   
  
    if(cfg_slow_mul | cfg_div_en) 
    begin : gen_mul_div_step_cov
      cover_exu_mult_cnt: cover property (@(posedge clk) disable iff (~resetn)
                                             start_slow_mul & (mul_div_cnt == i_cover_muldiv_seq[L_XLEN-1:0]));
                                             
      cover_exu_div_cnt: cover property (@(posedge clk) disable iff (~resetn)
                                             start_div & (mul_div_cnt == i_cover_muldiv_seq[L_XLEN-1:0]));                                       
    end // end if-generate
  
  end 
  endgenerate                                                                          
                                        
`endif   

 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File:
//   miv_rv32_exu.sv
//
//   Purpose:
//   Execution unit for core
//   
//
//
//   Author: $Author:  $
//
//   Version: $Revision:  $
//
//   Date: $Date:  $
//
//   Revision History:
// 
//   Revision:
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////

`default_nettype none

import miv_rv32_pkg::*;
import miv_rv32_core_cfg_pkg::*;

module miv_rv32_mul
  //****************************************************************************
  // Parameter description 
  #(
    parameter l_core_cfg_hw_macc_multiplier = 0
   )
//********************************************************************************
// Port description

  (
    //inputs
    input wire  logic                   clk,
    input wire  logic                   resetn,
    input wire  signed [L_XLEN-1:0]     data_in_0,
    input wire  signed [L_XLEN-1:0]     data_in_1,
    input wire  logic                   start_mul,
    input wire  t_exu_alu_op_sel        mul_type,
            
    //outputs
    output logic signed[(L_XLEN*2)-1:0] data_out /* synthesis syn_multstyle="dsp" */,
    output logic                        valid_result

   );
   
   localparam [0:0] l_core_cfg_macc_reg = (l_core_cfg_hw_macc_multiplier == 2) ? 1 : 0;
   logic start_mul_ack;
   
 generate
  if(l_core_cfg_macc_reg == 1) begin : gen_reg_macc
    logic [(L_XLEN*2)-1:0] in_reg0, in_reg1;
   
    always @ (posedge clk) begin
        if (!resetn) begin
            start_mul_ack <= 1'b0;
            valid_result  <= 1'b0;
            in_reg0       <= {L_XLEN{1'b0}};
            in_reg1       <= {L_XLEN{1'b0}};
        end else begin
            start_mul_ack <= start_mul;
            in_reg0       <= (((mul_type == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (mul_type == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1)) ? $signed({1'b0, data_in_0})  : $signed( data_in_0));
            in_reg1       <= (((mul_type == exu_alu_op_multiply_signed_op0_signed_op1)     | (mul_type == exu_alu_op_multiply_high_signed_op0_signed_op1))     ? $signed(data_in_1)          : $signed({1'b0, data_in_1}));

            if(start_mul_ack) begin
                valid_result <= 1'b0;
            end else begin
                valid_result <= start_mul;
            end       
        end
    end
  
    assign data_out = in_reg0 * in_reg1;
    
  end else begin: gen_macc
    assign start_mul_ack = 1'b0;
    assign valid_result = start_mul;
    assign data_out     = (((mul_type == exu_alu_op_multiply_unsigned_op0_unsigned_op1) | (mul_type == exu_alu_op_multiply_high_unsigned_op0_unsigned_op1)) ? $signed({1'b0, data_in_0})  : $signed( data_in_0))  * 
                          (((mul_type == exu_alu_op_multiply_signed_op0_signed_op1)     | (mul_type == exu_alu_op_multiply_high_signed_op0_signed_op1))     ? $signed(data_in_1)          : $signed({1'b0, data_in_1}));

  end
endgenerate

endmodule

`default_nettype wire




// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_fetch_unit.sv
//
//   Purpose: Fetch unit for core CPU.
//            Includes instruction pointer, fetch buffer/queue, and bus interface
//
//            Accepts request (instruction pointer) from control piplene (expipe) and returns the instruction
//            performing buffering and alignment as required to deal with misaligned and compressed instructions
//            in any arbritrary mix
//
//        
//           
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_core_cfg_pkg::*;

module miv_rv32_fetch_unit
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH           = 32,
	parameter l_core_reset_vector = 32'h6000_0000
   )
  
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,
  input  wire logic                                resetn,
  
  input  wire logic                                parity_en,
  
  // external memory bus interface
  output      logic                                ifu_emi_req_valid,
  input wire  logic                                ifu_emi_req_ready, 
  output      logic[3:0]                           ifu_emi_req_rd_byte_en,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_emi_req_addr,
  output      logic                                ifu_emi_req_addr_p,
  
  input wire  logic                                ifu_emi_resp_valid,
  output      logic                                ifu_emi_resp_ready,
  input wire  logic [31:0]                         ifu_emi_resp_data,
  input wire  logic [3:0]                          ifu_emi_resp_data_p,   
  input wire  logic                                ifu_emi_resp_error,
  
  // internal core pipeline (expipe) interface      

  input wire  logic                                ifu_expipe_fetch_en,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_valid,
  input wire  logic                                ifu_expipe_req_branch_excpt_req_fenci,
  input wire  logic                                ifu_expipe_req_fenci_proceed,
  output      logic                                ifu_expipe_req_branch_excpt_req_ready, 
  input wire  logic [I_ADDR_WIDTH-1:0]             ifu_expipe_req_branch_excpt_vaddr, 
  input wire  logic [1:0]                          ifu_expipe_req_priv, 
  input wire  logic                                ifu_expipe_req_flush,
   
  output      logic                                ifu_expipe_resp_valid,
  input wire  logic                                ifu_expipe_resp_ready,
  output      logic [31:0]                         ifu_expipe_resp_ireg,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_ireg_vaddr,
  output      logic                                ifu_expipe_resp_ireg_vaddr_valid,
  output      logic[I_ADDR_WIDTH-1:0]              ifu_expipe_resp_next_vaddr,
  output      logic                                ifu_expipe_resp_compressed,
  output      logic                                ifu_expipe_resp_access_fault,  
  output      logic                                ifu_expipe_resp_access_mem_error,
  output      logic                                ifu_expipe_resp_access_parity_error,
  output      logic                                ifu_expipe_resp_access_misalign_error,
  output      logic                                ifu_expipe_resp_access_aborted  
  );
   

  
//******************************************************************************
// Declarations


  typedef enum logic [1:0] {fetch_ptr_sel_reset,
                            fetch_ptr_sel_branch,
                            fetch_ptr_sel_incr4} t_fetch_ptr_sel;
                                                       
                            
  localparam IAB_BUFF_DEPTH       = 3;
  localparam LOG2_IAB_BUFF_DEPTH  = 2;  
  
  localparam MAX_IFU_EMI_OS       = 3;
  localparam LOG2_MAX_IFU_EMI_OS  = 2;
  
  localparam RESP_ERROR_WIDTH     = 2;  
  localparam IFU_MEM_ERROR_BIT    = 0;
  localparam IFU_PARITY_ERROR_BIT = 1;
  
  
  
  logic [3:0]                         bus_byte_parity;      
  logic                               ifu_emi_resp_parity_error;  
  
  t_iab_rd_alignment                  iab_rd_alignment;
  t_iab_rd_alignment                  last_iab_rd_alignment;
  t_iab_rd_alignment                  next_iab_rd_alignment;
  
  logic [I_ADDR_WIDTH-1:0]            iab_resp_addr;
  logic                               iab_resp_addr_valid;
  logic                               iab_resp_hword_high_only;  
  logic [31:0]                        iab_resp_data;
  logic [RESP_ERROR_WIDTH-1:0]        iab_resp_error;  
  logic [RESP_ERROR_WIDTH-1:0]        iab_alloc_error;
  
  logic                               emi_resp_head_compressed;                                     
  logic                               emi_resp_head_uncompressed_full;
  logic                               emi_resp_head_uncompressed_half;    
  logic                               iab_head_compressed;       
  logic                               iab_head_uncompressed_full;
  logic                               iab_head_uncompressed_half;                       

  t_fetch_ptr_sel                     fetch_ptr_sel; 
  logic [I_ADDR_WIDTH-1:0]            req_fetch_ptr;
  logic [I_ADDR_WIDTH-1:0]            next_req_fetch_ptr;
  logic                               next_req_fetch_ptr_valid;
  logic                               next_req_is_hword_high_only;  
  
  logic                               ifu_emi_req_accepted;
  logic                               ifu_emi_resp_accepted;
  
  logic                               emi_req_os;
  logic [LOG2_MAX_IFU_EMI_OS-1:0]     num_emi_req_os;
  logic                               req_flush;
  logic                               req_flush_branch;
  logic                               req_flush_pipe;  
  logic                               no_flush_req_os;
  logic                               iab_req_empty;
  logic                               iab_alloc_req;        
  logic                               iab_alloc_req_fence_i;
  logic                               iab_resp_alloc;  
  logic                               iab_resp_complete;      
  logic                               iab_resp_empty;  
  logic                               iab_ready;  
  
  logic [LOG2_IAB_BUFF_DEPTH-1:0]     buff_fill_level;  
  
  logic                               sticky_reset;
  logic                               sticky_reset_reg;   
  
  logic                               sticky_branch;
  logic                               sticky_branch_reg;
  
  logic                               fence_i_req;
  logic                               fence_i_hold;
  logic                               sticky_fence;
  logic                               sticky_fence_reg;
  logic                               branch_req_no_fence_i;
  logic                               branch_req_fence_i;
  

//******************************************************************************
// Main code


  assign ifu_expipe_req_branch_excpt_req_ready    = ((ifu_emi_req_ready & ifu_expipe_fetch_en) | ifu_expipe_req_branch_excpt_req_fenci) & iab_ready; 
  
  // compute bus parity. Instruction fetches are always 4-bytes
  
  assign bus_byte_parity  = {^ifu_emi_resp_data[31:24],
                             ^ifu_emi_resp_data[23:16],
                             ^ifu_emi_resp_data[15:8],
                             ^ifu_emi_resp_data[7:0]};
                             
  assign ifu_emi_resp_parity_error = ifu_emi_resp_valid & 
                            (bus_byte_parity != ifu_emi_resp_data_p) &
                            parity_en;
  
  

  

  // fetch pointer is the virtual address of the word currently being returned from memory
  // need to identify responses that are for a high halfword only (caused by a hword aligned branch target)  
  
  // To save area, the fetch_ptr holds the address of the outstanding request rather than the next request
  // (because need to return the address of the outstanding request later to the expipe)
  // After reset, need to ensure that the current fetch address (indicated buy next_fetch_ptr) is 
  // the reset vector, and not reset_vector+4,so need to make the reset sticky and force selection of
  // reset_vector. A branch cannot occur after reset because there should not be any valid instruction in the ex_retr stage
  // so ok to be lower priority.
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_reset_reg <= 1'b1;
    else
      sticky_reset_reg <= sticky_reset_reg  & ~ifu_emi_req_accepted;
  end
  
  assign sticky_reset = sticky_reset_reg; 
  
  // After a branch, need to ensure that the current fetch address (indicated buy next_fetch_ptr) is 
  // the branch target, and not branch target+4,so need to make the branch request sticky and force selection of
  // branch target. 
  // Also force the selection to be branch when flushing, since to resume after a flush a branch must always be taken
  // this prevents spurious fetches occuring after a flush that are then subsequently dropped.
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_branch_reg <= 1'b0;
    else
      sticky_branch_reg <= (sticky_branch_reg | branch_req_no_fence_i | ifu_expipe_req_flush) & ~(ifu_emi_req_accepted) ;
  end
  
  assign sticky_branch = sticky_branch_reg; 
  
  // If the branch is for a fence.i instruction (branches to the next instruction after the fence.i instruction in order to cause a pipeline/iab flush)
  // then need to wait until all memory accesses are complete before fetching by isuuing a FENCE operation and waiting for the response before issuing the fetch
  // The expipe will indicate the fence has completed and fetch request can proceed by asserting ifu_expipe_req_fenci_proceed
  // If a trap or reset occurs before the fence completes (can occur as the branch request is issued in the ex stage, and the instruction in retr may trap) then the
  // fence_i hold will be released immediately and piepline flushed as usual.
  
  assign fence_i_req            = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_fenci;
  assign branch_req_no_fence_i  = ifu_expipe_req_branch_excpt_req_valid & ~ifu_expipe_req_branch_excpt_req_fenci;
  assign branch_req_fence_i     = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_fenci;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      fence_i_hold <= 1'b0;
    else
      fence_i_hold <= (fence_i_hold | fence_i_req) & ~(ifu_expipe_req_fenci_proceed | ifu_expipe_req_flush);
  end
  
  // first fetch after fence needs to use the full address to determine if the first fetch is high halfword only
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      sticky_fence_reg <= 1'b0;
    else
      sticky_fence_reg <= (sticky_fence_reg | branch_req_fence_i) & ~(ifu_emi_req_accepted | ifu_expipe_req_flush) ;
  end
  
  assign sticky_fence = sticky_fence_reg;
  


  assign ifu_emi_req_accepted = ifu_emi_req_ready & ifu_emi_req_valid; 
  assign fetch_ptr_sel = sticky_reset ? fetch_ptr_sel_reset :
                             ifu_expipe_req_branch_excpt_req_valid ? fetch_ptr_sel_branch : 
                                 sticky_branch ? fetch_ptr_sel_branch :                             
                                     fetch_ptr_sel_incr4;                                         
                            
  
  always @* 
  begin
    case(fetch_ptr_sel)
      fetch_ptr_sel_reset:  
      begin
        next_req_fetch_ptr          = l_core_reset_vector;
        next_req_fetch_ptr_valid    = 1'b1;
        next_req_is_hword_high_only = 1'b0;
      end
      
      fetch_ptr_sel_branch: 
      begin
        next_req_fetch_ptr          = ifu_expipe_req_branch_excpt_vaddr;
        next_req_fetch_ptr_valid    = ifu_expipe_req_branch_excpt_req_valid;
        next_req_is_hword_high_only = ifu_expipe_req_branch_excpt_vaddr[1];
      end
      
      fetch_ptr_sel_incr4:  
      begin
        next_req_fetch_ptr          = req_fetch_ptr + {{I_ADDR_WIDTH-3{1'b0}},3'd4};
        next_req_fetch_ptr_valid    = 1'b1;
        next_req_is_hword_high_only = sticky_fence ? req_fetch_ptr[1] : 1'b0;
      end
      
      default:              
      begin
        next_req_fetch_ptr          = l_core_reset_vector;
        next_req_fetch_ptr_valid    = 1'b0;
        next_req_is_hword_high_only = 1'b0;
      end
    endcase
  end
  
  // Can generate a request when there is space for any outstanding requests to be allocated
  // Use > rather than >= because if this cycle generates a request it is not yet accounted for
  //assign iab_ready = (IAB_BUFF_DEPTH - buff_fill_level) > num_emi_req_os;
  //assign iab_ready = (buff_fill_level <= (IAB_BUFF_DEPTH - 1));  // need space for any requests currently outstanding to the EMI 
  assign iab_ready = (buff_fill_level <= (IAB_BUFF_DEPTH - 1)) & (num_emi_req_os < MAX_IFU_EMI_OS);

  assign ifu_emi_req_valid      = ifu_expipe_fetch_en & iab_ready & next_req_fetch_ptr_valid  & ~(fence_i_hold | fence_i_req); 
  assign ifu_emi_req_addr       = {next_req_fetch_ptr[I_ADDR_WIDTH-1:2],2'b00}; //always word aligned
  assign ifu_emi_req_addr_p     = (^ifu_emi_req_addr) & parity_en;
  assign ifu_emi_req_rd_byte_en = {4{ifu_emi_req_valid}}; 
  
  assign ifu_emi_resp_ready                 = 1'b1; // When a request is made it will always be accepted
  
  assign emi_resp_head_compressed           = (iab_rd_alignment == iab_rd_alignment_hword) ? (ifu_emi_resp_data[17:16] != 2'b11) : 
                                                                                             (ifu_emi_resp_data[1:0] != 2'b11);  
  assign emi_resp_head_uncompressed_full    = (iab_rd_alignment == iab_rd_alignment_word) & (ifu_emi_resp_data[1:0] == 2'b11);
  assign emi_resp_head_uncompressed_half    = (iab_rd_alignment == iab_rd_alignment_hword) & (ifu_emi_resp_data[17:16] == 2'b11);
  
  // if a flush is required due to reset or branch/exception taken/reset taken, need to drop any outstanding requests
  // and make the next fetch request the reset vector or branch/exception target (this is currently done by forcing a branch 
  //to the trap/reset vector in the decode stage)
  // Since a request made could still be in flight, need to wait for the memory response, but not return it to the expipe
  // flush is not used to block requests in the current cycle since it may be generated late in the cycle, therefore if a 
  // a request is being made when flush is asserted, drop the associated response
  // 
  // Need to also drop any responses made by requests prior to the branch or reset but not yet allocated.
  // Note that core supports same cycle responses, as well as pipelined req-resp (though only one non-completing outstanding).
  // fence.i also requires instructions in the pipline to be flushed (as they could have been written)
  // this will be performed by executiong a branch to the next instruction following the fence.i so that the
  // same mechanism as a branch taken can be used.
  // iab will also drop spurious responses. These may occur after a reset; this prevents deadlock
  
  assign req_flush_branch = ifu_expipe_req_branch_excpt_req_valid; 
  assign req_flush_pipe   = ifu_expipe_req_flush; 
  assign req_flush        = req_flush_branch | req_flush_pipe;

  // Instruction alignment buffer holds responses from the EMI until they are accepted by the expipe.
  // The IAB also aligns compressed instructions and responses that span 2 fetches and compressed instructions
  
  assign ifu_emi_resp_accepted  = ifu_emi_resp_valid & ifu_emi_resp_ready;
  
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      last_iab_rd_alignment <= iab_rd_alignment_word;
    else
      if(req_flush)
        last_iab_rd_alignment <= next_req_fetch_ptr[1] ? iab_rd_alignment_hword : iab_rd_alignment_word;
      else if (ifu_expipe_resp_valid & ifu_expipe_resp_ready)
        last_iab_rd_alignment <= next_iab_rd_alignment;
  end
  
  assign iab_rd_alignment = iab_resp_hword_high_only ? iab_rd_alignment_hword : last_iab_rd_alignment;
  
  // if there is somesthing in the iab, the response must come from the iab (partially or fully)\
  // otherwise can come directly from the response.
  // For uncompressed requests that span word, the first part may come from the iab and the other from the response directly       
  // Seperate allocation controls from response controls to removing expipe ready timing path
  always @*
  begin
    case({ifu_emi_resp_accepted, ifu_expipe_resp_ready, iab_resp_empty})

      3'b000,3'b001 : // EMI no new response, expipe not ready
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = 1'b0; 
        next_iab_rd_alignment                 = iab_rd_alignment;      
      end
      
      3'b010 : // EMI no new response, expipe ready,    iab not empty (responses available in iab)
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = ~((iab_head_compressed & (iab_rd_alignment == iab_rd_alignment_word)) | 
                                                  iab_head_uncompressed_half);      
        next_iab_rd_alignment                 = iab_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                      iab_rd_alignment_word) : 
                                                                      iab_rd_alignment;       
      end
      
      3'b100,3'b101 : // EMI new response,    expipe not ready
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = 1'b0;     
        next_iab_rd_alignment                 = iab_rd_alignment;
      end     
    
      3'b110 : // EMI new response,    expipe ready,    iab not empty (responses available in iab)
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = ~(iab_head_compressed & (iab_rd_alignment == iab_rd_alignment_word));  
        next_iab_rd_alignment                 = iab_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                      iab_rd_alignment_word) : 
                                                                      iab_rd_alignment;      
      end      
      
      3'b111 : // EMI new response,    expipe ready,    iab empty (no responses available in iab)
      begin
        iab_resp_alloc                        = emi_req_os;  // Always allocated  if there is an expected emi resp outstanding (ie ignore spurious responses)
        iab_resp_complete                     = ~((emi_resp_head_compressed & (iab_rd_alignment == iab_rd_alignment_word)) | emi_resp_head_uncompressed_half);  
        next_iab_rd_alignment                 = emi_resp_head_compressed ? ((iab_rd_alignment == iab_rd_alignment_word) ?  iab_rd_alignment_hword : 
                                                                                                                           iab_rd_alignment_word) : 
                                                                           iab_rd_alignment; 
      end                                       
  
      default :
      begin
        iab_resp_alloc                        = 1'b0;
        iab_resp_complete                     = 1'b0;  
        next_iab_rd_alignment                 = iab_rd_alignment; 
      end
    endcase
  end
  
  always @*
  begin
    case({ifu_emi_resp_accepted, iab_resp_empty})

      
      2'b00 : // EMI no new response,   iab not empty (responses available in iab)
      begin
        ifu_expipe_resp_valid                 = (iab_head_compressed | iab_head_uncompressed_full) & no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = iab_resp_data;
        ifu_expipe_resp_compressed            = iab_head_compressed;
        ifu_expipe_resp_access_mem_error      = iab_resp_error[IFU_MEM_ERROR_BIT];
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = iab_resp_error[IFU_PARITY_ERROR_BIT];        
        ifu_expipe_resp_access_aborted        = 1'b0;
        
      end
     
    
      2'b10 : // EMI new response,      iab not empty (responses available in iab)
      begin   
        ifu_expipe_resp_valid                 = no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = iab_head_uncompressed_half ? {ifu_emi_resp_data[15:0],iab_resp_data[15:0]} : iab_resp_data;
        ifu_expipe_resp_compressed            = iab_head_compressed;
        ifu_expipe_resp_access_mem_error      = iab_head_uncompressed_half ? (ifu_emi_resp_error | iab_resp_error[IFU_MEM_ERROR_BIT]): iab_resp_error[IFU_MEM_ERROR_BIT];
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = iab_head_uncompressed_half ? (ifu_emi_resp_parity_error | iab_resp_error[IFU_PARITY_ERROR_BIT]): iab_resp_error[IFU_PARITY_ERROR_BIT];
        ifu_expipe_resp_access_aborted        = 1'b0;
      end      
      
      2'b11 : // EMI new response,      iab empty (no responses available in iab)
      begin 
        ifu_expipe_resp_valid                 = (emi_resp_head_compressed | emi_resp_head_uncompressed_full) & no_flush_req_os & ~req_flush;
        ifu_expipe_resp_ireg                  = emi_resp_head_uncompressed_full ? ifu_emi_resp_data :
                                                                                  iab_resp_hword_high_only ? {{16{1'b0}},ifu_emi_resp_data[31:16]} :
                                                                                                             {{16{1'b0}},ifu_emi_resp_data[15:0]};
        ifu_expipe_resp_compressed            = emi_resp_head_compressed;
        ifu_expipe_resp_access_mem_error      = ifu_emi_resp_error;
        ifu_expipe_resp_access_misalign_error = iab_resp_addr[0]; 
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = ifu_emi_resp_parity_error;
        ifu_expipe_resp_access_aborted        = 1'b0;
      end                                       
  
      default :
      begin
        ifu_expipe_resp_valid                 = 1'b0;
        ifu_expipe_resp_ireg                  = {32{1'b0}};
        ifu_expipe_resp_compressed            = 1'b0;
        ifu_expipe_resp_access_mem_error      = 1'b0;
        ifu_expipe_resp_access_misalign_error = 1'b0;
        ifu_expipe_resp_access_fault          = 1'b0;
        ifu_expipe_resp_access_parity_error   = 1'b0;
        ifu_expipe_resp_access_aborted        = 1'b0;
      end
    endcase
  end
  
  assign ifu_expipe_resp_ireg_vaddr       = {iab_resp_addr[I_ADDR_WIDTH-1:2],(iab_rd_alignment == iab_rd_alignment_hword),iab_resp_addr[0]};
  assign ifu_expipe_resp_ireg_vaddr_valid = iab_resp_addr_valid;
  
  assign ifu_expipe_resp_next_vaddr       = (iab_req_empty | ifu_expipe_req_branch_excpt_req_valid)? next_req_fetch_ptr : 
                                                 {iab_resp_addr[I_ADDR_WIDTH-1:2],(iab_rd_alignment == iab_rd_alignment_hword),iab_resp_addr[0]};

  // allocate the branch request as part of fence.i to the aib 
  // before the request is accepted (unlike all other iab allocations which occur
  // when the emi accepts the request)
  // This then allows the request to be generated as an incremental request(fetch_ptr+4)
  assign iab_alloc_req         = ifu_emi_req_accepted | fence_i_req;
  assign iab_alloc_req_fence_i = fence_i_req;
  
  assign iab_alloc_error[IFU_MEM_ERROR_BIT]    = ifu_emi_resp_error;
  assign iab_alloc_error[IFU_PARITY_ERROR_BIT] = ifu_emi_resp_parity_error;
  
  miv_rv32_ifu_iab
  #(
 
    .I_ADDR_WIDTH                      (I_ADDR_WIDTH        ),
    .RESP_ERROR_WIDTH                  (RESP_ERROR_WIDTH    ),
    .BUFF_DEPTH                        (IAB_BUFF_DEPTH      ),
    .LOG2_BUFF_DEPTH                   (LOG2_IAB_BUFF_DEPTH )
  )
  u_miv_rv32_ifu_iab_0
  (
    .clk                               (clk                        ),   
    .resetn                            (resetn                     ),   
    .req_flush_branch                  (req_flush_branch           ),   
    .req_flush_pipe                    (req_flush_pipe             ),  
    .alloc_req                         (iab_alloc_req              ),   
    .alloc_req_fence_i                 (iab_alloc_req_fence_i      ), 
    .alloc_req_addr                    (next_req_fetch_ptr         ),   
    .alloc_req_hword_high              (next_req_is_hword_high_only),   
    .buff_curr_fetch_ptr               (req_fetch_ptr              ),   
    .alloc_resp                        (iab_resp_alloc             ),   
    .alloc_resp_data                   (ifu_emi_resp_data          ),   
    .alloc_resp_error                  (iab_alloc_error            ),   
    .resp_complete                     (iab_resp_complete          ),   
    .iab_rd_alignment                  (iab_rd_alignment           ),   
    .buff_resp_head_data               (iab_resp_data              ),   
    .buff_resp_head_error              (iab_resp_error             ),   
    .buff_resp_head_addr               (iab_resp_addr              ),   
    .buff_resp_head_addr_valid         (iab_resp_addr_valid        ), 
    .buff_resp_head_hword_high_only    (iab_resp_hword_high_only   ),   
    .buff_resp_head_compressed         (iab_head_compressed        ),   
    .buff_resp_head_uncompressed_full  (iab_head_uncompressed_full ),   
    .buff_resp_head_uncompressed_half  (iab_head_uncompressed_half ),   
    .buff_full                         (                           ), // open                            
    .buff_empty                        (iab_req_empty              ),                             
    .buff_resp_empty                   (iab_resp_empty             ),   
    .buff_fill_level                   (buff_fill_level            ),   
    .num_emi_req_os                    (num_emi_req_os             ),   
    .emi_req_os                        (emi_req_os                 ),
    .no_flush_req_os                   (no_flush_req_os            )    

  );
  
               

//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS


  // EMI request sequence correct
  
  // Expipe response sequence correct
  
  logic [I_ADDR_WIDTH-1:0]       prop_next_resp_addr;
  logic [I_ADDR_WIDTH-1:0]       prop_resp_addr;
  logic prop_expipe_resp_accept;
  logic prop_expipe_resp_compressed;
  logic prop_ifu_expipe_req_branch_excpt_req_accepted;
  
  assign prop_expipe_resp_accept      = ifu_expipe_resp_valid & ifu_expipe_resp_ready;
  assign prop_expipe_resp_compressed  = ifu_expipe_resp_compressed;
  assign prop_ifu_expipe_req_branch_excpt_req_accepted = ifu_expipe_req_branch_excpt_req_valid & ifu_expipe_req_branch_excpt_req_ready;
  
  always @*
  begin
    case({prop_ifu_expipe_req_branch_excpt_req_accepted, prop_expipe_resp_accept})   
      2'b00         : prop_next_resp_addr = prop_resp_addr;
      2'b01         : prop_next_resp_addr = prop_resp_addr + (prop_expipe_resp_compressed ? {{I_ADDR_WIDTH-3{1'd0}},3'd2} : {{I_ADDR_WIDTH-3{1'd0}},3'd4});
      2'b10,2'b11   : prop_next_resp_addr = ifu_expipe_req_branch_excpt_req_fenci ? (ifu_expipe_req_branch_excpt_vaddr + {{I_ADDR_WIDTH-3{1'd0}},3'd4}) : ifu_expipe_req_branch_excpt_vaddr ;
      default: prop_next_resp_addr = l_core_reset_vector;
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_resp_addr <= l_core_reset_vector;
    else
      prop_resp_addr <= prop_next_resp_addr;
  end
  
  assert_ifu_fetch_sequence: assert property (@(posedge clk) disable iff (~resetn)
                                                prop_expipe_resp_accept |-> (ifu_expipe_resp_ireg_vaddr == prop_resp_addr));
                                                
                                               
  
  // Data transport from EMI to expipe correct (not fabricated, dropped, duplicated, corrupted...)  
  // Simple end to end data check
  // For a selected non-deterministic location (instruction), pick a non-deterministic, stable value. When the location is returned to the expipe it should 
  // always be the expected instruction.
  
  logic                     nd_loc_compressed;
  logic [I_ADDR_WIDTH-1:0]  nd_loc_addr;
  logic [31:0]              nd_loc_instruction;
  
  assume_ifu_nd_loc_compressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                     ##1 $stable(nd_loc_compressed));
                                                    
  assume_ifu_nd_loc_addr_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                               ##1 $stable(nd_loc_addr));  
                                               
  assume_ifu_nd_loc_instruction_compressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                nd_loc_compressed |-> ##1 $stable(nd_loc_instruction[15:0]));                                                                                               
                                               
  assume_ifu_nd_loc_instruction_uncompressed_stable : assume property (@(posedge clk) disable iff (~resetn)  
                                                  !nd_loc_compressed |-> ##1 $stable(nd_loc_instruction));    
                                                  
  assume_ifu_nd_loc_instruction_compressed_encoding : assume property (@(posedge clk) disable iff (~resetn)  
                                                    nd_loc_compressed |-> (nd_loc_instruction[1:0] != 2'b11));  
                                                    
  assume_ifu_nd_loc_instruction_uncompressed_encoding : assume property (@(posedge clk) disable iff (~resetn)  
                                                    !nd_loc_compressed |-> (nd_loc_instruction[1:0] == 2'b11));                                                                                                     
  
  // Need to know address associated with the response. All responses must be in order, so keep a list of requests made and re-associate with response when 
  // received.  
  
  logic [I_ADDR_WIDTH-1:0]  prop_emi_resp_addr;
  logic [I_ADDR_WIDTH-1:0]  nd_loc_addr_next;
  
  assign nd_loc_addr_next = nd_loc_addr + 32'd4;
  
  // store location of outstanding request
  // make this bigger if more outstanding
  
// logic [I_ADDR_WIDTH-1:0] prop_req_os_addr;
// 
// always @(posedge clk)
// begin
//   if(ifu_emi_req_valid & ifu_emi_req_ready)
//     prop_emi_resp_addr <= ifu_emi_req_addr;
// end
  
  
  
 miv_rv32_common_buffer_behav
 #(

   .BUFF_WIDTH                        (I_ADDR_WIDTH       ),
   .BUFF_SIZE                         (MAX_IFU_EMI_OS     ),
   .PTR_SIZE                          (LOG2_MAX_IFU_EMI_OS)
 )
 u_core_ifu_prop_emi_os_list_0
 (
   .clk                               (clk                                    ),
   .resetn                            (resetn                                 ),
   .valid_in                          (ifu_emi_req_valid & ifu_emi_req_ready  ),
   .ready_in                          (                                       ), //open
   .data_in                           (ifu_emi_req_addr                       ),
   .data_out                          (prop_emi_resp_addr                     ),
   .valid_out                         (                                       ), //open
   .ready_out                         (ifu_emi_resp_valid & ifu_emi_resp_ready)
 );
  
    // constrain ifu_emi_resp_data if the address contains the monitored location
    // note that a halfword aligned uncompressed instruction will span 2 fetches 

  assume_ifu_nd_loc_monitored_uncompressed_word_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & !nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data == nd_loc_instruction));


  assume_ifu_nd_loc_monitored_uncompressed_hword_align_hi : assume property (@(posedge clk) disable iff (~resetn)  
                                                         ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |->  
                                                            (ifu_emi_resp_data[31:16] == nd_loc_instruction[15:0]));   
                                                            
  assume_ifu_nd_loc_monitored_uncompressed_hword_align_lo : assume property (@(posedge clk) disable iff (~resetn)  
                                                         ((prop_emi_resp_addr[31:2] == nd_loc_addr_next[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & !nd_loc_compressed) |->  
                                                            (ifu_emi_resp_data[15:0] == nd_loc_instruction[31:16]));  
                                                            
  assume_ifu_nd_loc_monitored_compressed_word_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & !nd_loc_addr[1] & ifu_emi_resp_valid & nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data[15:0] == nd_loc_instruction[15:0]));  
                                                       
  assume_ifu_nd_loc_monitored_compressed_hword_align : assume property (@(posedge clk) disable iff (~resetn)  
                                                    ((prop_emi_resp_addr[31:2] == nd_loc_addr[31:2]) & nd_loc_addr[1] & ifu_emi_resp_valid & nd_loc_compressed) |-> 
                                                       (ifu_emi_resp_data[31:16] == nd_loc_instruction[15:0]));
                                                       
                                                       

  assert_ifu_compressed_correct: assert property (@(posedge clk) disable iff (~resetn)  
                                                  ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1])) |->
                                                  (ifu_expipe_resp_compressed == nd_loc_compressed));                                                       
                                                       
  assert_ifu_instruction_correct_compressed: assert property (@(posedge clk) disable iff (~resetn)  
                                            ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1]) & nd_loc_compressed) |->
                                            (ifu_expipe_resp_ireg == {{16{1'b0}},  nd_loc_instruction[15:0]}));
                                            
  assert_ifu_instruction_correct_uncompressed: assert property (@(posedge clk) disable iff (~resetn)  
                                              ((ifu_expipe_resp_valid & ifu_expipe_resp_ready) & (ifu_expipe_resp_ireg_vaddr[31:1] == nd_loc_addr[31:1]) & !nd_loc_compressed) |->
                                              (ifu_expipe_resp_ireg == nd_loc_instruction));                                                                                                                                                                                                                                                                                                       
                                                  
  // if a request is made, the corresponding instruction(s) are returned to the expipe, unless flushed
  
  // Cannot have an entry completing if nothing valid returned (unless flushing)
  
  // Cannot have anything returned if there was not a request for that location
  
  assert_ifu_no_complete_without_valid: assert property (@(posedge clk) disable iff (~resetn)
                                                         (iab_resp_complete & ~(req_flush | ~no_flush_req_os)) |-> ifu_expipe_resp_valid & ifu_expipe_resp_ready);   
                                                           
  // after a fence.i hold, the next fetch accepted must be for pc+4 (incr)
  assert_ifu_post_fence_fetch_incr: assert property (@(posedge clk) disable iff (~resetn)  
                                                     $fell(fence_i_hold) & !$past(ifu_expipe_req_flush) |-> (fetch_ptr_sel == fetch_ptr_sel_incr4) & ifu_emi_req_valid);     
                                                     
  // when taking a fence branch, the request will always allocate to the iab straight away    
  assert_ifu_fence_alloc_iab: assert property (@(posedge clk) disable iff (~resetn)                                                                                              
                                               fence_i_req |-> iab_alloc_req);    
  
  // after a flush, a branch must always occur (note may be in debug mode so may be delayed until debug mode left)
  logic prop_pipe_flush_seen;
  logic prop_branch_req_accepted;
  
  assign prop_branch_req_accepted = ifu_expipe_req_branch_excpt_req_valid & ifu_emi_req_valid & ifu_emi_req_ready;
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_pipe_flush_seen <= 1'b0;
    else
      prop_pipe_flush_seen <= (prop_pipe_flush_seen & ~prop_branch_req_accepted) | ifu_expipe_req_flush;
  end
  
  assert_branch_must_follow_flush: assert property (@(posedge clk) disable iff (~resetn)                                                                                              
                                               prop_pipe_flush_seen |-> ##[1:$] prop_branch_req_accepted); 
                                              
  assert_can_always_fetch: assert property (@(posedge clk) disable iff (~resetn)  
                                                (ifu_emi_req_valid & ifu_emi_req_valid) |-> ##[1:$] (ifu_emi_req_valid & ifu_emi_req_valid));        
   //-------------                                                              
   // covers
   //------------

   // return any response   
   sequence seq_expipe_any_resp_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_resp_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready)[->cycles] ;
   endsequence
   
   // return any compressed response
   sequence seq_expipe_any_compressed_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed)[->cycles] ;
   endsequence
   
   // return any uncompressed response
   sequence seq_expipe_any_uncompressed_consec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed)[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed)[->cycles] ;
   endsequence
   
   // return compressed (word aligned)
   sequence seq_expipe_any_compressed_consec_word_aligned;
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1]) ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return compressed (hword aligned)
   sequence seq_expipe_any_compressed_consec_hword_aligned;
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1]) ;
   endsequence
   
   sequence seq_expipe_any_compressed_nonconsec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return uncompressed (word aligned)
   sequence seq_expipe_any_uncompressed_consec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec_word_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ~ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
   // return uncompressed (hword aligned)
   sequence seq_expipe_any_uncompressed_consec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[*cycles] ;
   endsequence
   
   sequence seq_expipe_any_uncompressed_nonconsec_hword_aligned(cycles);
      (ifu_expipe_resp_valid & ifu_expipe_resp_ready & ~ifu_expipe_resp_compressed & ifu_expipe_resp_ireg_vaddr[1])[->cycles] ;
   endsequence
   
  genvar i_cover_fetch_seq;
  generate
  for (i_cover_fetch_seq = 1; i_cover_fetch_seq <= 10; i_cover_fetch_seq++) begin : gen_cover_instr_seq
  
       cover_ifu_seq_expipe_any_resp_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_resp_consec(i_cover_fetch_seq));
  
       cover_ifu_seq_expipe_any_resp_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_resp_nonconsec(i_cover_fetch_seq)); 

       cover_ifu_seq_expipe_any_compressed_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec(i_cover_fetch_seq));   
   
       cover_ifu_seq_expipe_any_compressed_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec(i_cover_fetch_seq));      

       cover_ifu_seq_expipe_any_uncompressed_consec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec(i_cover_fetch_seq)); 
   
       cover_ifu_seq_expipe_any_uncompressed_nonconsec: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec(i_cover_fetch_seq));    

       cover_ifu_seq_expipe_any_compressed_nonconsec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec_word_aligned(i_cover_fetch_seq));  
   
       cover_ifu_seq_expipe_any_compressed_nonconsec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_nonconsec_hword_aligned(i_cover_fetch_seq));

       cover_ifu_seq_expipe_any_uncompressed_consec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec_word_aligned(i_cover_fetch_seq));
                                                                    
       cover_ifu_seq_expipe_any_uncompressed_nonconsec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec_word_aligned(i_cover_fetch_seq)); 

       cover_ifu_seq_expipe_any_uncompressed_consec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_consec_hword_aligned(i_cover_fetch_seq)); 
   
       cover_ifu_seq_expipe_any_uncompressed_nonconsec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_uncompressed_nonconsec_hword_aligned(i_cover_fetch_seq)); 
   
  

  end
  endgenerate
  
  // cannot have sequences of back-to-back compressed words with the same alignement, so just cover single instance
  
  
  cover_ifu_seq_expipe_any_compressed_consec_word_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec_word_aligned); 

  cover_ifu_seq_expipe_any_compressed_consec_hword_aligned: cover property (@(posedge clk) disable iff (~resetn)
                                                                  seq_expipe_any_compressed_consec_hword_aligned);                                                                                 
                                        
`endif   

 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//#112763   Sept 20  KOH   rv32c_nop debug step fix to prevent forced nop on step, rv32c_dec_fence_i = 1'b1;
// Notes:
//
////////////////////////////////////////////////////////////////////////////////       
                                                                                         
////////////////////////////////////////////////////////////////////////////////         
//                                                                                       
//   File: miv_rv32_idecode.sv                                                        
//                                                                                       
//   Purpose: Core CPU instruction decode                                              
//   Auto-generated by Proteus Python generation tools                                           
//                                                                                       
//   Author:                                                                             
//                                                                                       
//   Version: 1.0                                                                        
//                                                                                       
////////////////////////////////////////////////////////////////////////////////         
                                                                                         
`default_nettype none                                                                    
                                                                                         
import miv_rv32_pkg::*; 
import miv_rv32_core_cfg_pkg::*;
import miv_rv32_mnemonic_pkg::*; 
module miv_rv32_idecode
  //****************************************************************************         
  // Parameter description   
  #(
    parameter GEN_DECODE_RV32I          = 1,
    parameter GEN_DECODE_RV32M          = 1,
    parameter GEN_DECODE_RV32C          = 1
   )                                                            
                                                                                         
                                                                                         
//******************************************************************************         
// Port Description                                                                      
   (                                                                                     
                                                                                         
   // clk/reset                                                                          
    input   wire logic                    clk,                          
    input   wire logic                    resetn,   
    input   wire logic                    core_reset, 
    input   wire logic                    trap_taken, 
    input   wire logic                    debug_exit, 
    input   wire logic                    vectored_interrupt_taken,
    
    
    input   wire logic                    cfg_hw_mul_en,    
    input   wire logic                    cfg_hw_div_en,    
    input   wire logic                    cfg_atomics_en,   
    input   wire logic                    cfg_compressed_en,
    
    output  logic                         idecode_ready, 
    
    input   wire logic                    debug_mode,
    input   wire logic [1:0]              priv_mode,                 
                                                    
    input   wire logic [31:0]             instruction,
    input   wire logic                    instruction_valid,
    input   wire logic                    instruction_compressed,
    
    output  t_mnemonic_list                         mnemonic,
    output  logic[31:0]                         immediate,
    output  logic                         illegal_instr,
    output  logic                         m_env_call,
    output  logic                         m_ret,
    output  logic                         d_ret,
    output  logic                         dbreakpoint,
    output  logic                         gpr_wr_valid,
    output  logic[4:0]                         gpr_wr_sel,
    output  logic                         gpr_rs1_rd_valid,
    output  logic[4:0]                         gpr_rs1_rd_sel,
    output  logic                         gpr_rs2_rd_valid,
    output  logic[4:0]                         gpr_rs2_rd_sel,
    output  t_gpr_wr_mux_sel                         gpr_wr_mux_sel,
    output  logic[11:0]                         sw_csr_addr,
    output  t_csr_alu_wr_op_sel                         sw_csr_wr_op,
    output  t_csr_alu_rd_op_sel                         sw_csr_rd_op,
    output  t_exu_alu_operand0_sel                         operand0_mux_sel,
    output  t_exu_alu_operand1_sel                         operand1_mux_sel,
    output  t_exu_alu_op_sel                         alu_op_sel,
    output  t_exu_shifter_operand_sel                         shifter_operand_sel,
    output  t_exu_shifter_places_sel                         shifter_unit_places,
    output  t_exu_shifter_op_sel                         shifter_unit_op_sel,
    output  t_exu_bcu_operand0_sel                         bcu_operand0_mux_sel,
    output  t_exu_bcu_operand1_sel                         bcu_operand1_mux_sel,
    output  t_exu_bcu_op_sel                         bcu_op_sel,
    output  t_exu_alu_result_mux_sel                         exu_result_mux_sel,
    output  t_branch_cond                         branch_cond,
    output  logic                         fence_i,
    output  logic                         fence,
    output  t_lsu_op                         lsu_op,
    output  logic                         wfi

                                                                                         
                  
   );                                                                                    
                                                                                         
                                                                                         
                                                                                         
                                                                                         
                                                                                         
//******************************************************************************         
// Declarations     

  logic[31:0] imm_dec_u;
  logic[31:0] imm_dec_i;
  logic[31:0] imm_dec_ishft;
  logic[31:0] imm_dec_istr;
  logic[31:0] imm_dec_j;
  logic[31:0] imm_dec_b;
  logic[31:0] imm_dec_uimm5;
  logic[31:0] imm_dec_cbi;
  logic[31:0] imm_dec_clo;
  logic[31:0] imm_dec_cso;
  logic[31:0] imm_dec_cii;
  logic[31:0] imm_dec_cjo;
  logic[31:0] imm_dec_ciisp16;
  logic[31:0] imm_dec_ciwisp4;
  logic[31:0] imm_dec_cbo;
  logic[31:0] imm_dec_cio;
  logic[31:0] imm_dec_csso;   
  
  logic[4:0] gpr_src_rs1_gpr_dec_i;  
  logic[4:0] gpr_src_rs1_gpr_dec_b;  
  logic[4:0] gpr_src_rs1_gpr_dec_s;  
  logic[4:0] gpr_src_rs1_gpr_dec_r;  
  logic[4:0] gpr_src_rs1_gpr_dec_lrsc;
  logic[4:0] gpr_src_rs1_gpr_dec_cl; 
  logic[4:0] gpr_src_rs1_gpr_dec_cs; 
  logic[4:0] gpr_src_rs1_gpr_dec_ci; 
  logic[4:0] gpr_src_rs1_gpr_dec_cb; 
  logic[4:0] gpr_src_rs1_gpr_dec_cr;   
  
  logic[4:0] gpr_src_rs2_gpr_dec_b;
  logic[4:0] gpr_src_rs2_gpr_dec_s;
  logic[4:0] gpr_src_rs2_gpr_dec_r;
  logic[4:0] gpr_src_rs2_gpr_dec_lrsc;
  logic[4:0] gpr_src_rs2_gpr_dec_cs;
  logic[4:0] gpr_src_rs2_gpr_dec_cr;
  logic[4:0] gpr_src_rs2_gpr_dec_css;  
  
  logic[4:0] gpr_dest_gpr_dec_u;   
  logic[4:0] gpr_dest_gpr_dec_i;   
  logic[4:0] gpr_dest_gpr_dec_r;   
  logic[4:0] gpr_dest_gpr_dec_lrsc;
  logic[4:0] gpr_dest_gpr_dec_ciw; 
  logic[4:0] gpr_dest_gpr_dec_cl;  
  logic[4:0] gpr_dest_gpr_dec_ci;  
  //logic[4:0] gpr_dest_gpr_dec_cr;  
  logic[4:0] gpr_dest_gpr_dec_cs;  
  logic[4:0] gpr_dest_gpr_dec_cb; 
  
  logic [11:0] csr_src_csr_dec_i;                                                     
                                                                                         
                                                                             
                                                                                         
//******************************************************************************         
// Main code        

   // literals for immediate and register/csr src/dest definition
   
  assign imm_dec_u       = {instruction[31:12], {12{1'b0}}};  
  assign imm_dec_i       = {{20{instruction[31]}},instruction[31:20]};
  assign imm_dec_ishft   = {{27{1'b0}},instruction[24:20]}; 
  assign imm_dec_istr    = {{21{instruction[31]}},instruction[30:25],instruction[11:7]};
  assign imm_dec_j       = {{12{instruction[31]}}, instruction[19:12],instruction[20],instruction[30:21], 1'b0};
  assign imm_dec_b       = {{20{instruction[31]}},instruction[7],instruction[30:25],instruction[11:8],1'b0};
  assign imm_dec_uimm5   = {{27{1'b0}},instruction[19:15]};
  assign imm_dec_cbi     = {{27{instruction[12]}},instruction[6:2]};
  assign imm_dec_clo     = {{25{1'b0}},instruction[5],instruction[12:10],instruction[6],2'b00};
  assign imm_dec_cso     = {{25{1'b0}},instruction[5],instruction[12:10],instruction[6],2'b00};
  assign imm_dec_cii     = {{27{instruction[12]}},instruction[6:2]};
  assign imm_dec_cjo     = {{21{instruction[12]}},instruction[8],instruction[10:9],instruction[6],instruction[7],instruction[2],instruction[11],instruction[5:3],1'b0};
  assign imm_dec_ciisp16 = {{23{instruction[12]}}, instruction[4:3], instruction[5], instruction[2], instruction[6], 4'b0000};
  assign imm_dec_ciwisp4 = {{22{1'b0}},instruction[10:7], instruction[12:11], instruction[5], instruction[6], 2'b00};
  assign imm_dec_cbo     = {{24{instruction[12]}},instruction[6:5],instruction[2],instruction[11:10],instruction[4:3],1'b0};
  assign imm_dec_cio     = {{24{1'b0}},instruction[3:2],instruction[12],instruction[6:4],2'b00};
  assign imm_dec_csso    = {{24{1'b0}},instruction[8:7],instruction[12:9],2'b00};  
  
  assign gpr_src_rs1_gpr_dec_i    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_b    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_s    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_r    = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_lrsc = instruction[15+:5];
  assign gpr_src_rs1_gpr_dec_cl   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_cs   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_ci   = instruction[7+:5];
  assign gpr_src_rs1_gpr_dec_cb   = {2'b01,instruction[7+:3]};
  assign gpr_src_rs1_gpr_dec_cr   = instruction[7+:5];
  
  assign gpr_src_rs2_gpr_dec_b    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_s    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_r    = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_lrsc = instruction[20+:5];
  assign gpr_src_rs2_gpr_dec_cs   = {2'b01,instruction[2+:3]};
  assign gpr_src_rs2_gpr_dec_cr   = instruction[2+:5];
  assign gpr_src_rs2_gpr_dec_css  = instruction[2+:5];
  
  assign gpr_dest_gpr_dec_u     = instruction[7+:5];
  assign gpr_dest_gpr_dec_i     = instruction[7+:5];
  assign gpr_dest_gpr_dec_r     = instruction[7+:5];
  assign gpr_dest_gpr_dec_lrsc  = instruction[7+:5];
  assign gpr_dest_gpr_dec_ciw   = {2'b01,instruction[2+:3]};
  assign gpr_dest_gpr_dec_cl    = {2'b01,instruction[2+:3]};
  assign gpr_dest_gpr_dec_ci    = instruction[7+:5];
  //assign gpr_dest_gpr_dec_cr    = instruction[7+:5];
  assign gpr_dest_gpr_dec_cs    = {2'b01,instruction[7+:3]};
  assign gpr_dest_gpr_dec_cb    = {2'b01,instruction[7+:3]};
  
  assign csr_src_csr_dec_i      = instruction[20+:12];
  
  // decoder always able to accept an instruction in core
  assign idecode_ready = 1'b1;
   
                                 
  t_mnemonic_list                         rv32i_dec_mnemonic;
  t_mnemonic_list                         rv32m_dec_mnemonic;
  t_mnemonic_list                         rv32c_dec_mnemonic;
  t_mnemonic_list                         case_dec_mnemonic;
  logic[31:0]                         rv32i_dec_immediate;
  logic[31:0]                         rv32m_dec_immediate;
  logic[31:0]                         rv32c_dec_immediate;
  logic[31:0]                         case_dec_immediate;
  logic                         rv32i_dec_illegal_instr;
  logic                         rv32m_dec_illegal_instr;
  logic                         rv32c_dec_illegal_instr;
  logic                         case_dec_illegal_instr;
  logic                         rv32i_dec_m_env_call;
  logic                         rv32m_dec_m_env_call;
  logic                         rv32c_dec_m_env_call;
  logic                         case_dec_m_env_call;
  logic                         rv32i_dec_m_ret;
  logic                         rv32m_dec_m_ret;
  logic                         rv32c_dec_m_ret;
  logic                         case_dec_m_ret;
  logic                         rv32i_dec_d_ret;
  logic                         rv32m_dec_d_ret;
  logic                         rv32c_dec_d_ret;
  logic                         case_dec_d_ret;
  logic                         rv32i_dec_dbreakpoint;
  logic                         rv32m_dec_dbreakpoint;
  logic                         rv32c_dec_dbreakpoint;
  logic                         case_dec_dbreakpoint;
  logic                         rv32i_dec_gpr_wr_valid;
  logic                         rv32m_dec_gpr_wr_valid;
  logic                         rv32c_dec_gpr_wr_valid;
  logic                         case_dec_gpr_wr_valid;
  logic[4:0]                         rv32i_dec_gpr_wr_sel;
  logic[4:0]                         rv32m_dec_gpr_wr_sel;
  logic[4:0]                         rv32c_dec_gpr_wr_sel;
  logic[4:0]                         case_dec_gpr_wr_sel;
  logic                         rv32i_dec_gpr_rs1_rd_valid;
  logic                         rv32m_dec_gpr_rs1_rd_valid;
  logic                         rv32c_dec_gpr_rs1_rd_valid;
  logic                         case_dec_gpr_rs1_rd_valid;
  logic[4:0]                         rv32i_dec_gpr_rs1_rd_sel;
  logic[4:0]                         rv32m_dec_gpr_rs1_rd_sel;
  logic[4:0]                         rv32c_dec_gpr_rs1_rd_sel;
  logic[4:0]                         case_dec_gpr_rs1_rd_sel;
  logic                         rv32i_dec_gpr_rs2_rd_valid;
  logic                         rv32m_dec_gpr_rs2_rd_valid;
  logic                         rv32c_dec_gpr_rs2_rd_valid;
  logic                         case_dec_gpr_rs2_rd_valid;
  logic[4:0]                         rv32i_dec_gpr_rs2_rd_sel;
  logic[4:0]                         rv32m_dec_gpr_rs2_rd_sel;
  logic[4:0]                         rv32c_dec_gpr_rs2_rd_sel;
  logic[4:0]                         case_dec_gpr_rs2_rd_sel;
  t_gpr_wr_mux_sel                         rv32i_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         rv32m_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         rv32c_dec_gpr_wr_mux_sel;
  t_gpr_wr_mux_sel                         case_dec_gpr_wr_mux_sel;
  logic[11:0]                         rv32i_dec_sw_csr_addr;
  logic[11:0]                         rv32m_dec_sw_csr_addr;
  logic[11:0]                         rv32c_dec_sw_csr_addr;
  logic[11:0]                         case_dec_sw_csr_addr;
  t_csr_alu_wr_op_sel                         rv32i_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         rv32m_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         rv32c_dec_sw_csr_wr_op;
  t_csr_alu_wr_op_sel                         case_dec_sw_csr_wr_op;
  t_csr_alu_rd_op_sel                         rv32i_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         rv32m_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         rv32c_dec_sw_csr_rd_op;
  t_csr_alu_rd_op_sel                         case_dec_sw_csr_rd_op;
  t_exu_alu_operand0_sel                         rv32i_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         rv32m_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         rv32c_dec_operand0_mux_sel;
  t_exu_alu_operand0_sel                         case_dec_operand0_mux_sel;
  t_exu_alu_operand1_sel                         rv32i_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         rv32m_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         rv32c_dec_operand1_mux_sel;
  t_exu_alu_operand1_sel                         case_dec_operand1_mux_sel;
  t_exu_alu_op_sel                         rv32i_dec_alu_op_sel;
  t_exu_alu_op_sel                         rv32m_dec_alu_op_sel;
  t_exu_alu_op_sel                         rv32c_dec_alu_op_sel;
  t_exu_alu_op_sel                         case_dec_alu_op_sel;
  t_exu_shifter_operand_sel                         rv32i_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         rv32m_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         rv32c_dec_shifter_operand_sel;
  t_exu_shifter_operand_sel                         case_dec_shifter_operand_sel;
  t_exu_shifter_places_sel                         rv32i_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         rv32m_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         rv32c_dec_shifter_unit_places;
  t_exu_shifter_places_sel                         case_dec_shifter_unit_places;
  t_exu_shifter_op_sel                         rv32i_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         rv32m_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         rv32c_dec_shifter_unit_op_sel;
  t_exu_shifter_op_sel                         case_dec_shifter_unit_op_sel;
  t_exu_bcu_operand0_sel                         rv32i_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         rv32m_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         rv32c_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand0_sel                         case_dec_bcu_operand0_mux_sel;
  t_exu_bcu_operand1_sel                         rv32i_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         rv32m_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         rv32c_dec_bcu_operand1_mux_sel;
  t_exu_bcu_operand1_sel                         case_dec_bcu_operand1_mux_sel;
  t_exu_bcu_op_sel                         rv32i_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         rv32m_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         rv32c_dec_bcu_op_sel;
  t_exu_bcu_op_sel                         case_dec_bcu_op_sel;
  t_exu_alu_result_mux_sel                         rv32i_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         rv32m_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         rv32c_dec_exu_result_mux_sel;
  t_exu_alu_result_mux_sel                         case_dec_exu_result_mux_sel;
  t_branch_cond                         rv32i_dec_branch_cond;
  t_branch_cond                         rv32m_dec_branch_cond;
  t_branch_cond                         rv32c_dec_branch_cond;
  t_branch_cond                         case_dec_branch_cond;
  logic                         rv32i_dec_fence_i;
  logic                         rv32m_dec_fence_i;
  logic                         rv32c_dec_fence_i;
  logic                         case_dec_fence_i;
  logic                         rv32i_dec_fence;
  logic                         rv32m_dec_fence;
  logic                         rv32c_dec_fence;
  logic                         case_dec_fence;
  t_lsu_op                         rv32i_dec_lsu_op;
  t_lsu_op                         rv32m_dec_lsu_op;
  t_lsu_op                         rv32c_dec_lsu_op;
  t_lsu_op                         case_dec_lsu_op;
  logic                         rv32i_dec_wfi;
  logic                         rv32m_dec_wfi;
  logic                         rv32c_dec_wfi;
  logic                         case_dec_wfi;
  logic                         rv32i_instr_decoded;
  logic                         rv32m_instr_decoded;
  logic                         rv32c_instr_decoded;

generate if(GEN_DECODE_RV32I)
begin : gen_decode_rv32i
  always @*
  begin

    // assign defaults

    rv32i_dec_mnemonic = rv32_default;
    rv32i_dec_immediate = 32'd0;
    rv32i_dec_illegal_instr = 1'b1;
    rv32i_dec_m_env_call = 1'b0;
    rv32i_dec_m_ret = 1'b0;
    rv32i_dec_d_ret = 1'b0;
    rv32i_dec_dbreakpoint = 1'b0;
    rv32i_dec_gpr_wr_valid = 1'b0;
    rv32i_dec_gpr_wr_sel = 5'd0;
    rv32i_dec_gpr_rs1_rd_valid = 1'b0;
    rv32i_dec_gpr_rs1_rd_sel = 5'd0;
    rv32i_dec_gpr_rs2_rd_valid = 1'b0;
    rv32i_dec_gpr_rs2_rd_sel = 5'd0;
    rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32i_dec_sw_csr_addr = 12'd0;
    rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32i_dec_operand0_mux_sel = exu_op0_rs1;
    rv32i_dec_operand1_mux_sel = exu_op1_rs2;
    rv32i_dec_alu_op_sel = exu_alu_op_none;
    rv32i_dec_shifter_operand_sel = shifter_operand_none;
    rv32i_dec_shifter_unit_places = shifter_places_operand_none;
    rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32i_dec_bcu_op_sel = bcu_op_none;
    rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32i_dec_branch_cond = branch_cond_none;
    rv32i_dec_fence_i = 1'b0;
    rv32i_dec_fence = 1'b0;
    rv32i_dec_lsu_op = lsu_op_none;
    rv32i_dec_wfi = 1'b0;
    rv32i_instr_decoded = 1'b0;

    unique casez(instruction)
      32'b?????????????????????????0110111:
      begin
        rv32i_dec_mnemonic = rv32i_lui;
        rv32i_dec_immediate = imm_dec_u;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_u;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????????????0010111:
      begin
        rv32i_dec_mnemonic = rv32i_auipc;
        rv32i_dec_immediate = imm_dec_u;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_u;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????????????1101111:
      begin
        rv32i_dec_mnemonic = rv32i_jal;
        rv32i_dec_immediate = imm_dec_j;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_lit4;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????1100111:
      begin
        rv32i_dec_mnemonic = rv32i_jalr;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_pc;
        rv32i_dec_operand1_mux_sel = exu_op1_lit4;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_beq;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_equal_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bne;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_not_equal_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_blt;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bge;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_gte_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bltu;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????1100011:
      begin
        rv32i_dec_mnemonic = rv32i_bgeu;
        rv32i_dec_immediate = imm_dec_b;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_b;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_b;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_gte_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_compare_true;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lb;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_byte_s;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lh;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_hword_s;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lw;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_word;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lbu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_byte_u;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????0000011:
      begin
        rv32i_dec_mnemonic = rv32i_lhu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_ld_hword_u;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sb;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_addr_byte;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_byte;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sh;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_addr_hword;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_hword;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0100011:
      begin
        rv32i_dec_mnemonic = rv32i_sw;
        rv32i_dec_immediate = imm_dec_istr;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_s;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_s;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32i_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_str_word;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????000?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_addi;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_slti;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????011?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_sltiu;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????100?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_xori;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_ori;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_andi;
        rv32i_dec_immediate = imm_dec_i;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????001?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_slli;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????101?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_srli;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????101?????0010011:
      begin
        rv32i_dec_mnemonic = rv32i_srai;
        rv32i_dec_immediate = imm_dec_ishft;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_imm;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????000?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_add;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????000?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sub;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_sub_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????001?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sll;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????010?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_slt;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_signed_op0_signed_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????011?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sltu;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_cmp_op_compare_lt_unsigned_op0_unsigned_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_cmp_lit;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????100?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_xor;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????101?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_srl;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0100000??????????101?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_sra;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_rs1;
        rv32i_dec_shifter_unit_places = shifter_places_operand_rs2;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????110?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_or;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000000??????????111?????0110011:
      begin
        rv32i_dec_mnemonic = rv32i_and;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b0000????????00000000000000001111:
      begin
        rv32i_dec_mnemonic = rv32i_fence;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b1;
        rv32i_dec_lsu_op = lsu_op_fence;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000000000001000000001111:
      begin
        rv32i_dec_mnemonic = rv32i_fence_i;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b1;
        rv32i_dec_fence = 1'b1;
        rv32i_dec_lsu_op = lsu_op_fence;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????001?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrw;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = gpr_dest_gpr_dec_i != 5'd0;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_swap;
        rv32i_dec_sw_csr_rd_op = (gpr_dest_gpr_dec_i != 5'd0) ? csr_alu_rd_op_rd : csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????010?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrs;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (gpr_src_rs1_gpr_dec_i != 5'd0) ? csr_alu_wr_op_set : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????011?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrc;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_i;
        rv32i_dec_gpr_rs2_rd_valid = 1'b1;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (gpr_src_rs1_gpr_dec_i != 5'd0) ? csr_alu_wr_op_clr : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????101?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrwi;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = gpr_dest_gpr_dec_i != 5'd0;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_swap;
        rv32i_dec_sw_csr_rd_op = (gpr_dest_gpr_dec_i != 5'd0) ? csr_alu_rd_op_rd  : csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????110?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrsi;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (imm_dec_uimm5 != 32'd0) ? csr_alu_wr_op_set : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b?????????????????111?????1110011:
      begin
        rv32i_dec_mnemonic = rv32i_csrrci;
        rv32i_dec_immediate = imm_dec_uimm5;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b1;
        rv32i_dec_gpr_wr_sel = gpr_dest_gpr_dec_i;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_csr;
        rv32i_dec_sw_csr_addr = csr_src_csr_dec_i;
        rv32i_dec_sw_csr_wr_op = (imm_dec_uimm5 != 32'd0) ? csr_alu_wr_op_clr : csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_rd;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_imm;
        rv32i_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_ecall;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b1;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00000000000100000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_ebreak;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b1;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b01111011001000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_dret;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = ~debug_mode;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b1;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_dpc;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00110000001000000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_mret;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b1;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b1;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_epc;
        rv32i_dec_bcu_op_sel = bcu_op_add;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_always;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b0;
        rv32i_instr_decoded = 1'b1;
      end
      32'b00010000010100000000000001110011:
      begin
        rv32i_dec_mnemonic = rv32i_wfi;
        rv32i_dec_immediate = 32'd0;
        rv32i_dec_illegal_instr = 1'b0;
        rv32i_dec_m_env_call = 1'b0;
        rv32i_dec_m_ret = 1'b0;
        rv32i_dec_d_ret = 1'b0;
        rv32i_dec_dbreakpoint = 1'b0;
        rv32i_dec_gpr_wr_valid = 1'b0;
        rv32i_dec_gpr_wr_sel = 5'd0;
        rv32i_dec_gpr_rs1_rd_valid = 1'b0;
        rv32i_dec_gpr_rs1_rd_sel = 5'd0;
        rv32i_dec_gpr_rs2_rd_valid = 1'b0;
        rv32i_dec_gpr_rs2_rd_sel = 5'd0;
        rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32i_dec_sw_csr_addr = 12'd0;
        rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32i_dec_operand0_mux_sel = exu_op0_rs1;
        rv32i_dec_operand1_mux_sel = exu_op1_rs2;
        rv32i_dec_alu_op_sel = exu_alu_op_none;
        rv32i_dec_shifter_operand_sel = shifter_operand_none;
        rv32i_dec_shifter_unit_places = shifter_places_operand_none;
        rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32i_dec_bcu_op_sel = bcu_op_none;
        rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
        rv32i_dec_branch_cond = branch_cond_none;
        rv32i_dec_fence_i = 1'b0;
        rv32i_dec_fence = 1'b0;
        rv32i_dec_lsu_op = lsu_op_none;
        rv32i_dec_wfi = 1'b1;
        rv32i_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32i

  assign rv32i_dec_mnemonic = rv32_default;
  assign rv32i_dec_immediate = 32'd0;
  assign rv32i_dec_illegal_instr = 1'b1;
  assign rv32i_dec_m_env_call = 1'b0;
  assign rv32i_dec_m_ret = 1'b0;
  assign rv32i_dec_d_ret = 1'b0;
  assign rv32i_dec_dbreakpoint = 1'b0;
  assign rv32i_dec_gpr_wr_valid = 1'b0;
  assign rv32i_dec_gpr_wr_sel = 5'd0;
  assign rv32i_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32i_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32i_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32i_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32i_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32i_dec_sw_csr_addr = 12'd0;
  assign rv32i_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32i_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32i_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32i_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32i_dec_alu_op_sel = exu_alu_op_none;
  assign rv32i_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32i_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32i_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32i_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32i_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32i_dec_bcu_op_sel = bcu_op_none;
  assign rv32i_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32i_dec_branch_cond = branch_cond_none;
  assign rv32i_dec_fence_i = 1'b0;
  assign rv32i_dec_fence = 1'b0;
  assign rv32i_dec_lsu_op = lsu_op_none;
  assign rv32i_dec_wfi = 1'b0;
  assign rv32i_instr_decoded = 1'b0;

end
endgenerate
generate if(GEN_DECODE_RV32M)
begin : gen_decode_rv32m
  always @*
  begin

    // assign defaults

    rv32m_dec_mnemonic = rv32_default;
    rv32m_dec_immediate = 32'd0;
    rv32m_dec_illegal_instr = 1'b1;
    rv32m_dec_m_env_call = 1'b0;
    rv32m_dec_m_ret = 1'b0;
    rv32m_dec_d_ret = 1'b0;
    rv32m_dec_dbreakpoint = 1'b0;
    rv32m_dec_gpr_wr_valid = 1'b0;
    rv32m_dec_gpr_wr_sel = 5'd0;
    rv32m_dec_gpr_rs1_rd_valid = 1'b0;
    rv32m_dec_gpr_rs1_rd_sel = 5'd0;
    rv32m_dec_gpr_rs2_rd_valid = 1'b0;
    rv32m_dec_gpr_rs2_rd_sel = 5'd0;
    rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32m_dec_sw_csr_addr = 12'd0;
    rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32m_dec_operand0_mux_sel = exu_op0_rs1;
    rv32m_dec_operand1_mux_sel = exu_op1_rs2;
    rv32m_dec_alu_op_sel = exu_alu_op_none;
    rv32m_dec_shifter_operand_sel = shifter_operand_none;
    rv32m_dec_shifter_unit_places = shifter_places_operand_none;
    rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32m_dec_bcu_op_sel = bcu_op_none;
    rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32m_dec_branch_cond = branch_cond_none;
    rv32m_dec_fence_i = 1'b0;
    rv32m_dec_fence = 1'b0;
    rv32m_dec_lsu_op = lsu_op_none;
    rv32m_dec_wfi = 1'b0;
    rv32m_instr_decoded = 1'b0;

    unique casez(instruction)
      32'b0000001??????????000?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mul;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????001?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulh;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????010?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulhsu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_signed_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????011?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_mulhu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_mul_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_multiply_high_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_multiplier;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????100?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_div;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_divide_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????101?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_divu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_divide_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????110?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_rem;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_remainder_signed_op0_signed_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      32'b0000001??????????111?????0110011:
      begin
        rv32m_dec_mnemonic = rv32m_remu;
        rv32m_dec_immediate = 32'd0;
        rv32m_dec_illegal_instr = !cfg_hw_div_en;
        rv32m_dec_m_env_call = 1'b0;
        rv32m_dec_m_ret = 1'b0;
        rv32m_dec_d_ret = 1'b0;
        rv32m_dec_dbreakpoint = 1'b0;
        rv32m_dec_gpr_wr_valid = 1'b1;
        rv32m_dec_gpr_wr_sel = gpr_dest_gpr_dec_r;
        rv32m_dec_gpr_rs1_rd_valid = 1'b1;
        rv32m_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_r;
        rv32m_dec_gpr_rs2_rd_valid = 1'b1;
        rv32m_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_r;
        rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32m_dec_sw_csr_addr = 12'd0;
        rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32m_dec_operand0_mux_sel = exu_op0_rs1;
        rv32m_dec_operand1_mux_sel = exu_op1_rs2;
        rv32m_dec_alu_op_sel = exu_alu_op_remainder_unsigned_op0_unsigned_op1;
        rv32m_dec_shifter_operand_sel = shifter_operand_none;
        rv32m_dec_shifter_unit_places = shifter_places_operand_none;
        rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32m_dec_bcu_op_sel = bcu_op_none;
        rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_divider;
        rv32m_dec_branch_cond = branch_cond_none;
        rv32m_dec_fence_i = 1'b0;
        rv32m_dec_fence = 1'b0;
        rv32m_dec_lsu_op = lsu_op_none;
        rv32m_dec_wfi = 1'b0;
        rv32m_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32m

  assign rv32m_dec_mnemonic = rv32_default;
  assign rv32m_dec_immediate = 32'd0;
  assign rv32m_dec_illegal_instr = 1'b1;
  assign rv32m_dec_m_env_call = 1'b0;
  assign rv32m_dec_m_ret = 1'b0;
  assign rv32m_dec_d_ret = 1'b0;
  assign rv32m_dec_dbreakpoint = 1'b0;
  assign rv32m_dec_gpr_wr_valid = 1'b0;
  assign rv32m_dec_gpr_wr_sel = 5'd0;
  assign rv32m_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32m_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32m_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32m_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32m_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32m_dec_sw_csr_addr = 12'd0;
  assign rv32m_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32m_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32m_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32m_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32m_dec_alu_op_sel = exu_alu_op_none;
  assign rv32m_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32m_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32m_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32m_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32m_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32m_dec_bcu_op_sel = bcu_op_none;
  assign rv32m_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32m_dec_branch_cond = branch_cond_none;
  assign rv32m_dec_fence_i = 1'b0;
  assign rv32m_dec_fence = 1'b0;
  assign rv32m_dec_lsu_op = lsu_op_none;
  assign rv32m_dec_wfi = 1'b0;
  assign rv32m_instr_decoded = 1'b0;

end
endgenerate
generate if(GEN_DECODE_RV32C)
begin : gen_decode_rv32c
  always @*
  begin

    // assign defaults

    rv32c_dec_mnemonic = rv32_default;
    rv32c_dec_immediate = 32'd0;
    rv32c_dec_illegal_instr = 1'b1;
    rv32c_dec_m_env_call = 1'b0;
    rv32c_dec_m_ret = 1'b0;
    rv32c_dec_d_ret = 1'b0;
    rv32c_dec_dbreakpoint = 1'b0;
    rv32c_dec_gpr_wr_valid = 1'b0;
    rv32c_dec_gpr_wr_sel = 5'd0;
    rv32c_dec_gpr_rs1_rd_valid = 1'b0;
    rv32c_dec_gpr_rs1_rd_sel = 5'd0;
    rv32c_dec_gpr_rs2_rd_valid = 1'b0;
    rv32c_dec_gpr_rs2_rd_sel = 5'd0;
    rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
    rv32c_dec_sw_csr_addr = 12'd0;
    rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
    rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
    rv32c_dec_operand0_mux_sel = exu_op0_rs1;
    rv32c_dec_operand1_mux_sel = exu_op1_rs2;
    rv32c_dec_alu_op_sel = exu_alu_op_none;
    rv32c_dec_shifter_operand_sel = shifter_operand_none;
    rv32c_dec_shifter_unit_places = shifter_places_operand_none;
    rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
    rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
    rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
    rv32c_dec_bcu_op_sel = bcu_op_none;
    rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
    rv32c_dec_branch_cond = branch_cond_none;
    rv32c_dec_fence_i = 1'b0;
    rv32c_dec_fence = 1'b0;
    rv32c_dec_lsu_op = lsu_op_none;
    rv32c_dec_wfi = 1'b0;
    rv32c_instr_decoded = 1'b0;

    unique casez(instruction)
      32'b????????????????000???????????00:
      begin
        if(((imm_dec_ciwisp4 == 32'd0) && (gpr_dest_gpr_dec_ciw == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_illegal0;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = 1'b1;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b0;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((imm_dec_ciwisp4 != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi4spn;
          rv32c_dec_immediate = imm_dec_ciwisp4;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ciw;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????010???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_lw;
        rv32c_dec_immediate = imm_dec_clo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cl;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cl;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_ld_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????110???????????00:
      begin
        rv32c_dec_mnemonic = rv32c_sw;
        rv32c_dec_immediate = imm_dec_cso;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????000???????????01:
      begin
        if(((gpr_dest_gpr_dec_ci) != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_ci;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if(((gpr_dest_gpr_dec_ci) == 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_nop;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b1; //c.nop debug step fix SAR#112763
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????001???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_jal;
        rv32c_dec_immediate = imm_dec_cjo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = 5'd1;
        rv32c_dec_gpr_rs1_rd_valid = 1'b0;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_pc;
        rv32c_dec_operand1_mux_sel = exu_op1_lit2;
        rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_always;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????010???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_li;
        rv32c_dec_immediate = imm_dec_cii;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????011???????????01:
      begin
        if((gpr_dest_gpr_dec_ci == 5'd2) && (imm_dec_ciisp16 != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_addi16sp;
          rv32c_dec_immediate = imm_dec_ciisp16;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = 5'd2;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_dest_gpr_dec_ci != 5'd2)  && (imm_dec_cii != 32'd0))
        begin
          rv32c_dec_mnemonic = rv32c_lui;
          rv32c_dec_immediate = {imm_dec_cii[0+:20],{12{1'b0}}};
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100000????????01:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_srli;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_right;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100001????????01:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_srai;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_arithmetic_shift_right;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????100?10????????01:
      begin
        rv32c_dec_mnemonic = rv32c_andi;
        rv32c_dec_immediate = imm_dec_cbi;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cb;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???00???01:
      begin
        rv32c_dec_mnemonic = rv32c_sub;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_sub_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???01???01:
      begin
        rv32c_dec_mnemonic = rv32c_xor;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_xor_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???10???01:
      begin
        rv32c_dec_mnemonic = rv32c_or;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_or_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????100011???11???01:
      begin
        rv32c_dec_mnemonic = rv32c_and;
        rv32c_dec_immediate = 32'd0;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b1;
        rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_cs;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cs;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cs;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_alu_op_and_op0_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_none;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_logical;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????101???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_j;
        rv32c_dec_immediate = imm_dec_cjo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b0;
        rv32c_dec_gpr_rs1_rd_sel = 5'd0;
        rv32c_dec_gpr_rs2_rd_valid = 1'b0;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_pc;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_always;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????110???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_beqz;
        rv32c_dec_immediate = imm_dec_cbo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_cmp_op_compare_equal_signed_op0_signed_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_compare_true;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????111???????????01:
      begin
        rv32c_dec_mnemonic = rv32c_bnez;
        rv32c_dec_immediate = imm_dec_cbo;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cb;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = 5'd0;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_rs2;
        rv32c_dec_alu_op_sel = exu_cmp_op_compare_not_equal_signed_op0_signed_op1;
        rv32c_dec_shifter_operand_sel = shifter_operand_none;
        rv32c_dec_shifter_unit_places = shifter_places_operand_none;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
        rv32c_dec_branch_cond = branch_cond_compare_true;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_none;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      32'b????????????????000???????????10:
      begin
        if((!instruction[12]))
        begin
          rv32c_dec_mnemonic = rv32c_slli;
          rv32c_dec_immediate = imm_dec_cii;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_ci;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_rs1;
          rv32c_dec_shifter_unit_places = shifter_places_operand_imm;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_shifter;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????010???????????10:
      begin
        if((gpr_dest_gpr_dec_ci != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_lwsp;
          rv32c_dec_immediate = imm_dec_cio;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd2;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_lsu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_imm;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_ld_word;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????1000??????????10:
      begin
        if(((gpr_src_rs1_gpr_dec_cr != 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_jr;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_always;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_src_rs2_gpr_dec_cr != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_mv;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cr;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????1001??????????10:
      begin
        if(((gpr_src_rs1_gpr_dec_cr == 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_ebreak;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b1;
          rv32c_dec_gpr_wr_valid = 1'b0;
          rv32c_dec_gpr_wr_sel = 5'd0;
          rv32c_dec_gpr_rs1_rd_valid = 1'b0;
          rv32c_dec_gpr_rs1_rd_sel = 5'd0;
          rv32c_dec_gpr_rs2_rd_valid = 1'b0;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_none;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if(((gpr_src_rs1_gpr_dec_cr != 5'd0) &&  (gpr_src_rs2_gpr_dec_cr == 5'd0)))
        begin
          rv32c_dec_mnemonic = rv32c_jalr;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = 5'd1;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = 5'd0;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_pc;
          rv32c_dec_operand1_mux_sel = exu_op1_lit2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_add;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_always;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
        else if((gpr_src_rs2_gpr_dec_cr != 5'd0))
        begin
          rv32c_dec_mnemonic = rv32c_add;
          rv32c_dec_immediate = 32'd0;
          rv32c_dec_illegal_instr = !cfg_compressed_en;
          rv32c_dec_m_env_call = 1'b0;
          rv32c_dec_m_ret = 1'b0;
          rv32c_dec_d_ret = 1'b0;
          rv32c_dec_dbreakpoint = 1'b0;
          rv32c_dec_gpr_wr_valid = 1'b1;
          rv32c_dec_gpr_wr_sel = gpr_dest_gpr_dec_ci;
          rv32c_dec_gpr_rs1_rd_valid = 1'b1;
          rv32c_dec_gpr_rs1_rd_sel = gpr_src_rs1_gpr_dec_cr;
          rv32c_dec_gpr_rs2_rd_valid = 1'b1;
          rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_cr;
          rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_exu;
          rv32c_dec_sw_csr_addr = 12'd0;
          rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
          rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
          rv32c_dec_operand0_mux_sel = exu_op0_rs1;
          rv32c_dec_operand1_mux_sel = exu_op1_rs2;
          rv32c_dec_alu_op_sel = exu_alu_op_add_op0_op1;
          rv32c_dec_shifter_operand_sel = shifter_operand_none;
          rv32c_dec_shifter_unit_places = shifter_places_operand_none;
          rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
          rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
          rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
          rv32c_dec_bcu_op_sel = bcu_op_none;
          rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_adder;
          rv32c_dec_branch_cond = branch_cond_none;
          rv32c_dec_fence_i = 1'b0;
          rv32c_dec_fence = 1'b0;
          rv32c_dec_lsu_op = lsu_op_none;
          rv32c_dec_wfi = 1'b0;
          rv32c_instr_decoded = 1'b1;
        end
      end
      32'b????????????????110???????????10:
      begin
        rv32c_dec_mnemonic = rv32c_swsp;
        rv32c_dec_immediate = imm_dec_csso;
        rv32c_dec_illegal_instr = !cfg_compressed_en;
        rv32c_dec_m_env_call = 1'b0;
        rv32c_dec_m_ret = 1'b0;
        rv32c_dec_d_ret = 1'b0;
        rv32c_dec_dbreakpoint = 1'b0;
        rv32c_dec_gpr_wr_valid = 1'b0;
        rv32c_dec_gpr_wr_sel = 5'd0;
        rv32c_dec_gpr_rs1_rd_valid = 1'b1;
        rv32c_dec_gpr_rs1_rd_sel = 5'd2;
        rv32c_dec_gpr_rs2_rd_valid = 1'b1;
        rv32c_dec_gpr_rs2_rd_sel = gpr_src_rs2_gpr_dec_css;
        rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
        rv32c_dec_sw_csr_addr = 12'd0;
        rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
        rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
        rv32c_dec_operand0_mux_sel = exu_op0_rs1;
        rv32c_dec_operand1_mux_sel = exu_op1_imm;
        rv32c_dec_alu_op_sel = exu_alu_op_none;
        rv32c_dec_shifter_operand_sel = shifter_operand_rs2;
        rv32c_dec_shifter_unit_places = shifter_places_operand_noshift;
        rv32c_dec_shifter_unit_op_sel = exu_shifter_op_shift_left;
        rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_rs1;
        rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
        rv32c_dec_bcu_op_sel = bcu_op_add;
        rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_acu;
        rv32c_dec_branch_cond = branch_cond_none;
        rv32c_dec_fence_i = 1'b0;
        rv32c_dec_fence = 1'b0;
        rv32c_dec_lsu_op = lsu_op_str_word;
        rv32c_dec_wfi = 1'b0;
        rv32c_instr_decoded = 1'b1;
      end
      default :
      begin
      end
    endcase
  end

end
else begin : ngen_decode_rv32c

  assign rv32c_dec_mnemonic = rv32_default;
  assign rv32c_dec_immediate = 32'd0;
  assign rv32c_dec_illegal_instr = 1'b1;
  assign rv32c_dec_m_env_call = 1'b0;
  assign rv32c_dec_m_ret = 1'b0;
  assign rv32c_dec_d_ret = 1'b0;
  assign rv32c_dec_dbreakpoint = 1'b0;
  assign rv32c_dec_gpr_wr_valid = 1'b0;
  assign rv32c_dec_gpr_wr_sel = 5'd0;
  assign rv32c_dec_gpr_rs1_rd_valid = 1'b0;
  assign rv32c_dec_gpr_rs1_rd_sel = 5'd0;
  assign rv32c_dec_gpr_rs2_rd_valid = 1'b0;
  assign rv32c_dec_gpr_rs2_rd_sel = 5'd0;
  assign rv32c_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
  assign rv32c_dec_sw_csr_addr = 12'd0;
  assign rv32c_dec_sw_csr_wr_op = csr_alu_wr_op_none;
  assign rv32c_dec_sw_csr_rd_op = csr_alu_rd_op_none;
  assign rv32c_dec_operand0_mux_sel = exu_op0_rs1;
  assign rv32c_dec_operand1_mux_sel = exu_op1_rs2;
  assign rv32c_dec_alu_op_sel = exu_alu_op_none;
  assign rv32c_dec_shifter_operand_sel = shifter_operand_none;
  assign rv32c_dec_shifter_unit_places = shifter_places_operand_none;
  assign rv32c_dec_shifter_unit_op_sel = exu_shifter_op_none;
  assign rv32c_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
  assign rv32c_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
  assign rv32c_dec_bcu_op_sel = bcu_op_none;
  assign rv32c_dec_exu_result_mux_sel = exu_alu_result_mux_none;
  assign rv32c_dec_branch_cond = branch_cond_none;
  assign rv32c_dec_fence_i = 1'b0;
  assign rv32c_dec_fence = 1'b0;
  assign rv32c_dec_lsu_op = lsu_op_none;
  assign rv32c_dec_wfi = 1'b0;
  assign rv32c_instr_decoded = 1'b0;

end
endgenerate
always @*
begin

  unique case({rv32i_instr_decoded,rv32m_instr_decoded,rv32c_instr_decoded})
   3'b100 :
    begin
      case_dec_mnemonic = rv32i_dec_mnemonic;
      case_dec_immediate = rv32i_dec_immediate;
      case_dec_illegal_instr = rv32i_dec_illegal_instr;
      case_dec_m_env_call = rv32i_dec_m_env_call;
      case_dec_m_ret = rv32i_dec_m_ret;
      case_dec_d_ret = rv32i_dec_d_ret;
      case_dec_dbreakpoint = rv32i_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32i_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = rv32i_dec_gpr_wr_sel;
      case_dec_gpr_rs1_rd_valid = rv32i_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = rv32i_dec_gpr_rs1_rd_sel;
      case_dec_gpr_rs2_rd_valid = rv32i_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = rv32i_dec_gpr_rs2_rd_sel;
      case_dec_gpr_wr_mux_sel = rv32i_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32i_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32i_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32i_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32i_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32i_dec_operand1_mux_sel;
      case_dec_alu_op_sel = rv32i_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32i_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32i_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32i_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32i_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32i_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32i_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32i_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32i_dec_branch_cond;
      case_dec_fence_i = rv32i_dec_fence_i;
      case_dec_fence = rv32i_dec_fence;
      case_dec_lsu_op = rv32i_dec_lsu_op;
      case_dec_wfi = rv32i_dec_wfi;
    end

   3'b010 :
    begin
      case_dec_mnemonic = rv32m_dec_mnemonic;
      case_dec_immediate = rv32m_dec_immediate;
      case_dec_illegal_instr = rv32m_dec_illegal_instr;
      case_dec_m_env_call = rv32m_dec_m_env_call;
      case_dec_m_ret = rv32m_dec_m_ret;
      case_dec_d_ret = rv32m_dec_d_ret;
      case_dec_dbreakpoint = rv32m_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32m_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = rv32m_dec_gpr_wr_sel;
      case_dec_gpr_rs1_rd_valid = rv32m_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = rv32m_dec_gpr_rs1_rd_sel;
      case_dec_gpr_rs2_rd_valid = rv32m_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = rv32m_dec_gpr_rs2_rd_sel;
      case_dec_gpr_wr_mux_sel = rv32m_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32m_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32m_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32m_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32m_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32m_dec_operand1_mux_sel;
      case_dec_alu_op_sel = rv32m_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32m_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32m_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32m_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32m_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32m_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32m_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32m_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32m_dec_branch_cond;
      case_dec_fence_i = rv32m_dec_fence_i;
      case_dec_fence = rv32m_dec_fence;
      case_dec_lsu_op = rv32m_dec_lsu_op;
      case_dec_wfi = rv32m_dec_wfi;
    end

   3'b001 :
    begin
      case_dec_mnemonic = rv32c_dec_mnemonic;
      case_dec_immediate = rv32c_dec_immediate;
      case_dec_illegal_instr = rv32c_dec_illegal_instr;
      case_dec_m_env_call = rv32c_dec_m_env_call;
      case_dec_m_ret = rv32c_dec_m_ret;
      case_dec_d_ret = rv32c_dec_d_ret;
      case_dec_dbreakpoint = rv32c_dec_dbreakpoint;
      case_dec_gpr_wr_valid = rv32c_dec_gpr_wr_valid;
      case_dec_gpr_wr_sel = rv32c_dec_gpr_wr_sel;
      case_dec_gpr_rs1_rd_valid = rv32c_dec_gpr_rs1_rd_valid;
      case_dec_gpr_rs1_rd_sel = rv32c_dec_gpr_rs1_rd_sel;
      case_dec_gpr_rs2_rd_valid = rv32c_dec_gpr_rs2_rd_valid;
      case_dec_gpr_rs2_rd_sel = rv32c_dec_gpr_rs2_rd_sel;
      case_dec_gpr_wr_mux_sel = rv32c_dec_gpr_wr_mux_sel;
      case_dec_sw_csr_addr = rv32c_dec_sw_csr_addr;
      case_dec_sw_csr_wr_op = rv32c_dec_sw_csr_wr_op;
      case_dec_sw_csr_rd_op = rv32c_dec_sw_csr_rd_op;
      case_dec_operand0_mux_sel = rv32c_dec_operand0_mux_sel;
      case_dec_operand1_mux_sel = rv32c_dec_operand1_mux_sel;
      case_dec_alu_op_sel = rv32c_dec_alu_op_sel;
      case_dec_shifter_operand_sel = rv32c_dec_shifter_operand_sel;
      case_dec_shifter_unit_places = rv32c_dec_shifter_unit_places;
      case_dec_shifter_unit_op_sel = rv32c_dec_shifter_unit_op_sel;
      case_dec_bcu_operand0_mux_sel = rv32c_dec_bcu_operand0_mux_sel;
      case_dec_bcu_operand1_mux_sel = rv32c_dec_bcu_operand1_mux_sel;
      case_dec_bcu_op_sel = rv32c_dec_bcu_op_sel;
      case_dec_exu_result_mux_sel = rv32c_dec_exu_result_mux_sel;
      case_dec_branch_cond = rv32c_dec_branch_cond;
      case_dec_fence_i = rv32c_dec_fence_i;
      case_dec_fence = rv32c_dec_fence;
      case_dec_lsu_op = rv32c_dec_lsu_op;
      case_dec_wfi = rv32c_dec_wfi;
    end

    default :
    begin
      case_dec_mnemonic = rv32_default;
      case_dec_immediate = 32'd0;
      case_dec_illegal_instr = 1'b1;
      case_dec_m_env_call = 1'b0;
      case_dec_m_ret = 1'b0;
      case_dec_d_ret = 1'b0;
      case_dec_dbreakpoint = 1'b0;
      case_dec_gpr_wr_valid = 1'b0;
      case_dec_gpr_wr_sel = 5'd0;
      case_dec_gpr_rs1_rd_valid = 1'b0;
      case_dec_gpr_rs1_rd_sel = 5'd0;
      case_dec_gpr_rs2_rd_valid = 1'b0;
      case_dec_gpr_rs2_rd_sel = 5'd0;
      case_dec_gpr_wr_mux_sel = gpr_wr_mux_sel_none;
      case_dec_sw_csr_addr = 12'd0;
      case_dec_sw_csr_wr_op = csr_alu_wr_op_none;
      case_dec_sw_csr_rd_op = csr_alu_rd_op_none;
      case_dec_operand0_mux_sel = exu_op0_rs1;
      case_dec_operand1_mux_sel = exu_op1_rs2;
      case_dec_alu_op_sel = exu_alu_op_none;
      case_dec_shifter_operand_sel = shifter_operand_none;
      case_dec_shifter_unit_places = shifter_places_operand_none;
      case_dec_shifter_unit_op_sel = exu_shifter_op_none;
      case_dec_bcu_operand0_mux_sel = bcu_operand0_pc;
      case_dec_bcu_operand1_mux_sel = bcu_operand1_imm;
      case_dec_bcu_op_sel = bcu_op_none;
      case_dec_exu_result_mux_sel = exu_alu_result_mux_none;
      case_dec_branch_cond = branch_cond_none;
      case_dec_fence_i = 1'b0;
      case_dec_fence = 1'b0;
      case_dec_lsu_op = lsu_op_none;
      case_dec_wfi = 1'b0;
    end
  endcase
end


always @*
begin
  if (core_reset == 1'b1) 
  begin 
     mnemonic = rv32_reset;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 5'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 5'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 5'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_resetvec;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
  end 
  else 
  if (trap_taken)
  begin 
     mnemonic = rv32_trap;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 5'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 5'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 5'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = vectored_interrupt_taken ? bcu_operand0_trap_cause : bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_exvec;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
  end 
  else 
  if (debug_exit)
  begin 
     mnemonic = rv32_dbgexit;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 5'd0;
     gpr_rs1_rd_valid = 1'b1;
     gpr_rs1_rd_sel = 5'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 5'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_rs1;
     bcu_operand1_mux_sel = bcu_operand1_dpc;
     bcu_op_sel = bcu_op_add;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_always;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
  end 
  else 
  if (instruction_valid)
  begin 
     mnemonic = case_dec_mnemonic;
     immediate = case_dec_immediate;
     illegal_instr = case_dec_illegal_instr;
     m_env_call = case_dec_m_env_call;
     m_ret = case_dec_m_ret;
     d_ret = case_dec_d_ret;
     dbreakpoint = case_dec_dbreakpoint;
     gpr_wr_valid = case_dec_gpr_wr_valid;
     gpr_wr_sel = case_dec_gpr_wr_sel;
     gpr_rs1_rd_valid = case_dec_gpr_rs1_rd_valid;
     gpr_rs1_rd_sel = case_dec_gpr_rs1_rd_sel;
     gpr_rs2_rd_valid = case_dec_gpr_rs2_rd_valid;
     gpr_rs2_rd_sel = case_dec_gpr_rs2_rd_sel;
     gpr_wr_mux_sel = case_dec_gpr_wr_mux_sel;
     sw_csr_addr = case_dec_sw_csr_addr;
     sw_csr_wr_op = case_dec_sw_csr_wr_op;
     sw_csr_rd_op = case_dec_sw_csr_rd_op;
     operand0_mux_sel = case_dec_operand0_mux_sel;
     operand1_mux_sel = case_dec_operand1_mux_sel;
     alu_op_sel = case_dec_alu_op_sel;
     shifter_operand_sel = case_dec_shifter_operand_sel;
     shifter_unit_places = case_dec_shifter_unit_places;
     shifter_unit_op_sel = case_dec_shifter_unit_op_sel;
     bcu_operand0_mux_sel = case_dec_bcu_operand0_mux_sel;
     bcu_operand1_mux_sel = case_dec_bcu_operand1_mux_sel;
     bcu_op_sel = case_dec_bcu_op_sel;
     exu_result_mux_sel = case_dec_exu_result_mux_sel;
     branch_cond = case_dec_branch_cond;
     fence_i = case_dec_fence_i;
     fence = case_dec_fence;
     lsu_op = case_dec_lsu_op;
     wfi = case_dec_wfi;
  end 
  else begin 
     mnemonic = rv32_noexec;
     immediate = 32'd0;
     illegal_instr = 1'b0;
     m_env_call = 1'b0;
     m_ret = 1'b0;
     d_ret = 1'b0;
     dbreakpoint = 1'b0;
     gpr_wr_valid = 1'b0;
     gpr_wr_sel = 5'd0;
     gpr_rs1_rd_valid = 1'b0;
     gpr_rs1_rd_sel = 5'd0;
     gpr_rs2_rd_valid = 1'b0;
     gpr_rs2_rd_sel = 5'd0;
     gpr_wr_mux_sel = gpr_wr_mux_sel_none;
     sw_csr_addr = 12'd0;
     sw_csr_wr_op = csr_alu_wr_op_none;
     sw_csr_rd_op = csr_alu_rd_op_none;
     operand0_mux_sel = exu_op0_rs1;
     operand1_mux_sel = exu_op1_rs2;
     alu_op_sel = exu_alu_op_none;
     shifter_operand_sel = shifter_operand_none;
     shifter_unit_places = shifter_places_operand_none;
     shifter_unit_op_sel = exu_shifter_op_none;
     bcu_operand0_mux_sel = bcu_operand0_pc;
     bcu_operand1_mux_sel = bcu_operand1_imm;
     bcu_op_sel = bcu_op_none;
     exu_result_mux_sel = exu_alu_result_mux_none;
     branch_cond = branch_cond_none;
     fence_i = 1'b0;
     fence = 1'b0;
     lsu_op = lsu_op_none;
     wfi = 1'b0;
  end 
end

                                                                                         
                                                                                         
                                                                              
//******************************************************************************         
// properties                                                                            
                                                                                         
                                                                                         
                                                                                         
endmodule                                                                                
                                                                                         
`default_nettype wire                                                                    
// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_ifu_iab.sv
//
//   Purpose: 
//
//        
//           
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_core_cfg_pkg::*;

module miv_rv32_ifu_iab
  //****************************************************************************
  // Parameter description
  #(
    parameter I_ADDR_WIDTH         = 32,
    parameter RESP_ERROR_WIDTH     = 1,
    parameter BUFF_DEPTH           = 3,
    parameter LOG2_BUFF_DEPTH      = 2
   )
  
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,
  input  wire logic                                resetn,
  
  input  wire logic                                req_flush_branch, 
  input  wire logic                                req_flush_pipe, 
  
  input  wire logic                                alloc_req, 
  input  wire logic                                alloc_req_fence_i,
  input  wire logic [I_ADDR_WIDTH-1:0]             alloc_req_addr,      
  input  wire logic                                alloc_req_hword_high,
  output      logic [I_ADDR_WIDTH-1:0]             buff_curr_fetch_ptr,
  
  input  wire logic                                alloc_resp, 
  input  wire logic [31:0]                         alloc_resp_data,  
  input  wire logic [RESP_ERROR_WIDTH-1:0]         alloc_resp_error,
  input  wire logic                                resp_complete,  
  input  wire logic                                iab_rd_alignment,
  output      logic [31:0]                         buff_resp_head_data,
  output      logic [RESP_ERROR_WIDTH-1:0]         buff_resp_head_error,
  output      logic [I_ADDR_WIDTH-1:0]             buff_resp_head_addr,
  output      logic                                buff_resp_head_addr_valid,
  output      logic                                buff_resp_head_hword_high_only,
  output      logic                                buff_resp_head_compressed,
  output      logic                                buff_resp_head_uncompressed_full,
  output      logic                                buff_resp_head_uncompressed_half,
  
  output      logic                                buff_full,
  output      logic                                buff_empty,
  output      logic                                buff_resp_empty,
  output      logic [LOG2_BUFF_DEPTH-1:0]          buff_fill_level,
  output      logic [LOG2_BUFF_DEPTH-1:0]          num_emi_req_os,
  output      logic                                emi_req_os,
  output      logic                                no_flush_req_os
  );
   

  
//******************************************************************************
// Declarations

  function logic [LOG2_BUFF_DEPTH:0] calc_fill (logic [LOG2_BUFF_DEPTH:0] a_op, b_op, max);
  
    calc_fill = ((a_op[LOG2_BUFF_DEPTH] ^ b_op[LOG2_BUFF_DEPTH]) & (a_op[LOG2_BUFF_DEPTH-1:0] == b_op[LOG2_BUFF_DEPTH-1:0])) ? max :
                {1'b0,(a_op[LOG2_BUFF_DEPTH-1:0] - b_op[LOG2_BUFF_DEPTH-1:0])};    
  endfunction
  

  logic [LOG2_BUFF_DEPTH-1:0]   buff_req_wr_ptr;  
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_req_wr_ptr; 
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_wr_ptr;  
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_resp_wr_ptr; 
  logic [LOG2_BUFF_DEPTH-1:0]   buff_req_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   next_buff_resp_rd_ptr;
  logic [LOG2_BUFF_DEPTH-1:0]   buff_resp_rd_ptr_plus_one;
  
  logic [LOG2_BUFF_DEPTH-1:0]   req_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_req_count;
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_emi_req_os_count;
  logic [LOG2_BUFF_DEPTH-1:0]   resp_count;
  logic [LOG2_BUFF_DEPTH-1:0]   next_resp_count;  
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_at_flush;
  logic [LOG2_BUFF_DEPTH-1:0]   emi_req_os_count_at_flush;
  logic                         flush_req_os;
  logic                         alloc_resp_qual;
  logic                         resp_complete_qual;
  logic                         alloc_req_qual;
  logic                         req_flush;
  
  logic [I_ADDR_WIDTH-1:0]      buff_entry_addr_req[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;
  logic [BUFF_DEPTH-1:0]        buff_entry_hword_high_only_req;
  logic [31:0]                  buff_entry_data_resp[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;
  logic [RESP_ERROR_WIDTH-1:0]  buff_entry_error_resp[BUFF_DEPTH-1:0] /* synthesis syn_ramstyle="registers" */;


  logic [31:0]                    curr_head_data_resp;
  logic [31:0]                    next_head_data_resp;
  logic [31:0]                    buff_resp_head_data_resp_compressed;       
  logic [31:0]                    buff_resp_head_data_resp_uncompressed_full;
  logic [31:0]                    buff_resp_head_data_resp_uncompressed_half;
  logic [31:0]                    buff_resp_head_data_resp;

  logic [RESP_ERROR_WIDTH-1:0]    curr_head_error_resp;
  logic [RESP_ERROR_WIDTH-1:0]    next_head_error_resp;  
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_compressed;       
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_uncompressed_full;
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp_uncompressed_half;
  logic [RESP_ERROR_WIDTH-1:0]    buff_resp_head_error_resp;

//******************************************************************************
// Main code

  //when allocating a fence i request, the aib is just used as a holding register so doesn't change pointers or counts
  // the next read after the fence hold is released will use this as the fetch_ptr (even though it indicates the buffer is empty)
  
  assign alloc_req_qual  = alloc_req & ~alloc_req_fence_i;
  assign alloc_resp_qual = alloc_resp & no_flush_req_os;
  assign resp_complete_qual = resp_complete & no_flush_req_os;
  
  // need to differentiate between branch flushes and pipe flushes (pipe flushes take priority)
  // Branch flush still allows a new request to be made in the same cycle as the branch flush,
  // pipe flush completely flushes including new requests made in the flush cycle.
  
  assign req_flush = req_flush_branch | req_flush_pipe;

  
  assign next_buff_req_wr_ptr = (buff_req_wr_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : (buff_req_wr_ptr + 'd1);
                                              
  assign next_buff_resp_wr_ptr = alloc_resp_qual   ? ((buff_resp_wr_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : buff_resp_wr_ptr + 'd1) : 
                                                buff_resp_wr_ptr;                                         
                                                 
  assign buff_resp_rd_ptr_plus_one = (buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0] == BUFF_DEPTH-1) ? {LOG2_BUFF_DEPTH{1'b0}} : buff_resp_rd_ptr + 'd1;                                                    
                                                                                               
  assign next_buff_resp_rd_ptr = resp_complete_qual ? buff_resp_rd_ptr_plus_one : 
                                                      buff_resp_rd_ptr;
                                                 
// when flushing, all pointers revert to buff_req_wr_ptr (except buff_req_wr_ptr!)
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_req_wr_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(alloc_req_qual & ~req_flush_pipe)  // can still allocate a new branch request when flushing 
        buff_req_wr_ptr <= next_buff_req_wr_ptr;
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_resp_wr_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush)  
        buff_resp_wr_ptr <= buff_req_wr_ptr;
      else if(alloc_resp_qual)
        buff_resp_wr_ptr <= next_buff_resp_wr_ptr;
  end
  
  // buff_req_rd_ptr is the pointer to the latest fetched instruction (this is effectively fetch_ptr)
  // always follows the req write pointer
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_req_rd_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush | alloc_req_qual)
        buff_req_rd_ptr <= buff_req_wr_ptr;
  end
  
  
  // buff_resp_rd_ptr is the next response to return to the expipe
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_resp_rd_ptr <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      if(req_flush)
        buff_resp_rd_ptr <= buff_req_wr_ptr;
      else if(resp_complete_qual)
        buff_resp_rd_ptr <= next_buff_resp_rd_ptr;
  end
  
  // request/response counters 
  always @*
  begin
    case({alloc_req_qual,resp_complete_qual})
      2'b00 : next_req_count = req_count;
      2'b01 : next_req_count = req_count - 'd1; 
      2'b10 : next_req_count = req_count + 'd1;
      2'b11 : next_req_count = req_count;
      default : next_req_count = {LOG2_BUFF_DEPTH{1'b0}};    
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      req_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      req_count <= req_flush ? ((alloc_req_qual & ~req_flush_pipe) ? 'd1 : {LOG2_BUFF_DEPTH{1'b0}}) : next_req_count;  
  end
  
  // will still generate an emi request whether flush is occuring or not (because do not suppress emi_req for timing reasons)
  // so still need to count flushing requests
  always @*
  begin
    case({alloc_req_qual,alloc_resp})
      2'b00 : next_emi_req_os_count = emi_req_os_count;
      2'b01 : next_emi_req_os_count = emi_req_os_count - 'd1; 
      2'b10 : next_emi_req_os_count = emi_req_os_count + 'd1;
      2'b11 : next_emi_req_os_count = emi_req_os_count;
      default : next_emi_req_os_count = {LOG2_BUFF_DEPTH{1'b0}};   
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      emi_req_os_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      emi_req_os_count <= next_emi_req_os_count;
  end
  
  always @*
  begin
    case({alloc_resp_qual,resp_complete_qual})
      2'b00 : next_resp_count = resp_count;
      2'b01 : next_resp_count = resp_count - 'd1; 
      2'b10 : next_resp_count = resp_count + 'd1;
      2'b11 : next_resp_count = resp_count;
      default : next_resp_count = {LOG2_BUFF_DEPTH{1'b0}};    
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      resp_count <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      resp_count <= req_flush ? {LOG2_BUFF_DEPTH{1'b0}} :  next_resp_count;
  end
  

  
  genvar i_buff;
  generate
  
  for(i_buff = 0; i_buff<BUFF_DEPTH; i_buff++)
  begin : gen_buff_loop

//  
    
    always @(posedge clk)
    begin
      if(alloc_req & ~req_flush_pipe & (buff_req_wr_ptr[LOG2_BUFF_DEPTH-1:0] == i_buff[LOG2_BUFF_DEPTH-1:0]))
      begin
        buff_entry_addr_req[i_buff]               <= alloc_req_addr;
        buff_entry_hword_high_only_req[i_buff]    <= alloc_req_hword_high;
      end
    end  
    
    always @(posedge clk)
    begin
      if(alloc_resp_qual & (buff_resp_wr_ptr[LOG2_BUFF_DEPTH-1:0] == i_buff[LOG2_BUFF_DEPTH-1:0]))
      begin
        buff_entry_data_resp[i_buff]               <= alloc_resp_data;
        buff_entry_error_resp[i_buff]              <= alloc_resp_error;
      end
    end 
    
  end
  endgenerate 
  
  assign buff_curr_fetch_ptr   = buff_entry_addr_req[buff_req_rd_ptr];
  assign buff_full             = req_count == BUFF_DEPTH;
  assign buff_empty            = req_count == {LOG2_BUFF_DEPTH{1'b0}};  
  assign buff_resp_empty       = resp_count == {LOG2_BUFF_DEPTH{1'b0}}; 
  assign buff_fill_level       = req_count;
  assign num_emi_req_os        = emi_req_os_count;
  assign emi_req_os            = ( emi_req_os_count != {LOG2_BUFF_DEPTH{1'b0}}) | flush_req_os; 
  
  // need to drop all outstanding responses still in flight after a flush
  // except request allocated in the flush cycle if a branch flush
  
  always @*
  begin
    case({(alloc_req_qual & req_flush_pipe),alloc_resp})
      2'b00 : emi_req_os_count_at_flush = emi_req_os_count;
      2'b01 : emi_req_os_count_at_flush = emi_req_os_count - 'd1; 
      2'b10 : emi_req_os_count_at_flush = emi_req_os_count + 'd1;
      2'b11 : emi_req_os_count_at_flush = emi_req_os_count;
      default : emi_req_os_count_at_flush = {LOG2_BUFF_DEPTH{1'b0}};   
    endcase
  end
  
    always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      emi_req_os_at_flush <= {LOG2_BUFF_DEPTH{1'b0}};
    else
      emi_req_os_at_flush <= req_flush ? emi_req_os_count_at_flush: 
                                        (alloc_resp & (emi_req_os_at_flush != {LOG2_BUFF_DEPTH{1'b0}})) ? emi_req_os_at_flush -'d1 :
                                                                                  emi_req_os_at_flush;
  end
  
  assign no_flush_req_os = (emi_req_os_at_flush == {LOG2_BUFF_DEPTH{1'b0}});
  assign flush_req_os    = ~no_flush_req_os;
  
  
  assign curr_head_data_resp                        = buff_entry_data_resp[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign next_head_data_resp                        = buff_entry_data_resp[buff_resp_rd_ptr_plus_one[LOG2_BUFF_DEPTH-1:0]];
  assign curr_head_error_resp                       = buff_entry_error_resp[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign next_head_error_resp                       = buff_entry_error_resp[buff_resp_rd_ptr_plus_one[LOG2_BUFF_DEPTH-1:0]];

  assign buff_resp_head_compressed                  = ~buff_empty & ((iab_rd_alignment == iab_rd_alignment_hword) ? (curr_head_data_resp[17:16] != 2'b11) : 
                                                                                                                    (curr_head_data_resp[1:0] != 2'b11));
  assign buff_resp_head_uncompressed_full           = (~buff_empty & (iab_rd_alignment == iab_rd_alignment_word) & (curr_head_data_resp[1:0] == 2'b11)) |
                                                      ((resp_count >= 'd2) & (iab_rd_alignment == iab_rd_alignment_hword) & (curr_head_data_resp[17:16] == 2'b11));
  assign buff_resp_head_uncompressed_half           = ((resp_count == 'd1) & (iab_rd_alignment == iab_rd_alignment_hword) & (curr_head_data_resp[17:16] == 2'b11));  
  
  assign buff_resp_head_data_resp_compressed        = (iab_rd_alignment == iab_rd_alignment_hword) ? {{16{1'b0}}, curr_head_data_resp [31:16]} : {{16{1'b0}}, curr_head_data_resp [15:0]};
  assign buff_resp_head_data_resp_uncompressed_full = (iab_rd_alignment == iab_rd_alignment_word) ? curr_head_data_resp : {next_head_data_resp[15:0],curr_head_data_resp [31:16]};
  assign buff_resp_head_data_resp_uncompressed_half = {{16{1'b0}},curr_head_data_resp [31:16]};
  
  assign buff_resp_head_data_resp                   = ({32{buff_resp_head_compressed}}        & buff_resp_head_data_resp_compressed) |
                                                      ({32{buff_resp_head_uncompressed_full}} & buff_resp_head_data_resp_uncompressed_full) |
                                                      ({32{buff_resp_head_uncompressed_half}} & buff_resp_head_data_resp_uncompressed_half);                                                      
                                                      
  assign buff_resp_head_error_resp_compressed        = curr_head_error_resp;
  assign buff_resp_head_error_resp_uncompressed_full = (iab_rd_alignment == iab_rd_alignment_word) ? curr_head_error_resp : (curr_head_error_resp | next_head_error_resp);
  assign buff_resp_head_error_resp_uncompressed_half = curr_head_error_resp;

  assign buff_resp_head_error_resp                   = ({RESP_ERROR_WIDTH{buff_resp_head_compressed}}        & buff_resp_head_error_resp_compressed) |
                                                       ({RESP_ERROR_WIDTH{buff_resp_head_uncompressed_full}} & buff_resp_head_error_resp_uncompressed_full) |
                                                       ({RESP_ERROR_WIDTH{buff_resp_head_uncompressed_half}} & buff_resp_head_error_resp_uncompressed_half);

  assign buff_resp_head_data                         = buff_resp_head_data_resp;
  assign buff_resp_head_error                        = buff_resp_head_error_resp;
  assign buff_resp_head_addr                         = buff_entry_addr_req[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
  assign buff_resp_head_addr_valid                   = ~buff_empty;
  assign buff_resp_head_hword_high_only              = buff_entry_hword_high_only_req[buff_resp_rd_ptr[LOG2_BUFF_DEPTH-1:0]];
 
 
                          

//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  assert_ifu_iab_head_type_onehot0: assert property (@(posedge clk) disable iff (~resetn)
                                                     $onehot0({buff_resp_head_compressed,buff_resp_head_uncompressed_full,buff_resp_head_uncompressed_half}));
                                                                             
  assert_ifu_iab_no_alloc_req_if_full: assert property (@(posedge clk) disable iff (~resetn)
                                                        alloc_req |-> (!buff_full) | req_flush);
                                                                                                                
  assert_ifu_iab_no_alloc_resp_if_no_req: assert property (@(posedge clk) disable iff (~resetn)
                                                           alloc_resp_qual |-> (req_count >= {LOG2_BUFF_DEPTH{1'b0}}));      
                                                                                                                                                                       
  assert_ifu_iab_no_dealloc_resp_if_empty: assert property (@(posedge clk) disable iff (~resetn)                            
                                                      resp_complete_qual |-> !buff_empty);

  assert_ifu_iab_empt_resp_not_empty: assert property (@(posedge clk) disable iff (~resetn)
                                                        buff_empty |-> buff_resp_empty);
                                                        

                                                    
`endif
 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//   File: miv_rv32_lsu.sv
//
//   Purpose: core Load-Store Unit
//
//
//   Author: 
//
//   Version: 1.0
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

  import miv_rv32_pkg::*;
  import miv_rv32_core_cfg_pkg::*;

module miv_rv32_lsu
  //****************************************************************************
  // Parameter description
  #(
    parameter D_ADDR_WIDTH          = 32

   )
//******************************************************************************
// Port Description
  (
  
  // clk/reset
  input  wire logic                                clk,         
  input  wire logic                                resetn, 
  
  input  wire logic                                parity_en,
  
  input  wire logic                                lsu_flush,
  output      logic                                lsu_op_os,
  output      logic                                lsu_ld_op_os,   
  output      logic                                lsu_fence_op_os,
  
  // External memory interface
  output      logic                                lsu_emi_req_valid,
  input wire  logic                                lsu_emi_req_ready, 
  output      logic [3:0]                          lsu_emi_req_rd_byte_en,  
  output      logic [3:0]                          lsu_emi_req_wr_byte_en,
  output      logic [31:0]                         lsu_emi_req_addr,
  output      logic                                lsu_emi_req_addr_p,
  output      logic                                lsu_emi_req_fence,
  output      logic                                lsu_emi_req_read,
  output      logic                                lsu_emi_req_write,
  output      logic [31:0]                         lsu_emi_req_wr_data,
  output      logic [3:0]                          lsu_emi_req_wr_data_p,

  input wire  logic                                lsu_emi_resp_valid,
  output      logic                                lsu_emi_resp_ready,
  input wire  logic                                lsu_emi_resp_error,
  input wire  logic [31:0]                         lsu_emi_resp_rd_data,
  input wire  logic [3:0]                          lsu_emi_resp_rd_data_p,
  // expipe interface
  
  input wire  logic                                lsu_expipe_req_valid,  
  output      logic                                lsu_expipe_req_ready,  
  input wire  logic[D_ADDR_WIDTH-1:0]              lsu_expipe_req_addr,
  input wire  logic                                lsu_expipe_req_addr_valid,
  input wire  logic [31:0]                         lsu_expipe_req_wr_data,
  input wire  logic                                lsu_expipe_req_wr_data_valid, 
  input wire  t_lsu_op                             lsu_expipe_req_op,   
   
  output      logic                                lsu_expipe_resp_valid,
  input wire  logic                                lsu_expipe_resp_ready,       
  output      logic [31:0]                         lsu_expipe_resp_rd_data,
  output      logic                                lsu_expipe_resp_ld_addr_misalign,
  output      logic                                lsu_expipe_resp_ld_access_fault,
  output      logic                                lsu_expipe_resp_str_amo_addr_misalign,
  output      logic                                lsu_expipe_resp_str_amo_access_fault,
  output      logic                                lsu_expipe_resp_access_mem_error,
  output      logic                                lsu_expipe_resp_access_parity_error,
  output      logic                                lsu_expipe_resp_access_aborted
  );
   


  
//******************************************************************************
// Declarations

  localparam REQ_BUFF_DEPTH        = 2;
  localparam LOG2_REQ_BUFF_DEPTH   = 1;
  localparam OS_COUNT_WIDTH        = 2;
  localparam MAX_OS                = 2;
  

  logic                               expipe_req_accepted;
  logic                               req_buff_ready;
  logic                               alloc_req_buff;      
  logic                               dealloc_resp_buff;   
  t_lsu_op                            alloc_req_buff_state;
  t_lsu_op                            req_buff_resp_state[REQ_BUFF_DEPTH-1:0];     
  logic [1:0]                         req_buff_resp_addr_align[REQ_BUFF_DEPTH-1:0]; 
  logic [3:0]                         req_buff_resp_fault[REQ_BUFF_DEPTH-1:0];  
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_state_valid;  
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_drop;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_resp_exception_os;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_load_os;
  logic [REQ_BUFF_DEPTH-1:0]          req_buff_fence_os;
  logic [LOG2_REQ_BUFF_DEPTH-1:0]     buff_rd_ptr;  
  logic [LOG2_REQ_BUFF_DEPTH-1:0]     buff_wr_ptr;
  logic [REQ_BUFF_DEPTH-1:0]          buff_rd_strb; 
  logic [REQ_BUFF_DEPTH-1:0]          buff_wr_strb;
  t_lsu_op                            req_resp_state;
  logic [1:0]                         req_resp_addr_align;  
  logic [3:0]                         req_resp_fault;
  logic                               req_resp_drop;
  logic                               req_resp_state_valid;  
  logic                               req_resp_ld_req_buff_access_fault;
  logic                               req_resp_ld_req_buff_addr_misalign;
  logic                               req_resp_str_req_buff_access_fault;
  logic                               req_resp_str_req_buff_addr_misalign;
  logic                               req_resp_exception;
  logic                               lsu_emi_req_accepted;
  logic                               lsu_emi_resp_accepted;
  logic                               lsu_emi_resp_accepted_qual;
  logic [OS_COUNT_WIDTH-1:0]          emi_req_os_count;
  logic [OS_COUNT_WIDTH-1:0]          next_emi_req_os_count;
  logic [OS_COUNT_WIDTH-1:0]          emi_req_os_count_at_flush;
  logic [OS_COUNT_WIDTH-1:0]          next_emi_req_os_count_at_flush;
  logic                               inc_os_count;
  logic                               dec_os_count;
  logic                               emi_req_os_at_flush;
  logic                               next_emi_req_os;

  logic                               alloc_ld_req_buff_addr_misalign;
  logic                               alloc_ld_req_buff_access_fault; 
  logic                               alloc_str_req_buff_addr_misalign;
  logic                               alloc_str_req_buff_access_fault;
  logic                               alloc_exception;
  logic                               exception_os;
  logic [1:0]                         alloc_req_addr_align;
  logic [3:0]                         alloc_req_fault;
  
  logic [63:0]                        lsu_emi_resp_rd_data_double_s;
  logic [63:0]                        lsu_emi_resp_rd_data_double_u;
  
  logic                               lsu_resp_valid;                 
  logic [31:0]                        lsu_resp_rd_data;               
  logic                               lsu_resp_access_mem_error;      
  logic                               lsu_resp_access_parity_error; 
  logic                               lsu_resp_ld_req_buff_access_fault;  
  logic                               lsu_resp_ld_req_buff_addr_misalign; 
  logic                               lsu_resp_str_req_buff_access_fault; 
  logic                               lsu_resp_str_req_buff_addr_misalign;  
  logic [3:0]                         lsu_emi_resp_byte_parity_error;
 

  
//******************************************************************************
// Main code

// When a request is accepted, put it in the request buffer (required in order to know what to do 
// with the response in the retr stage)

// Core LSU is intended for simple memory systems, therefore all requests must complete in order, including
// reads and writes. RISC-V memory model does not require this, therefore the subsystem may choose to 
// reorder read and write requests without causal dependencies by indicating to the core that the 
// request has completed, though it must do so with the response in the order requested
// The subsystem may also choose to provide an early response for writes. In this case it is responsible for ensuring
// read-after-write ordering of requests.

// Allocate req buffer when memory accepts a request (all request types)           
  
  assign expipe_req_accepted    = lsu_expipe_req_valid & lsu_expipe_req_ready;  
  
  assign req_buff_ready         = ~(&req_buff_resp_state_valid); 
  assign lsu_expipe_req_ready   = req_buff_ready &    
                                  (lsu_emi_req_ready | alloc_exception) &
                                  ~exception_os;   
                                  
  
  assign lsu_op_os               = |req_buff_resp_state_valid;   
  assign lsu_ld_op_os            = |req_buff_load_os;  
  assign lsu_fence_op_os         = |req_buff_fence_os;  
  
  // compute parity error
  
  assign lsu_emi_resp_byte_parity_error = {4{parity_en}} & {((^lsu_emi_resp_rd_data[31:24]) != lsu_emi_resp_rd_data_p[3]),
                                                            ((^lsu_emi_resp_rd_data[23:16]) != lsu_emi_resp_rd_data_p[2]),
                                                            ((^lsu_emi_resp_rd_data[15:8]) != lsu_emi_resp_rd_data_p[1]),
                                                            ((^lsu_emi_resp_rd_data[7:0]) != lsu_emi_resp_rd_data_p[0])};
                         

  always @*
  begin
    case(lsu_expipe_req_op)
      lsu_op_none : 
      begin
        lsu_emi_req_valid                  = 1'b0;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b0;
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;
        alloc_req_buff                     = 1'b0;         
        alloc_ld_req_buff_addr_misalign    = 1'b0; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_byte_s : 
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) &
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000;          
        lsu_emi_req_fence                  = 1'b0;  
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush)); 
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
                 
      lsu_op_ld_hword_s : 
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000 ) &
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0; 
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));   
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[0] == 1'b1;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
          
      lsu_op_ld_word :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b1111 & {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;   
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[1:0] != 2'b00; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_byte_u :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;  
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = 1'b0; 
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_ld_hword_u :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_wr_byte_en             = 4'b0000; 
        lsu_emi_req_fence                  = 1'b0;  
        lsu_emi_req_read                   = 1'b1;
        lsu_emi_req_write                  = 1'b0;    
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));        
        alloc_ld_req_buff_addr_misalign    = lsu_expipe_req_addr[0] == 1'b1;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_str_byte :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = ((lsu_expipe_req_addr[1:0]  == 2'b00) ? 4'b0001 :
                                               (lsu_expipe_req_addr[1:0]  == 2'b01) ? 4'b0010 :
                                                 (lsu_expipe_req_addr[1:0]  == 2'b10) ? 4'b0100 :
                                                   (lsu_expipe_req_addr[1:0]  == 2'b11) ? 4'b1000 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1;    
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));    
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      lsu_op_str_hword :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = ((lsu_expipe_req_addr[1]  == 1'b0) ? 4'b0011 :
                                               (lsu_expipe_req_addr[1]  == 1'b1) ? 4'b1100 : 4'b0000) & 
                                             {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;    
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1; 
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));  
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = lsu_expipe_req_addr[0] == 1'b1; 
      end
      
      lsu_op_str_word :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b1111 & {4{~alloc_exception}};
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b1;  
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush)); 
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = lsu_expipe_req_addr[1:0] != 2'b00;
      end
      
      // Fence will be implemented like a non-posted write with no strobes (also marked a fence)
      // external memory will respond when all preceding memory operations complete
      lsu_op_fence :
      begin
        lsu_emi_req_valid                  = lsu_expipe_req_valid & req_buff_ready & ~alloc_exception & ~exception_os;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b1;    
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;   
        alloc_req_buff                     = expipe_req_accepted & ((lsu_emi_req_valid & lsu_emi_req_ready) | (alloc_exception & ~lsu_flush));        
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
      default :     
      begin
        lsu_emi_req_valid                  = 1'b0;
        lsu_emi_req_rd_byte_en             = 4'b0000;
        lsu_emi_req_wr_byte_en             = 4'b0000;
        lsu_emi_req_fence                  = 1'b0;   
        lsu_emi_req_read                   = 1'b0;
        lsu_emi_req_write                  = 1'b0;    
        alloc_req_buff                     = 1'b0;       
        alloc_ld_req_buff_addr_misalign    = 1'b0;
        alloc_str_req_buff_addr_misalign   = 1'b0;
      end
      
    endcase    
  end
  
    // no memory management/protection supported in core
  assign alloc_ld_req_buff_access_fault     = 1'b0; 
  assign alloc_str_req_buff_access_fault    = 1'b0;
  
  assign alloc_exception      = alloc_ld_req_buff_access_fault |
                                alloc_ld_req_buff_addr_misalign |
                                alloc_str_req_buff_access_fault |
                                alloc_str_req_buff_addr_misalign;
  
  assign lsu_emi_req_addr      = lsu_expipe_req_addr;
  assign lsu_emi_req_addr_p    = (^lsu_expipe_req_addr) & parity_en;
  assign lsu_emi_req_wr_data   = lsu_expipe_req_wr_data;
  assign lsu_emi_req_wr_data_p = {(^lsu_expipe_req_wr_data[31:24]),(^lsu_expipe_req_wr_data[23:16]),(^lsu_expipe_req_wr_data[15:8]),(^lsu_expipe_req_wr_data[7:0])} & {4{parity_en}};
  
  assign alloc_req_buff_state = lsu_expipe_req_op;         
  assign alloc_req_addr_align = lsu_expipe_req_addr[1:0];  
  assign alloc_req_fault      = {alloc_ld_req_buff_access_fault,
                                 alloc_ld_req_buff_addr_misalign,
                                 alloc_str_req_buff_access_fault,
                                 alloc_str_req_buff_addr_misalign};
//  assign dealloc_resp_buff    = lsu_expipe_resp_valid;


// request buffer
// store request here and match with response
// EMI response must always be 1 or more cycles after request
// Optionally implement as 2 entry buffer, even though only one request max outstanding
// So that request timing can be decoupled from response
// 


  logic [LOG2_REQ_BUFF_DEPTH-1:0] next_buff_rd_ptr;
  logic [LOG2_REQ_BUFF_DEPTH-1:0] next_buff_wr_ptr;
  
  assign next_buff_rd_ptr = (buff_rd_ptr == (REQ_BUFF_DEPTH-1)) ? {LOG2_REQ_BUFF_DEPTH{1'b0}} : buff_rd_ptr+'d1;
  assign next_buff_wr_ptr = (buff_wr_ptr == (REQ_BUFF_DEPTH-1)) ? {LOG2_REQ_BUFF_DEPTH{1'b0}} : buff_wr_ptr+'d1;

  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_rd_ptr <= {LOG2_REQ_BUFF_DEPTH{1'b0}};
    else
      if(dealloc_resp_buff)
        buff_rd_ptr <= next_buff_rd_ptr;
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      buff_wr_ptr <= {LOG2_REQ_BUFF_DEPTH{1'b0}};
    else
      if(alloc_req_buff)
        buff_wr_ptr <= next_buff_wr_ptr;
  end
  


  genvar i_req_buff;
  generate
  
  for(i_req_buff = 0; i_req_buff<REQ_BUFF_DEPTH; i_req_buff++)
  begin : gen_req_buff_loop
  
  
    assign buff_wr_strb[i_req_buff] = alloc_req_buff & (buff_wr_ptr == i_req_buff[LOG2_REQ_BUFF_DEPTH-1:0]);
    assign buff_rd_strb[i_req_buff] = dealloc_resp_buff & (buff_rd_ptr == i_req_buff[LOG2_REQ_BUFF_DEPTH-1:0]);
    
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
      begin
        req_buff_resp_fault[i_req_buff]       <= 4'b0000;
      end
      else
        if(buff_wr_strb[i_req_buff]) // still update even if flushing, because use this to drop requests with exceptions at allocation
        begin
          req_buff_resp_fault[i_req_buff]       <= alloc_req_fault;
        end
    end  
    
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
      begin
        req_buff_resp_state[i_req_buff]       <= lsu_op_none;
        req_buff_resp_addr_align[i_req_buff]  <= 2'b00;
        req_buff_resp_drop[i_req_buff]        <= 1'b0;
      end
      else
        if(lsu_flush)
        begin
          req_buff_resp_state[i_req_buff]       <= lsu_op_none;
          req_buff_resp_addr_align[i_req_buff]  <= 2'b00;
          req_buff_resp_drop[i_req_buff]        <= 1'b1;
        end 
        else if(buff_wr_strb[i_req_buff])
        begin
          req_buff_resp_state[i_req_buff]       <= alloc_req_buff_state;
          req_buff_resp_addr_align[i_req_buff]  <= alloc_req_addr_align;
          req_buff_resp_drop[i_req_buff]        <= 1'b0;
        end
    end  
  
    always @(posedge clk or negedge resetn)
    begin
      if(~resetn)
        req_buff_resp_state_valid[i_req_buff] <= 1'b0;
      else
        req_buff_resp_state_valid[i_req_buff] <= (req_buff_resp_state_valid[i_req_buff] & ~buff_rd_strb[i_req_buff]) | buff_wr_strb[i_req_buff];
    end 
  
    assign req_buff_resp_exception_os[i_req_buff] = req_buff_resp_state_valid[i_req_buff] & (|req_buff_resp_fault[i_req_buff]);
    assign req_buff_load_os[i_req_buff] = ((req_buff_resp_state[i_req_buff] == lsu_op_ld_byte_s)  |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_hword_s) |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_word)    |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_byte_u)  |
                                           (req_buff_resp_state[i_req_buff] == lsu_op_ld_hword_u)) & req_buff_resp_state_valid[i_req_buff];
    
    assign req_buff_fence_os[i_req_buff] = (req_buff_resp_state[i_req_buff] == lsu_op_fence) & req_buff_resp_state_valid[i_req_buff];
    
  end
  endgenerate 
  
  // block emi requests and do not accept new request from expipe when an entry in the response buffer will cause an exception
  // (simplifies exception handling and reduces timing pressure on exception flushing in the expipe)  
  assign exception_os                          = |req_buff_resp_exception_os;  
  
  assign req_resp_state                        = req_buff_resp_state[buff_rd_ptr];     
  assign req_resp_addr_align                   = req_buff_resp_addr_align[buff_rd_ptr];
  assign {req_resp_ld_req_buff_access_fault,      
          req_resp_ld_req_buff_addr_misalign,
          req_resp_str_req_buff_access_fault,
          req_resp_str_req_buff_addr_misalign} = req_buff_resp_fault[buff_rd_ptr]; 
  assign req_resp_state_valid                  = req_buff_resp_state_valid[buff_rd_ptr];
  assign req_resp_drop                         = req_buff_resp_drop[buff_rd_ptr];
  
  assign req_resp_exception                    = |req_buff_resp_fault[buff_rd_ptr];
  
  // Return response when emi responds if something in or allocating to the buffer (for a load, store, or fence), otherwise respond straight away  in retr stage  
  // if a request is not expecting an emi response (align error, access fault)        
  // May get a response not associated with a request buffer entry if a reset occurs after a request but before a response,
  // to avoid deadlock, drop such responses silently.
  

  
  assign lsu_emi_resp_ready = 1'b1;
  assign lsu_emi_resp_accepted = lsu_emi_resp_valid & lsu_emi_resp_ready;  
  assign lsu_emi_resp_accepted_qual = lsu_emi_resp_accepted; // & ~emi_req_os_at_flush;  // mask with emi_req_os_at_flush so unmatched responses are dropped
  
  assign lsu_emi_resp_rd_data_double_s = {{32{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data};
  assign lsu_emi_resp_rd_data_double_u = {{32{1'b0}},lsu_emi_resp_rd_data};
  
  
   always @*
  begin
    case(req_resp_state)
      
      lsu_op_ld_byte_s :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align == 2'b00) ? {{24{lsu_emi_resp_rd_data[7]}},lsu_emi_resp_rd_data[7:0]} :
                                               (req_resp_addr_align == 2'b01) ? {{24{lsu_emi_resp_rd_data[15]}},lsu_emi_resp_rd_data[15:8]} :
                                               (req_resp_addr_align == 2'b10) ? {{24{lsu_emi_resp_rd_data[23]}},lsu_emi_resp_rd_data[23:16]} :
                                                                                {{24{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data[31:24]};         
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align == 2'b00) ? lsu_emi_resp_byte_parity_error[0] :
                                               (req_resp_addr_align == 2'b01) ? lsu_emi_resp_byte_parity_error[1] :
                                               (req_resp_addr_align == 2'b10) ? lsu_emi_resp_byte_parity_error[2] :
                                                                                lsu_emi_resp_byte_parity_error[3];  
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end  
      lsu_op_ld_hword_s :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = lsu_emi_resp_rd_data_double_s[(16*req_resp_addr_align[1])+:32]; 
        lsu_resp_rd_data                     = (req_resp_addr_align[1] == 1'b0) ? {{16{lsu_emi_resp_rd_data[15]}},lsu_emi_resp_rd_data[15:0]} :
                                                                                  {{16{lsu_emi_resp_rd_data[31]}},lsu_emi_resp_rd_data[31:16]};
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align[1] == 1'b0) ? (|lsu_emi_resp_byte_parity_error[1:0]) :
                                                                                  (|lsu_emi_resp_byte_parity_error[3:2]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      lsu_op_ld_word :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = lsu_emi_resp_rd_data;
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (|lsu_emi_resp_byte_parity_error[3:0]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end    
      lsu_op_ld_byte_u :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align == 2'b00) ? {{24{1'b0}},lsu_emi_resp_rd_data[7:0]} :
                                               (req_resp_addr_align == 2'b01) ? {{24{1'b0}},lsu_emi_resp_rd_data[15:8]} :
                                               (req_resp_addr_align == 2'b10) ? {{24{1'b0}},lsu_emi_resp_rd_data[23:16]} :
                                                                                {{24{1'b0}},lsu_emi_resp_rd_data[31:24]};  
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (|lsu_emi_resp_byte_parity_error[3:0]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end  
      lsu_op_ld_hword_u :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid);
        lsu_resp_rd_data                     = (req_resp_addr_align[1] == 1'b0) ? {{16{1'b0}},lsu_emi_resp_rd_data[15:0]} :
                                                                                  {{16{1'b0}},lsu_emi_resp_rd_data[31:16]};
        lsu_resp_access_mem_error            = lsu_emi_resp_error & req_resp_state_valid;
        lsu_resp_access_parity_error         = (req_resp_addr_align[1] == 1'b0) ? (|lsu_emi_resp_byte_parity_error[1:0]) :
                                                                                  (|lsu_emi_resp_byte_parity_error[3:2]);
        lsu_resp_ld_req_buff_access_fault    = req_resp_ld_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_ld_req_buff_addr_misalign   = req_resp_ld_req_buff_addr_misalign & req_resp_state_valid;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      
      lsu_op_fence :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid; //| (resp_exception & req_resp_state_valid); // fence waits until memory response
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
      end 
      
      lsu_op_str_byte :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;          
      end
      
      lsu_op_str_hword :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;  
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;  
      end
      
      lsu_op_str_word :
      begin
        lsu_resp_valid                       = (lsu_emi_resp_accepted_qual | req_resp_exception) & req_resp_state_valid;
        lsu_resp_rd_data                     = {32{1'b0}};  
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = req_resp_str_req_buff_access_fault & req_resp_state_valid;
        lsu_resp_str_req_buff_addr_misalign  = req_resp_str_req_buff_addr_misalign & req_resp_state_valid;  
        dealloc_resp_buff                    = lsu_expipe_resp_valid & lsu_expipe_resp_ready;   
      end
      
      lsu_op_none :
      begin
        lsu_resp_valid                       = 1'b0;
        lsu_resp_rd_data                     = {32{1'b0}};
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = req_resp_drop & req_resp_state_valid & (lsu_emi_resp_accepted | req_resp_exception);
      end
           
      default :
      begin
        lsu_resp_valid                       = 1'b0;
        lsu_resp_rd_data                     = {32{1'b0}};
        lsu_resp_access_mem_error            = 1'b0;
        lsu_resp_access_parity_error         = 1'b0;
        lsu_resp_ld_req_buff_access_fault    = 1'b0;
        lsu_resp_ld_req_buff_addr_misalign   = 1'b0;
        lsu_resp_str_req_buff_access_fault   = 1'b0;
        lsu_resp_str_req_buff_addr_misalign  = 1'b0;
        dealloc_resp_buff                    = 1'b0;
      end 
    endcase
  end                                      
  
  assign lsu_expipe_resp_valid                        = lsu_resp_valid;               
  assign lsu_expipe_resp_rd_data                      = lsu_resp_rd_data;       
  assign lsu_expipe_resp_ld_addr_misalign             = lsu_resp_ld_req_buff_addr_misalign;
  assign lsu_expipe_resp_ld_access_fault              = lsu_resp_ld_req_buff_access_fault;
  assign lsu_expipe_resp_str_amo_addr_misalign        = lsu_resp_str_req_buff_addr_misalign;
  assign lsu_expipe_resp_str_amo_access_fault         = lsu_resp_str_req_buff_access_fault;
  assign lsu_expipe_resp_access_mem_error             = lsu_resp_access_mem_error;
  assign lsu_expipe_resp_access_parity_error          = lsu_resp_access_parity_error;
  assign lsu_expipe_resp_access_aborted               = 1'b0; 
  

 
//******************************************************************************
// properties
`ifdef miv_rv32_RTL_PROPS

  localparam MAX_SEQ_LEN = 10;

  logic [1:0]  prop_trx_os;
  logic [1:0]  prop_next_trx_os;
  logic        prop_resp_is_ld;
  logic        prop_req_is_str;
  logic        prop_req_is_ld;
  logic        prop_resp_is_fence;
  logic        prop_resp_is_str;
  logic        prop_resp_is_dropped;
  logic        prop_ld_str_req_align_access_error;
  logic        prop_mem_parity_error;
  logic        prop_lsu_emi_req_accepted;
  logic        prop_expipe_req_accepted;
  logic        prop_expipe_resp_accepted;
  
  assign prop_lsu_emi_req_accepted   = lsu_emi_req_valid & lsu_emi_req_ready;
  assign prop_expipe_req_accepted    = lsu_expipe_req_valid & lsu_expipe_req_ready; 
  assign prop_expipe_resp_accepted   = lsu_expipe_resp_valid & lsu_expipe_resp_ready;
  
  assign prop_resp_is_ld = ((req_resp_state == lsu_op_ld_byte_s)  |
                            (req_resp_state == lsu_op_ld_hword_s) |
                            (req_resp_state == lsu_op_ld_word)    |
                            (req_resp_state == lsu_op_ld_byte_u)  |
                            (req_resp_state == lsu_op_ld_hword_u)) & req_resp_state_valid;

  assign prop_resp_is_str = ((req_resp_state == lsu_op_str_byte)  |
                             (req_resp_state == lsu_op_str_hword) |
                             (req_resp_state == lsu_op_str_word)) & req_resp_state_valid;                            
                            
                          
  assign prop_req_is_str = (lsu_expipe_req_op ==lsu_op_str_byte) |  
                           (lsu_expipe_req_op ==lsu_op_str_hword) | 
                           (lsu_expipe_req_op ==lsu_op_str_word);
                           
  assign prop_req_is_ld = (lsu_expipe_req_op == lsu_op_ld_byte_s)  |  
                           (lsu_expipe_req_op == lsu_op_ld_hword_s) | 
                           (lsu_expipe_req_op == lsu_op_ld_word)    |
                           (lsu_expipe_req_op == lsu_op_ld_byte_u)  |
                           (lsu_expipe_req_op == lsu_op_ld_hword_u);                          
                            
  assign prop_resp_is_fence = (req_resp_state == lsu_op_fence) & req_resp_state_valid; 
  
  assign prop_resp_is_dropped = (req_resp_state == lsu_op_none)& req_resp_drop & req_resp_state_valid ;     
  
  assign prop_ld_str_req_align_access_error =  lsu_expipe_resp_ld_addr_misalign |
                                               lsu_expipe_resp_ld_access_fault |
                                               lsu_expipe_resp_str_amo_addr_misalign |
                                               lsu_expipe_resp_str_amo_access_fault; 
                                                                                             
  assign prop_mem_parity_error = lsu_expipe_resp_access_mem_error | 
                                 lsu_expipe_resp_access_parity_error;
  
  
  // when the emi makes a request, must always be able to accept the response
  assert_lsu_req_must_allow_response: assert property (@(posedge clk) disable iff (~resetn)
                                                       lsu_emi_req_valid |->  ##1 lsu_emi_resp_ready);        
  
  // cannot have a response from store_reqerr and load_fence simultaneously
  //assert_lsu_single_response: assert property (@(posedge clk) disable iff (~resetn)
  //                                             $onehot0({lsu_store_reqerr_resp_valid , lsu_resp_valid}));
                                               
  
  // can only have an emi response for a load store or fence request
  assert_lsu_emi_response_ld_fence: assert property (@(posedge clk) disable iff (~resetn)
                                                     lsu_emi_resp_accepted_qual |->  prop_resp_is_ld | prop_resp_is_fence | prop_resp_is_str | prop_resp_is_dropped);     
                                                     
  // must be an emi request or error response when expipe request
  //assert_lsu_req_must_have_emireq_or_err: assert property (@(posedge clk) disable iff (~resetn)
  //                                                         prop_expipe_req_accepted |->  prop_lsu_emi_req_accepted | prop_ld_str_req_align_access_error);  
                                                                                                                                               
  
  // can only have a response if there is a request
  always @*
  begin
    case({prop_expipe_resp_accepted, prop_expipe_req_accepted})
      2'b00 : prop_next_trx_os = prop_trx_os;
      2'b01 : prop_next_trx_os = prop_trx_os + 2'd1;
      2'b10 : prop_next_trx_os = prop_trx_os - 2'd1;
      2'b11 : prop_next_trx_os = prop_trx_os;
      default : prop_next_trx_os = prop_trx_os;
    endcase
  end
  
  always @(posedge clk or negedge resetn)
  begin
    if(~resetn)
      prop_trx_os <= 2'd0;
    else
      if(lsu_flush)
        prop_trx_os <= 2'd0;
      else
        prop_trx_os <= prop_next_trx_os;
  end
  
  assert_lsu_resp_only_if_req: assert property (@(posedge clk) disable iff (~resetn)
                                                prop_expipe_resp_accepted |-> (prop_trx_os > 2'd0));    
  
  // only up to REQ_BUFF_DEPTH requests outstanding
  assert_lsu_enough_buff_space: assert property (@(posedge clk) disable iff (~resetn)
                                           prop_expipe_req_accepted |-> (prop_trx_os < REQ_BUFF_DEPTH));
  

// emi response must always be 1 or more cycles after request  
  
// can never write and read the same req buff location at the same time


// if a request is presented to the LSU eventually it must be accepted
  assert_lsu_req_eventually_accepted: assert property (@(posedge clk) disable iff (~resetn)
                                                     (lsu_expipe_req_valid & ~lsu_flush) |-> ##[0:$] (lsu_expipe_req_valid & lsu_emi_req_ready));
                                                     
                                                     
// if a request is presented to the LSU eventually there will be a response
  assert_lsu_req_eventually_response: assert property (@(posedge clk) disable iff (~resetn)
                                                        (lsu_expipe_req_valid & ~lsu_flush) |-> ##[0:$] (lsu_expipe_resp_valid & lsu_expipe_resp_ready)); 
  //-------------                                                              
  // covers
  //------------
  
   sequence seq_any_req_consec(cycles);
      prop_lsu_emi_req_accepted[*cycles] ;
   endsequence
   
   sequence seq_any_req_nonconsec(cycles);
      prop_lsu_emi_req_accepted[->cycles] ;
   endsequence
   
   sequence seq_lb_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0001) |
                               (lsu_emi_req_rd_byte_en == 4'b0010) |  
                               (lsu_emi_req_rd_byte_en == 4'b0100) |
                               (lsu_emi_req_rd_byte_en == 4'b1000)))[*cycles] ;
   endsequence
   
   sequence seq_lb_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0001) |
                               (lsu_emi_req_rd_byte_en == 4'b0010) |  
                               (lsu_emi_req_rd_byte_en == 4'b0100) |
                               (lsu_emi_req_rd_byte_en == 4'b1000)))[->cycles] ;
   endsequence
   
   sequence seq_lh_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0011) |
                               (lsu_emi_req_rd_byte_en == 4'b1100)))[*cycles] ;
   endsequence
   
   sequence seq_lh_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_rd_byte_en == 4'b0011) |
                               (lsu_emi_req_rd_byte_en == 4'b1100)))[->cycles] ;
   endsequence

   sequence seq_lw_req_consec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_rd_byte_en == 4'b1111))[*cycles] ;
   endsequence
   
   sequence seq_lw_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_rd_byte_en == 4'b1111))[->cycles] ;
   endsequence
   
   sequence seq_sb_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0001) |
                               (lsu_emi_req_wr_byte_en == 4'b0010) |  
                               (lsu_emi_req_wr_byte_en == 4'b0100) |
                               (lsu_emi_req_wr_byte_en == 4'b1000)))[*cycles] ;
   endsequence
   
   sequence seq_sb_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0001) |
                               (lsu_emi_req_wr_byte_en == 4'b0010) |  
                               (lsu_emi_req_wr_byte_en == 4'b0100) |
                               (lsu_emi_req_wr_byte_en == 4'b1000)))[->cycles] ;
   endsequence
   
   sequence seq_sh_req_consec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0011) |
                               (lsu_emi_req_wr_byte_en == 4'b1100)))[*cycles] ;
   endsequence
   
   sequence seq_sh_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & ((lsu_emi_req_wr_byte_en == 4'b0011) |
                               (lsu_emi_req_wr_byte_en == 4'b1100)))[->cycles] ;
   endsequence

   sequence seq_sw_req_consec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_wr_byte_en == 4'b1111))[*cycles] ;
   endsequence
   
   sequence seq_sw_req_nonconsec(cycles);
      (prop_lsu_emi_req_accepted & (lsu_emi_req_wr_byte_en == 4'b1111))[->cycles] ;
   endsequence

   sequence seq_any_resp_consec(cycles);
      lsu_emi_resp_accepted_qual[*cycles] ;
   endsequence
     
   sequence seq_any_resp_nonconsec(cycles);
      lsu_emi_resp_accepted_qual[->cycles] ;
   endsequence
   
   sequence seq_any_resp_consec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & ~lsu_emi_resp_error)[*cycles] ;
   endsequence
     
   sequence seq_any_resp_nonconsec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & ~lsu_emi_resp_error)[->cycles] ;
   endsequence
   
   sequence seq_ld_resp_consec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & prop_resp_is_ld & ~lsu_emi_resp_error)[*cycles] ;
   endsequence
     
   sequence seq_ld_resp_nonconsec_no_error(cycles);
      (lsu_emi_resp_accepted_qual & prop_resp_is_ld & ~lsu_emi_resp_error)[->cycles] ;
   endsequence

  genvar i_req_seq;
  generate  
  for (i_req_seq = 1; i_req_seq < MAX_SEQ_LEN; i_req_seq++) begin : gen_per_req_cover

    cover_req_seq_any_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_req_consec(i_req_seq));
                                                  
    cover_req_seq_any_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_lb_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lb_req_consec(i_req_seq));
                                                  
    cover_req_seq_lb_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lb_req_nonconsec(i_req_seq));                                                    
                                                     
    cover_req_seq_lh_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lh_req_consec(i_req_seq));
                                                  
    cover_req_seq_lh_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lh_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_lw_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_lw_req_consec(i_req_seq));
                                                  
    cover_req_seq_lw_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_lw_req_nonconsec(i_req_seq)); 
                                                     
    cover_req_seq_sb_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sb_req_consec(i_req_seq));
                                                  
    cover_req_seq_sb_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sb_req_nonconsec(i_req_seq));                                                    
                                                     
    cover_req_seq_sh_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sh_req_consec(i_req_seq));
                                                  
    cover_req_seq_sh_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sh_req_nonconsec(i_req_seq));
                                                     
    cover_req_seq_sw_req_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_sw_req_consec(i_req_seq));
                                                  
    cover_req_seq_sw_req_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_sw_req_nonconsec(i_req_seq));                                                                                                          
                                                                                                        
    cover_resp_seq_any_resp_consec: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec(i_req_seq));
                                                  
    cover_resp_seq_any_resp_nonconsec: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec(i_req_seq));   
                                                     
    cover_resp_seq_any_resp_consec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec_no_error(i_req_seq));
                                                  
    cover_resp_seq_any_resp_nonconsec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec_no_error(i_req_seq));   
                                                                                                                                                      
    cover_resp_seq_ld_resp_consec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                  seq_any_resp_consec_no_error(i_req_seq));
                                                  
    cover_resp_seq_ld_resp_nonconsec_no_error: cover property (@(posedge clk) disable iff (~resetn) 
                                                     seq_any_resp_nonconsec_no_error(i_req_seq));                                                                                                                                                  
  end
  endgenerate 
  
  cover_lsu_alloc_misalign_resp: cover property (@(posedge clk) disable iff (~resetn)  
                                                  (prop_expipe_req_accepted & lsu_expipe_req_addr[0] & lsu_expipe_req_op) ##1
                                                   (prop_expipe_resp_accepted & lsu_expipe_resp_ld_addr_misalign));

`endif

 
endmodule

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for ram data I/O.  
//
// PARAMETER DESCRIPTION:
//
// DATA_WIDTH          Number of data bits per word.
//
// INPUT PORT DESCRIPTION:
//
// sys_din[]           RAM write data. 
// ram_dout            Data output from ram
//
// OUTPUT PORT DESCRIPTION:
//
// sys_dout[]          RAM read data.
// ram_din[]           Data input to RAM
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdualdata_behav
  #(
    parameter DATA_WIDTH = 8,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_bist_shared_pkg::BIST_TRUE
  )
  (
    input  wire logic                  ram_init_busy_a,
    input  wire logic                  ram_init_busy_b,
    // user ram interface
    input  wire logic [DATA_WIDTH-1:0] sys_adin,
    output      logic [DATA_WIDTH-1:0] sys_adout,
    input  wire logic [DATA_WIDTH-1:0] sys_bdin,
    output      logic [DATA_WIDTH-1:0] sys_bdout,
    // internal ram interface
    input  wire logic [DATA_WIDTH-1:0] ram_adout,
    output      logic [DATA_WIDTH-1:0] ram_adin,
    input  wire logic [DATA_WIDTH-1:0] ram_bdout,
    output      logic [DATA_WIDTH-1:0] ram_bdin
  );
  
  // implementation
  import miv_rv32_bist_shared_pkg::*;

  localparam logic GRND = 1'b0;

  generate
    genvar i;

    // generate data input mux
    for (i = 0; i < DATA_WIDTH; i++) begin : din_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        adin_mux
        (
          .sigin(sys_adin[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(ram_adin[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bdin_mux
        (
          .sigin(sys_bdin[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_bdin[i])
        ); 
    end : din_gen

    // generate data input mux
    for (i = 0; i < DATA_WIDTH; i++) begin : dout_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        adout_mux
        (
          .sigin(ram_adout[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(sys_adout[i])
        ); 
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bdout_mux
        (
          .sigin(ram_bdout[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(sys_bdout[i])
        ); 
    end : dout_gen
  endgenerate
  
endmodule : miv_rv32_bistdualdata_behav

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for ram contrl signals. 
//
// PARAMETER DESCRIPTION:
//
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
//
// INPUT PORT DESCRIPTION:
//
// ram_init_busy       RAM initialization busy signal
// ram_init_clear_q    RAM initialization clear RAM DOUT
// ram_init_aaddr      RAM address for initialization
// sys_lp1             Light sleep mode input
// sys_lp2             Deep sleep mode input
// sys_lp3             Shut down mode input
// sys_addr[]          RAM read/write address.
// sys_ceb             RAM cell enable (active low).
// sys_web             RAM write enable (active low).
// sys_wemb[]          RAM write enable mask (active low).
// pg_override         Override low power mode
//
// OUTPUT PORT DESCRIPTION:
//
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM

//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_behav
  #(
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS    = 1,
    parameter NUM_LP2_PINS    = 1,
    parameter NUM_LP3_PINS    = 1,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_bist_shared_pkg::BIST_TRUE
  )
  (
    input  wire logic                       ram_init_busy_a,
    input  wire logic                       ram_init_busy_b,
    input  wire logic                       ram_init_start_b,
    input  wire logic                       ram_init_clear_q,
    input  wire logic [ADDR_WIDTH-1:0]      ram_init_aaddr,
    // user ram interface
    input  wire logic                       sys_aceb,
    input  wire logic                       sys_aweb,
    input  wire logic [DATA_WIDTH-1:0]      sys_awemb,
    input  wire logic [ADDR_WIDTH-1:0]      sys_aaddr,
    input  wire logic                       sys_bceb,
    input  wire logic                       sys_bweb,
    input  wire logic [DATA_WIDTH-1:0]      sys_bwemb,
    input  wire logic [ADDR_WIDTH-1:0]      sys_baddr,
    input  wire logic [NUM_LP1_PINS-1:0]    sys_lp1,
    input  wire logic [NUM_LP2_PINS-1:0]    sys_lp2,
    input  wire logic [NUM_LP3_PINS-1:0]    sys_lp3,
    input  wire logic                       pg_override,
    // internal ram interface
    output      logic                       ram_aceb,
    output      logic                       ram_aweb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
    output      logic                       ram_bceb,
    output      logic                       ram_bweb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
    output      logic [LOW_POWER_WIDTH-1:0] low_power
  );
  
  // implementation
  import miv_rv32_bist_shared_pkg::*;

  localparam logic GRND = 1'b0;
  localparam logic POWR = 1'b1;

  logic [NUM_LP1_PINS-1:0] lp1;
  logic [NUM_LP2_PINS-1:0] lp2;
  logic [NUM_LP3_PINS-1:0] lp3;
  logic                   ram_init_start;

  assign low_power[0]                                             = pg_override;
  assign low_power[NUM_LP1_PINS:1]                                = lp1;
  assign low_power[NUM_LP2_PINS+NUM_LP1_PINS:NUM_LP1_PINS+1]      = lp2;
  assign low_power[LOW_POWER_WIDTH-1:NUM_LP2_PINS+NUM_LP1_PINS+1] = lp3;

  assign ram_init_start = ~ram_init_start_b;

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    aceb_mux
    (
      .sigin(sys_aceb),
      .tstin(GRND),
      .tstsel(ram_init_busy_a),
      .sigout(ram_aceb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    bceb_mux
    (
      .sigin(sys_bceb),
      .tstin(ram_init_start),
      .tstsel(ram_init_busy_b),
      .sigout(ram_bceb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    aweb_mux
    (
      .sigin(sys_aweb),
      .tstin(ram_init_clear_q),
      .tstsel(ram_init_busy_a),
      .sigout(ram_aweb)
    ); 

  miv_rv32_bistmux
    #(
       .RTL_MUX(RTL_MUX)
    )
    bweb_mux
    (
      .sigin(sys_bweb),
      .tstin(POWR),
      .tstsel(ram_init_busy_b),
      .sigout(ram_bweb)
    ); 

  generate
    genvar i;

    for (i = 0; i < NUM_LP1_PINS; i++) begin : lp1_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp1_mux
        (
          .sigin(sys_lp1[i]),
          .tstin(BIST_LP1_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp1[i])
        ); 
    end : lp1_gen

    for (i = 0; i < NUM_LP2_PINS; i++) begin : lp2_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp2_mux
        (
          .sigin(sys_lp2[i]),
          .tstin(BIST_LP2_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp2[i])
        ); 
    end : lp2_gen

    for (i = 0; i < NUM_LP3_PINS; i++) begin : lp3_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        lp3_mux
        (
          .sigin(sys_lp3[i]),
          .tstin(BIST_LP3_DEFAULT),
          .tstsel(ram_init_busy_b),
          .sigout(lp3[i])
        ); 
    end : lp3_gen

    for (i = 0; i < DATA_WIDTH; i++) begin : wemb_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        awemb_mux
        (
          .sigin(sys_awemb[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_a),
          .sigout(ram_awemb[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        bwemb_mux
        (
          .sigin(sys_bwemb[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_bwemb[i])
        );
    end : wemb_gen

    for (i = 0; i < ADDR_WIDTH; i++) begin : addr_gen
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        aaddr_mux
        (
          .sigin(sys_aaddr[i]),
          .tstin(ram_init_aaddr[i]),
          .tstsel(ram_init_busy_a),
          .sigout(ram_aaddr[i])
        );
      miv_rv32_bistmux
        #(
           .RTL_MUX(RTL_MUX)
        )
        baddr_mux
        (
          .sigin(sys_baddr[i]),
          .tstin(GRND),
          .tstsel(ram_init_busy_b),
          .sigout(ram_baddr[i])
        );
    end : addr_gen
  endgenerate

endmodule : miv_rv32_bistdual_behav

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This file is a wrapper for ECCs and ECC err mask.
// The RAM in bist wrapper is used to store data and ecc
// parity. The relation between the data width and the
// RAM width (data + parity) is as follows.
//    data in/out width        RAM width
//         5- 11             10- 16 (+5 bits for parity)
//        12- 26             18- 32 (+6 bits for parity)
//        27- 57             34- 64 (+7 bits for parity)
//        58-120             66-128 (+8 bits for parity)
//       121-247            130-256 (+9 bits for parity)
//       248-502            258-512 (+10 bits for parity)
// e.g. if you need dpr128x32 RAM, dpr128x39 bist wrapper will be created.
//      ECC uses 7bits for parity.
// ecc_err is masked during RAM initialization and BIST test
// to suppress ecc_err report on uninitialized RAM read
//
// PARAMETER DESCRIPTION:
//
// FUNC_CLKS_SYNC       A and B clocks are functional same
// ADDR_WIDTH           Number of address bits.
// DATA_WIDTH           Number of data bits per word.
// PARITY_WIDTH         Number of parity bits per word.
// INPUT_PIPELINE       Indicates if input Pipeline flops are used or not
// OUTPUT_PIPELINE      Indicates if output Pipeline flops are used or not
//
// INPUT PORT DESCRIPTION:
//
// rstb                 System reset (active low).
// acscasnb             ACScan mode  (active low).
// aclk                 RAM clock for port A.
// aaddr                RAM read/write address for port A.
// aceb	                RAM cell enable for port A (active low)
// aweb	                RAM read/write for port A (active low)
// awemb_and            And'ed RAM write enable mask (active low)
// sys_adin             RAM write data for port A .
// bistw_adout          RAM read data (data) for port A.
// bistw_apout          RAM read data (parity) for port A.
// bclk                 RAM clock for port B.
// baddr                RAM read/write address for port B.
// bceb	                RAM cell enable for port B (active low)
// bweb	                RAM read/write for port B (active low)
// bwemb_and            And'ed RAM write enable mask (active low)
// sys_bdin	        RAM write data for port B.
// bistw_bdout          RAM read data (data) for port A.
// bistw_bpout          RAM read data (parity) for port A.
// ecc_bypass           ECC bypass. conenct to ECBI register.
// ram_err_inject       Inject error on RAM write data.
//
// OUTPUT PORT DESCRIPTION:
//
// sys_adout            RAM read data for port A.
// sys_bdout            RAM read data for port B.
// bistw_adin           RAM write data (data) for port A.
// bistw_apin           RAM write data (parity) for port A.
// bistw_bdin           RAM write data (data) for port B.
// bistw_bpin           RAM write data (parity) for port B.
// ecc_aerr             ecc error detect/corect.
// ecc_berr             ecc error detect/corect.
// ecc_aerr_int         registered version of ecc_aerr, suitable for edge sensitive interrupts. 
// ecc_berr_int         registered version of ecc_aerr, suitable for edge sensitive interrupts. 
//     
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_eccw
  #(
    parameter BIST_ECC_EMPTY = 0,
    parameter ADDR_WIDTH     = 4,
    parameter DATA_WIDTH     = 8,
    parameter PARITY_WIDTH   = 5,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE
                             = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,

    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline OUTPUT_PIPELINE
                             = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC
                             = miv_rv32_bist_shared_pkg::BIST_TRUE
  )
  (
    input  wire logic                     bistb,
    input  wire logic                     ram_init_busy_a,
    input  wire logic                     ram_init_busy_b,
    input  wire logic                     ecc_bypass,
    input  wire logic [miv_rv32_bist_shared_pkg::ECC_ERR_INJECT_WIDTH-1:0]             
                                          ram_err_inject,
    input  wire logic                     arstb,
    input  wire logic                     aclk,
    input  wire logic [ADDR_WIDTH-1:0]    aaddr,
    input  wire logic                     aceb,
    input  wire logic                     aweb,
    input  wire logic                     awemb_and,
    input  wire logic [DATA_WIDTH-1:0]    sys_adin,
    input  wire logic [DATA_WIDTH-1:0]    bistw_adout,
    input  wire logic [PARITY_WIDTH-1:0]  bistw_apout,
    input  wire logic                     brstb,
    input  wire logic                     bclk,
    input  wire logic [ADDR_WIDTH-1:0]    baddr,
    input  wire logic                     bceb,
    input  wire logic                     bweb,
    input  wire logic                     bwemb_and,
    input  wire logic [DATA_WIDTH-1:0]    sys_bdin,
    input  wire logic [DATA_WIDTH-1:0]    bistw_bdout,
    input  wire logic [PARITY_WIDTH-1:0]  bistw_bpout,
    output      logic [DATA_WIDTH-1:0]    sys_adout,
    output      logic [DATA_WIDTH-1:0]    bistw_adin,
    output      logic [PARITY_WIDTH-1:0]  bistw_apin,
    output      logic [miv_rv32_bist_shared_pkg::ECC_ERR_WIDTH-1:0]             
                                          ecc_aerr_int,
    output      logic [miv_rv32_bist_shared_pkg::ECC_ERR_WIDTH-1:0]             
                                          ecc_aerr,
    output      logic [DATA_WIDTH-1:0]    sys_bdout,
    output      logic [DATA_WIDTH-1:0]    bistw_bdin,
    output      logic [PARITY_WIDTH-1:0]  bistw_bpin,
    output      logic [miv_rv32_bist_shared_pkg::ECC_ERR_WIDTH-1:0]             
                                          ecc_berr_int,
    output      logic [miv_rv32_bist_shared_pkg::ECC_ERR_WIDTH-1:0]             
                                          ecc_berr
  );

// IMPLEMENTATION 

  import miv_rv32_bist_shared_pkg::*;

  localparam logic                    GRND            = 1'b 0;
  localparam logic [PARITY_WIDTH-1:0] GRND_PARITY     = {PARITY_WIDTH{1'b0}};

  logic [PARITY_WIDTH-1:0]         parity_adout;
  logic [PARITY_WIDTH-1:0]         parity_bdout;
  logic [ECC_ERR_WIDTH-1:0]        ecc_aerr_bist;
  logic [ECC_ERR_WIDTH-1:0]        ecc_aerr_masked;
  logic [ECC_ERR_WIDTH-1:0]        ecc_berr_bist;
  logic [ECC_ERR_WIDTH-1:0]        ecc_berr_masked;
  logic [DATA_WIDTH-1:0]           adin_con;
  logic [DATA_WIDTH-1:0]           bdin_con;

  assign bistw_apin     = parity_adout;
  assign bistw_adin     = adin_con;
  assign bistw_bpin     = parity_bdout;
  assign bistw_bdin     = bdin_con;
  assign ecc_aerr       = ecc_aerr_bist;
  assign ecc_berr       = ecc_berr_bist;

  miv_rv32_bist_err_inject 
    #(
      .ERR_WIDTH(2),
      .DATA_WIDTH(DATA_WIDTH)
    )
    aerr_inject_inst
    (
      .err_inject(ram_err_inject),
      .data_in(sys_adin),
      .data_out(adin_con)
    );

  miv_rv32_bist_err_inject 
    #(
      .ERR_WIDTH(2),
      .DATA_WIDTH(DATA_WIDTH)
    )
    berr_inject_inst
    (
      .err_inject(ram_err_inject),
      .data_in(sys_bdin),
      .data_out(bdin_con)
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(0),
      .MEMORY_READ(1)
    )
    ecc_aread
    (
      .ecc_bypass(ecc_bypass),
      .data_in(bistw_adout),
      .parity_in(bistw_apout),
      .err_multpl(ecc_aerr_bist[1]),
      .err_detect(ecc_aerr_bist[0]),
      .data_out(sys_adout),
      .parity_out(),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(0),
      .MEMORY_READ(1)
    )
    ecc_bread
    (
      .ecc_bypass(ecc_bypass),
      .data_in(bistw_bdout),
      .parity_in(bistw_bpout),
      .err_multpl(ecc_berr_bist[1]),
      .err_detect(ecc_berr_bist[0]),
      .data_out(sys_bdout),
      .parity_out(),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(1),
      .MEMORY_READ(0)
    )
    ecc_awrite
    (
      .ecc_bypass(GRND),
      .data_in(sys_adin),
      .parity_in(GRND_PARITY),
      .err_multpl(),
      .err_detect(),
      .data_out(),
      .parity_out(parity_adout),
      .check_out()
    );

  miv_rv32_bist_ecc 
    #(
      .BIST_ECC_EMPTY(BIST_ECC_EMPTY),
      .DATA_WIDTH(DATA_WIDTH),
      .ECC_PARITY_WIDTH(PARITY_WIDTH),
      .MEMORY_WRITE(1),
      .MEMORY_READ(0)
    )
    ecc_bwrite
    (
      .ecc_bypass(GRND),
      .data_in(sys_bdin),
      .parity_in(GRND_PARITY),
      .err_multpl(),
      .err_detect(),
      .data_out(),
      .parity_out(parity_bdout),
      .check_out()
    );

  miv_rv32_bistdual_err_mask 
    #(
      .ADDR_WIDTH(ADDR_WIDTH),
      .ERR_WIDTH(ECC_ERR_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC)
    )
    err_mask
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .arstb(arstb),
      .ecc_bypass(ecc_bypass),
      .aclk(aclk),
      .aaddr(aaddr),
      .aweb(aweb),
      .aceb(aceb),
      .awemb_and(awemb_and),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bweb(bweb),
      .bceb(bceb),
      .bwemb_and(bwemb_and),
      .aerr_in(ecc_aerr_bist),
      .berr_in(ecc_berr_bist),
      .aerr_out(ecc_aerr_masked),
      .berr_out(ecc_berr_masked)
    );

  // register the ecc error signals for use as interrupts 
  always @(*) //  always_ff @(negedge arstb or posedge aclk) 
  begin : register_ecc_err_a
    if(arstb != 1'b 1) begin
      ecc_aerr_int <= 2'b 00;
    end 
    else begin
      ecc_aerr_int <= ecc_aerr_bist;
    end
  end : register_ecc_err_a

  always_ff @(negedge brstb or posedge bclk) 
  begin : register_ecc_err_b
    if(brstb != 1'b 1) begin
      ecc_berr_int <= 2'b 00;
    end 
    else begin
      ecc_berr_int <= ecc_berr_bist;
    end
  end : register_ecc_err_b

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
// This block masks ECC and Parity error signal.
// The error signal is masked in following conditions.
// 1) During RAM initialization and BIST test
// 2) Simultaneous read/write for dpr, tpr and trf
// 3) RAM is disabled (ceb = '1') and RAM is being written (ceb = '0' and web = '0')
//
// PARAMETER DESCRIPTION:
//
// ADDR_WIDTH       RAM address width
// ERR_WIDTH        Error signal width
// INPUT_PIPELINE   input pipeline
// OUTPUT_PIPELINE  output pipeline
// FUNC_CLKS_SYNC   A and B clocks are functional same
//
// INPUT PORT DESCRIPTION:
//
// rstb                 Initializes/Resets the BIST block.
// ecc_bypass           ECC bypass signal.
// aclk                 RAM clock
// aaddr                RAM address             
// aweb                 RAM write enable
// aceb                 RAM cell enable
// awemb_and            And'ed RAM write enable mask
// bclk                 RAM clock
// baddr                RAM address             
// bweb                 RAM write enable
// bceb                 RAM cell enable
// bwemb_and            And'ed RAM write enable mask
// aerr_in              error input (DPR A port)
// berr_in              error input (DPR B port)
// ram_init_busy_a_sync synchronized bisti_init_busy (aclk)
// ram_init_busy_b_sync synchronized bisti_init_busy (bclk)
//
// OUTPUT PORT DESCRIPTION:
//
// aerr_out         masked error output (DPR A port)
// berr_in          masked error output (DPR B port)
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_err_mask
  #(
    parameter ADDR_WIDTH = 4,
    parameter ERR_WIDTH  = 2,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE
                             = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline OUTPUT_PIPELINE
                             = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC 
                             = miv_rv32_bist_shared_pkg::BIST_TRUE
  )
  (
    input  wire logic                  bistb,
    input  wire logic                  ecc_bypass,
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aweb,
    input  wire logic                  aceb,
    input  wire logic                  awemb_and,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bweb,
    input  wire logic                  bceb,
    input  wire logic                  bwemb_and,
    input  wire logic                  ram_init_busy_a,
    input  wire logic                  ram_init_busy_b,
    input  wire logic [ERR_WIDTH-1:0]  aerr_in,
    input  wire logic [ERR_WIDTH-1:0]  berr_in,
    output      logic [ERR_WIDTH-1:0]  aerr_out,
    output      logic [ERR_WIDTH-1:0]  berr_out
  );

// IMPLEMENTATION

  import miv_rv32_bist_shared_pkg::*;

  localparam logic [ERR_WIDTH-1:0] ERR_GRND  = {ERR_WIDTH{1'b0}};

  logic [ERR_WIDTH-1:0] aerr_out_int;
  logic [ERR_WIDTH-1:0] berr_out_int;
  logic simul_read_write;
  logic ram_ctrl_a_mask0;
  logic ram_ctrl_a_mask1;
  logic ram_ctrl_a_mask;
  logic ram_ctrl_b_mask0;
  logic ram_ctrl_b_mask1;
  logic ram_ctrl_b_mask;
  //logic [ADDR_WIDTH - 1:0] aaddr_latch;
  //logic aread_latch;
  //logic assert_a_mask;
  //logic assert_a_mask_tmp_1;
  //logic assert_a_mask_tmp_2;
  //logic [ADDR_WIDTH - 1:0] baddr_latch;
  //logic bread_latch;
  //logic assert_b_mask;
  //logic assert_b_mask_tmp_1;
  //logic assert_b_mask_tmp_2;

  assign aerr_out = aerr_out_int;
  assign berr_out = berr_out_int;

  // Create ECC err mask for following conditions.
  //  1. RAM is disabled
  //  2. simultaneous read/write (DPR/TPR/TRF) in sychronous clock
  // detect simultaneous read/write 
  generate 
    if (FUNC_CLKS_SYNC == BIST_TRUE) 
    begin : gen_simul_read_write
      always @(*) begin : detect_simul_read_write
        if(aaddr == baddr && aceb == 1'b 0 && bceb == 1'b 0 && 
           ((aweb == 1'b 0 && awemb_and == 1'b 0) || (bweb == 1'b 0 && bwemb_and == 1'b 0))) begin
          simul_read_write = 1'b 1;
        end
        else begin
          simul_read_write = 1'b 0;
        end
      end : detect_simul_read_write
    end : gen_simul_read_write
  endgenerate

  generate 
    if (FUNC_CLKS_SYNC == BIST_FALSE) 
    begin : gen_no_simul_read_write
      assign simul_read_write = 1'b 0;
    end : gen_no_simul_read_write
  endgenerate

  // insert pipeline flops to adjust timing
  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_ON) 
    begin : gen_two_pipeline
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask  <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
          ram_ctrl_a_mask1 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask1 <= simul_read_write | aceb | ~aweb;
          ram_ctrl_a_mask0 <= ram_ctrl_a_mask1 | ram_init_busy_a;
          ram_ctrl_a_mask  <= ram_ctrl_a_mask0;
        end 
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask  <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
          ram_ctrl_b_mask1 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask1 <= simul_read_write | bceb | ~bweb;
          ram_ctrl_b_mask0 <= ram_ctrl_b_mask1 | ram_init_busy_b;
          ram_ctrl_b_mask  <= ram_ctrl_b_mask0;
        end
      end : b_pipeline
    end : gen_two_pipeline
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_OFF) 
    begin : gen_one_INPUT_PIPELINE
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask0 <= simul_read_write | aceb | ~aweb;
          ram_ctrl_a_mask <= ram_ctrl_a_mask0 | ram_init_busy_a;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask0 <= simul_read_write | bceb | ~bweb;
          ram_ctrl_b_mask <= ram_ctrl_b_mask0 | ram_init_busy_b;
        end
      end : b_pipeline
    end : gen_one_INPUT_PIPELINE
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_ON) 
    begin : gen_one_OUTPUT_PIPELINE
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
          ram_ctrl_a_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_a_mask0 <= simul_read_write | ((aceb | ~aweb)) | ram_init_busy_a;
          ram_ctrl_a_mask <= ram_ctrl_a_mask0;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
          ram_ctrl_b_mask0 <= 1'b 1;
        end else begin
          ram_ctrl_b_mask0 <= simul_read_write | ((bceb | ~bweb)) | ram_init_busy_b;
          ram_ctrl_b_mask <= ram_ctrl_b_mask0;
        end
      end : b_pipeline
    end : gen_one_OUTPUT_PIPELINE
  endgenerate

  generate 
    if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_OFF) 
    begin : gen_no_pipeline
      // a clock flop
      always_ff @(negedge arstb or posedge aclk) begin : a_pipeline
        if(arstb != 1'b 1) begin
          ram_ctrl_a_mask <= 1'b 1;
        end else begin
          ram_ctrl_a_mask <= simul_read_write | ((aceb | ~aweb)) | ram_init_busy_a;
        end
      end : a_pipeline

      // b clock flop
      always_ff @(negedge brstb or posedge bclk) begin : b_pipeline
        if(brstb != 1'b 1) begin
          ram_ctrl_b_mask <= 1'b 1;
        end else begin
          ram_ctrl_b_mask <= simul_read_write | ((bceb | ~bweb)) | ram_init_busy_b;
        end
      end : b_pipeline
    end : gen_no_pipeline
  endgenerate

  // Mask ECC err
  assign aerr_out_int = (ram_ctrl_a_mask == 1'b 1 || bistb == 1'b 0) ? ERR_GRND : aerr_in;
  assign berr_out_int = (ram_ctrl_b_mask == 1'b 1 || bistb == 1'b 0) ? ERR_GRND : berr_in;

  // pragma translate_off
  logic aerr_latch;
  logic berr_latch;
  always @(negedge arstb or posedge aclk) begin 
    if(arstb != 1'b 1) begin
      aerr_latch <= 1'b0;
    end
    else begin
      aerr_latch <= aerr_out_int[0];
      if (aerr_latch == 1'b0 && ram_ctrl_a_mask == 1'b 0 && bistb == 1'b 1 && ecc_bypass == 1'b0) begin
        assert (aerr_out_int[0] == 1'b0) 
        else begin
          $display( "ECC/Parity error is detected.");
          $info;
        end 
      end
    end
  end
  always @(negedge brstb or posedge bclk) begin 
    if(brstb != 1'b 1) begin
      berr_latch <= 1'b0;
    end
    else begin
      berr_latch <= berr_out_int[0];
      if(berr_latch == 1'b0 && ram_ctrl_b_mask == 1'b 0 && bistb == 1'b 1 && ecc_bypass == 1'b0) begin
        assert (berr_out_int[0] != 1'b1) 
        else begin
          $display( "ECC/Parity error is detected.");
          $info;
        end 
      end
    end
  end
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements enable signals for pipeline flops.
//
// PARAMETER DESCRIPTION:
//
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops 
//                     (ls) is used or not
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops 
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
//
// INPUT PORT DESCRIPTION:
//
// arstb                A System reset (active low). 
// aclk                 A RAM clock.
// aceb                 A RAM cell enable (active low).
// aweb                 A RAM write enable (active low).
// brstb                B System reset (active low). 
// bclk                 B RAM clock.
// bceb                 B RAM cell enable (active low).
// bweb                 B RAM write enable (active low).
//
// OUTPUT PORT DESCRIPTION:
//
// a_input_pl_data_enable  A Enable for data input pipeline flops
// a_input_pl_ctrl_enable  A Enable for contrl input pipeline flops
// a_output_pl_data_enable A Enable for output pipeline flops
// b_input_pl_data_enable  B Enable for data input pipeline flops
// b_input_pl_ctrl_enable  B Enable for contrl input pipeline flops
// b_output_pl_data_enable B Enable for output pipeline flops
// input_pl_pg_enable      Enable for low power input pipeline flops
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_pl_enable
  #(
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF
  )
  (
    input  wire logic arstb,
    input  wire logic aclk,
    input  wire logic aceb,
    input  wire logic aweb,
    output      logic a_input_pl_data_enable,
    output      logic a_input_pl_ctrl_enable,
    output      logic a_output_pl_data_enable,
    input  wire logic brstb,
    input  wire logic bclk,
    input  wire logic bceb,
    input  wire logic bweb,
    output      logic b_input_pl_data_enable,
    output      logic b_input_pl_ctrl_enable,
    output      logic b_output_pl_data_enable,
    output      logic input_pl_pg_enable
  );
  
  // implementation
  import miv_rv32_bist_shared_pkg::*;

  logic a_output_pl_data_enable_int;
  logic b_output_pl_data_enable_int;

  assign a_input_pl_data_enable = ~aceb & ~aweb;
  assign a_input_pl_ctrl_enable = ~aceb;
  assign b_input_pl_data_enable = ~bceb & ~bweb;
  assign b_input_pl_ctrl_enable = ~bceb;
  assign input_pl_pg_enable     = 1'b1;

  generate
    if (INPUT_PIPELINE == BIST_PIPELINE_ON && OUTPUT_PIPELINE == BIST_PIPELINE_ON) begin : input_on_output_on
      always_ff @(posedge aclk or negedge arstb)
      begin : a_output_pl_enable_two_ff
        if (arstb != 1'b1) begin
          a_output_pl_data_enable     <= 1'b1;
          a_output_pl_data_enable_int <= 1'b1;
        end
        else begin
          a_output_pl_data_enable     <= a_output_pl_data_enable_int;
          a_output_pl_data_enable_int <= ~aceb & aweb;
        end
      end : a_output_pl_enable_two_ff
      always_ff @(posedge bclk or negedge brstb)
      begin : b_output_pl_enable_two_ff
        if (brstb != 1'b1) begin
          b_output_pl_data_enable     <= 1'b1;
          b_output_pl_data_enable_int <= 1'b1;
        end
        else begin
          b_output_pl_data_enable     <= b_output_pl_data_enable_int;
          b_output_pl_data_enable_int <= ~bceb & bweb;
        end
      end : b_output_pl_enable_two_ff
    end : input_on_output_on
    else if (INPUT_PIPELINE == BIST_PIPELINE_OFF && OUTPUT_PIPELINE == BIST_PIPELINE_ON) begin : input_off_output_on
      always_ff @(posedge aclk or negedge arstb)
      begin : a_output_pl_enable_one_ff
        if (arstb != 1'b1) begin
          a_output_pl_data_enable <= 1'b1;
        end
        else begin
          a_output_pl_data_enable <= ~aceb & aweb;
        end
      end : a_output_pl_enable_one_ff
      always_ff @(posedge bclk or negedge brstb)
      begin : b_output_pl_enable_one_ff
        if (brstb != 1'b1) begin
          b_output_pl_data_enable <= 1'b1;
        end
        else begin
          b_output_pl_data_enable <= ~bceb & bweb;
        end
      end : b_output_pl_enable_one_ff
    end : input_off_output_on
    else begin : output_off
      assign  a_output_pl_data_enable = ~aceb & aweb;
      assign  b_output_pl_data_enable = ~bceb & bweb;
    end : output_off
  endgenerate
  
endmodule : miv_rv32_bistdual_pl_enable

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This block is used to initialize RAM.
// The address counter is generated and no BIST sequencer is required to
// generate addresses.
//
//
// PARAMETER DESCRIPTION:
//
// ASYNC_ACLK             asynchronous relationship between aclk and bistclk
// ASYNC_BCLK             asynchronous relationship between bclk and bistclk
// RAM_INIT_GEN           RAM initialization logic is generated when high
// RAM_DEPTH              RAM depth
// ADDR_WIDTH             RAM address bit width
//
//
// INPUT PORT DESCRIPTION:
//
// arstb                  Initializes/Resets BIST block (active low), A side
// brstb                  Initializes/Resets BIST block (active low), B side
// aclk                   System A clock
// bclk                   System B clock
// ram_init_enable        RAM initialization enable (active high)
//
//
// OUTPUT PORT DESCRIPTION:
//
// ram_init_busy_a        RAM initialization busy signal (active high), A side
// ram_init_busy_b        RAM initialization busy signal (active high), B side
// ram_init_start_b       RAM initialization start for B (read) clock domain
// ram_init_clear_q       RAM initialization clear RAM DOUT
// ram_init_aaddr         RAM address for initialization, A (write) side
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_ram_init

  #(
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_bist_shared_pkg::BIST_TRUE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_INIT_GEN    
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter RAM_DEPTH       = 16,
    parameter ADDR_WIDTH      = 4
  )
  (
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic                  ram_init_enable,   
    
    output      logic                  ram_init_busy_a,
    output      logic                  ram_init_busy_b,
    output      logic                  ram_init_start_b,
    output      logic                  ram_init_clear_q, 
    output      logic [ADDR_WIDTH-1:0] ram_init_aaddr
  );
  
  import miv_rv32_bist_shared_pkg::*;
  
  // INTERNAL SIGNALS
  logic ram_init_busy_a_int;
  logic ram_init_busy_b_int;
  logic ram_init_start_a_int;
  logic ram_init_start_b_int;
  logic init_start;
  logic ram_init_clear_q_int;
  
  // STATE VARIABLE DECLARATIONS
  typedef enum logic [2:0] {
    RESET,
    NOT_INIT,
    START_INIT,
    INCR_ADDR,
    LAST_ADDR,
    CLR_PIPELINE_OUT,
    FINISH_INIT
  } t_gen_ram_state;
  
  t_gen_ram_state state;
  t_gen_ram_state nextstate;
  
  // Assign outputs
  assign ram_init_busy_a    = ram_init_enable   ? ram_init_busy_a_int  : 1'b0;
  assign ram_init_busy_b    = ram_init_enable   ? ram_init_busy_b_int  : 1'b0;
  assign ram_init_start_b   = ram_init_enable   ? ram_init_start_b_int : 1'b0;
  assign ram_init_clear_q   = ram_init_enable   ? ram_init_clear_q_int : 1'b0;
  
  generate
    case ( RAM_INIT_GEN ) 
    
      BIST_TRUE :
        begin : gen_ram_init
          
          // sequential logic for state machine
          always_ff @(posedge aclk or negedge arstb)
          begin : ram_init_seq
            if ( arstb != 1'b1 ) begin
              state                <= RESET;

              init_start           <= 1'b1;
              ram_init_busy_a_int  <= 1'b1;
              ram_init_start_a_int <= 1'b0;
              ram_init_clear_q_int <= 1'b0;
              ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
            end
            else begin
              state                <= nextstate;
              init_start           <= ram_init_enable;
              
              // output logic
              unique case ( nextstate )
                RESET: begin
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end              
                  
                NOT_INIT: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end
                  
                START_INIT: begin // ram_init_enable toggled
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end               
                
                INCR_ADDR: begin
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b1;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= ram_init_aaddr + 1'b1;
                end
                
                LAST_ADDR: begin // clear RAM Q values
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b1;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end
                  
                CLR_PIPELINE_OUT: begin // one cycle to clear output pipeline
                  ram_init_busy_a_int  <= 1'b1;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end
                  
                FINISH_INIT: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b1;
                  ram_init_aaddr       <= ram_init_aaddr;
                end              
                
                default: begin
                  ram_init_busy_a_int  <= 1'b0;
                  ram_init_start_a_int <= 1'b0;
                  ram_init_clear_q_int <= 1'b0;
                  ram_init_aaddr       <= {ADDR_WIDTH{1'b0}};
                end
              endcase  
            end
          end : ram_init_seq
          
          // Next state combo logic
          always @(*)
          begin : ram_init_nextstate
            
            unique case ( state )
              RESET: begin
                if ( ram_init_enable == 1'b1 ) begin
                  nextstate = INCR_ADDR;
                end
                else begin
                  nextstate = NOT_INIT;
                end
              end              
                
              NOT_INIT: begin
                if ( ram_init_enable == 1'b1 && init_start == 1'b0 ) begin
                  nextstate = START_INIT;
                end
                else begin
                  nextstate = NOT_INIT;
                end
              end
                
              START_INIT: begin // ram_init_enable toggled
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = INCR_ADDR;
                end
              end               
              
              INCR_ADDR: begin
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else if ( RAM_DEPTH - 1 == int'(ram_init_aaddr) ) begin
                  nextstate = LAST_ADDR;
                end
                else begin
                  nextstate = INCR_ADDR;
                end
              end
              
              LAST_ADDR: begin // clear RAM Q values
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = CLR_PIPELINE_OUT;
                end
              end
                
              CLR_PIPELINE_OUT: begin // wait one cycle to clear output pipeline
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = FINISH_INIT;
                end
              end
                
              FINISH_INIT: begin
                if ( ram_init_enable != 1'b1 ) begin
                  nextstate = NOT_INIT;
                end
                else begin
                  nextstate = FINISH_INIT;
                end
              end              
              
              default: begin
                nextstate   = NOT_INIT;
              end
            endcase  
          end : ram_init_nextstate

          // pragma translate_off
          logic init_done;
          always @(posedge bclk or negedge brstb)
          begin
            if ( brstb != 1'b1 ) begin
              init_done <= 1'b1;
            end
            else begin
              init_done <= ram_init_busy_b_int;
              assert(ram_init_busy_b_int == 1'b1 || ram_init_busy_b_int ^ init_done == 1'b0 || ram_init_enable == 1'b0)
              else begin
                $display("ram_init : RAM initialization complete.");
                $info;
              end 
            end
          end
          // pragma translate_on

        end : gen_ram_init
        
      BIST_FALSE:
        begin : gen_no_ram_init
          assign ram_init_aaddr       = {ADDR_WIDTH{1'b0}};
          assign ram_init_busy_a_int  = 1'b0;
          assign ram_init_busy_b_int  = 1'b0;
          assign ram_init_start_b_int = 1'b0;
          assign ram_init_clear_q_int = 1'b0;
        end : gen_no_ram_init
      
    endcase
  endgenerate


  // generate sync flops if bclk and aclk are async
  generate
    if ( ( RAM_INIT_GEN == BIST_TRUE ) && ( FUNC_CLKS_SYNC == BIST_FALSE) )
    begin : gen_busy_sync
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(1),
          .MTBF(1))
        pmc_sync_flop_ram_init_busy
        ( .sigin(ram_init_busy_a_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_busy_b_int)
        );
      pmc_sync_flop_behav_v3
        #(.RETIMING_FLOP_NUM(2),
          .RESET_VALUE(0),
          .MTBF(1))
        pmc_sync_flop_ram_init_start
        ( .sigin(ram_init_start_a_int),
          .gray_clk(1'b0),
          .clk(bclk),
          .rstb(brstb),
          .sigout(ram_init_start_b_int)
        );
    end : gen_busy_sync
  // no need for sync flops if bclk and aclk are sync
    else if ( ( RAM_INIT_GEN == BIST_TRUE ) && ( FUNC_CLKS_SYNC == BIST_TRUE  ) )
    begin : busy_no_sync
      assign ram_init_busy_b_int  = ram_init_busy_a_int;
      assign ram_init_start_b_int = ram_init_start_a_int;
    end : busy_no_sync
  endgenerate

endmodule : miv_rv32_bistdual_ram_init

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// This block makes RAM behaviour the same in both ASIC and FPGA.
// There are three different modes in this design:
// 1) ASIC mode:
//      -no FPGA compatible logic is generated
//      -all signals are feed through
//
// 2) FPGA compatible mode with synchronous clocks
//
// 3) FPGA compatible mode with asynchronous clocks
//      -assertions detect simultaneous read/write and simultaneous write/write
//      -error message is displayed if above accesses are detected and 
//       simulation will be aborted
//
//
// PARAMETER DESCRIPTION:
//
// RAM_STABILIZER         FPGA compatible logic selection
// FUNC_CLKS_SYNC         A and B clocks are functionally the same
// ADDR_WIDTH             Number of address bits
// DATA_WIDTH             Number of data bits per word
//
//
// INPUT PORT DESCRIPTION:
//
// arstb                  Active-low reset for port A
// aclk                   RAM clock for port A
// aaddr                  RAM read/write address for port A
// aceb_in                Active-low RAM cell enable for port A
// aweb                   Active-low RAM read/write for port A
// awemb_and              Active-low AND-ed RAM write enable mask
// adin                   RAM write data for port A
// adout_in               RAM write data for port A
// brstb                  Active-low reset for port B
// bclk                   RAM clock for port B
// baddr                  RAM read/write address for port B
// bceb_in                Active-low RAM cell enable for port B
// bweb                   Active-low RAM read/write for port B
// bwemb_and              Active-low AND-ed RAM write enable mask
// bdin                   RAM write data for port B
// bdout_in               RAM write data for port B
//
//
// OUTPUT PORT DESCRIPTION:
//
// aceb_out               Active-low RAM cell enable for port A
// bceb_out               Active-low RAM cell enable for port B
// adout                  RAM read data for port A
// bdout                  RAM read data for port B
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistdual_ram_stabilizer
  #(
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter ADDR_WIDTH      = 4,
    parameter DATA_WIDTH      = 8
  )
  (
    input  wire logic arstb,
    input  wire logic aclk,
    input  wire logic aceb_in,
    input  wire logic aweb,
    input  wire logic awemb_and,
    input  wire logic brstb,
    input  wire logic bclk,
    input  wire logic bceb_in,
    input  wire logic bweb,
    input  wire logic bwemb_and,
    
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic [ADDR_WIDTH-1:0] baddr,    
    input  wire logic [DATA_WIDTH-1:0] adin,
    input  wire logic [DATA_WIDTH-1:0] adout_in,
    input  wire logic [DATA_WIDTH-1:0] bdin,
    input  wire logic [DATA_WIDTH-1:0] bdout_in,
    
    output      logic aceb_out,
    output      logic bceb_out,
    
    output      logic [DATA_WIDTH-1:0] adout_out,
    output      logic [DATA_WIDTH-1:0] bdout_out
  );
  
  // IMPORT PACKAGE
  import miv_rv32_bist_shared_pkg::*;
  
  // INTERNAL SIGNALS
  logic simul_rw;
  logic simul_ww;
  logic simul_a_mask;
  logic simul_b_mask;
  logic simul_rw_latched;
  logic simul_ww_latched;
  logic aceb_latched;
  logic aweb_latched;
  logic awemb_latched;
  logic bceb_latched;
  logic bweb_latched;
  logic bwemb_latched;
  
  logic [DATA_WIDTH-1:0] w_data;
  logic [ADDR_WIDTH-1:0] aaddr_latched;
  logic [ADDR_WIDTH-1:0] baddr_latched;
  
  //----------------------------------------------------------------------------
  // No FPGA compatible logic or FPGA compatible logic for asynchronous clocks
  //----------------------------------------------------------------------------
  generate
    if ( RAM_STABILIZER == BIST_FALSE || 
         (RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_FALSE) ) 
    begin : no_ram_stabilizer_logic
      // all signals are feed through
      assign aceb_out = aceb_in;
      assign bceb_out = bceb_in;
      assign adout_out = adout_in;
      assign bdout_out = bdout_in;
    end : no_ram_stabilizer_logic
  
  //----------------------------------------------------------------------------
  // FPGA compatible logic for synchronous clocks
  //----------------------------------------------------------------------------
    else if ( RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_TRUE )
    begin : ram_stabilizer_logic_sync
    
      // detect simultaneous accesses (write/write and read/write)
      // also create mask signals (for write/write and read side for read/write)
      always @(*) 
      begin : simul_rw_detect
        if ( aaddr == baddr && aceb_in == 1'b0 && bceb_in == 1'b0 ) begin
          if ( (aweb == 1'b0 && awemb_and == 1'b0) && 
               (bweb == 1'b0 && bwemb_and == 1'b0) ) begin
            // simultaneous write/write
            simul_ww     = 1'b1;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b1;
          end
          else if ( aweb == 1'b0 && awemb_and == 1'b0 ) begin
            // simultaneous A write, B read
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b1;
          end
          else if ( bweb == 1'b0 && bwemb_and == 1'b0 ) begin
            // simultaneous A read, B write
            simul_ww     = 1'b0;
            simul_rw     = 1'b1;
            simul_a_mask = 1'b1;
            simul_b_mask = 1'b0;
          end
          else begin
            // simultaneous read/read
            simul_ww     = 1'b0;
            simul_rw     = 1'b0;
            simul_a_mask = 1'b0;
            simul_b_mask = 1'b0;
          end
        end
        else begin
          // normal access
          simul_ww     = 1'b0;
          simul_rw     = 1'b0;
          simul_a_mask = 1'b0;
          simul_b_mask = 1'b0;
        end
      end : simul_rw_detect
      
      // generate simultaneous read/write flop
      always_ff @(posedge aclk or negedge arstb)
      begin : latch_simul_rw
        if ( arstb != 1'b1 ) begin
          simul_rw_latched <= 1'b0;
        end
        else begin
          simul_rw_latched <= simul_rw;
        end
      end : latch_simul_rw
      
      // simultaneous write/write flop
      always_ff @(posedge aclk or negedge arstb)
      begin : latch_simul_ww
        if ( arstb != 1'b1 ) begin
          simul_ww_latched <= 1'b0;
        end
        else begin
          simul_ww_latched <= simul_ww;
        end
      end : latch_simul_ww
      
      // generate write data flops
      // select output data on read/write
      always_ff @(posedge aclk or negedge arstb)
      begin : gen_w_data_flops
        if ( arstb != 1'b1 ) begin
          w_data <= {DATA_WIDTH{1'b0}};
        end
        else begin
          if ( simul_a_mask == 1'b0 ) begin
            w_data <= adin;
          end
          else begin
            w_data <= bdin;
          end
        end
      end : gen_w_data_flops
      
      // generate aceb
      // aceb is masked when A read and B write
      always @(*)
      begin : gen_aceb_out
        if ( simul_a_mask == 1'b1 ) begin
          aceb_out = 1'b1;
        end
        else begin
          aceb_out = aceb_in;
        end
      end : gen_aceb_out
      
      // gen bceb
      // bceb is masked if:
      //   1) A write and B read
      //   2) A write and B write
      always @(*)
      begin : gen_bceb_out
        if ( simul_b_mask == 1'b1 ) begin
          bceb_out = 1'b1;
        end
        else begin
          bceb_out = bceb_in;
        end
      end : gen_bceb_out
      
      // dout select mux
      // 1) write and write : all 0 for both adout and bdout
      // 2) write and read  : write data is bypassed to outputs
      // 3) other cases     : adout is RAM adout and bdout is RAM bdout
      always @(*)
      begin : dout_sel
        if ( simul_ww_latched == 1'b1 ) begin
          adout_out = {DATA_WIDTH{1'b0}};
          bdout_out = {DATA_WIDTH{1'b0}};
        end
        else if ( simul_rw_latched == 1'b1 ) begin
          adout_out = w_data;
          bdout_out = w_data;
        end
        else begin
          adout_out = adout_in;
          bdout_out = bdout_in;
        end
      end : dout_sel
    end : ram_stabilizer_logic_sync
  endgenerate

  //----------------------------------------------------------------------------
  // Assertion on async clock and simultaneous access
  //----------------------------------------------------------------------------
  // pragma translate_off
  generate
    if (RAM_STABILIZER == BIST_TRUE && FUNC_CLKS_SYNC == BIST_FALSE) 
    begin : async_assert
      always @(negedge arstb or posedge aclk) begin 
        if(arstb != 1'b 1) begin
          aaddr_latched <= {ADDR_WIDTH{1'b0}};
          aceb_latched  <= 1'b1;
          aweb_latched  <= 1'b1;
          awemb_latched <= 1'b1;
        end
        else begin
          aaddr_latched <= aaddr;
          aceb_latched  <= aceb_in;
          aweb_latched  <= aweb;
          awemb_latched <= awemb_and;
        end
      end
      always @(negedge brstb or posedge bclk) begin 
        if(brstb != 1'b 1) begin
          baddr_latched <= {ADDR_WIDTH{1'b0}};
          bceb_latched  <= 1'b1;
          bweb_latched  <= 1'b1;
          bwemb_latched <= 1'b1;
        end
        else begin
          baddr_latched <= baddr;
          bceb_latched  <= bceb_in;
          bweb_latched  <= bweb;
          bwemb_latched <= bwemb_and;
        end
      end
      always @(aaddr_latched or aceb_latched or aweb_latched or awemb_latched or
               baddr_latched or bceb_latched or bweb_latched or bwemb_latched) begin
        if (aaddr_latched == baddr_latched && 
            ((aceb_latched == 1'b0 && bceb_latched == 1'b0) &&
            ((aweb_latched == 1'b0 && awemb_latched == 1'b0) || (bweb_latched == 1'b0 && bwemb_latched == 1'b0)))) begin
          simul_rw <= 1'b1;
        end
        else begin
          simul_rw <= 1'b0;
        end
      end
      // assertion
      always @(simul_rw) begin
        assert (simul_rw == 1'b0)
        else begin
          $display( "Error: Found Simultaneous access on the same address. (async. clock)");
          $error;
        end
      end 
    end : async_assert
  endgenerate
  // pragma translate_on

endmodule : miv_rv32_bistdual_ram_stabilizer

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Implements a mux for the RAM BIST blocks.  There is no test out signal
// because the scan data passes through these muxes.
//
//
// INPUT PORT DESCRIPTION:
//
// sigin                  Incoming normal mode signal
// tstin                  Incoming test mode signal
// tstsel                 Selects either incoming or test value
//
//
// OUTPUT PORT DESCRIPTION:
//
// sigout                 Output normal mode signal
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bistmux
  #(
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RTL_MUX
                         = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false LW_MACRO
                         = miv_rv32_bist_shared_pkg::BIST_TRUE
  )
  (
    input  wire logic sigin,
    input  wire logic tstin,
    input  wire logic tstsel,
    output      logic sigout
  );
  
  import miv_rv32_bist_shared_pkg::*;
 
  generate
    if (RTL_MUX == BIST_FALSE) begin : macro_mux
      if (LW_MACRO == BIST_TRUE) begin : lw_mux
        miv_rv32_logic_mux_behav_v2 
          bistmux_inst
          (
            .a(sigin),
            .b(tstin),
            .s0(tstsel),
            .y(sigout)
          );
      end : lw_mux
      else begin : icdc_mux
        pmc_logic_mux_behav
          bistmux_inst
          (
            .A(sigin),
            .B(tstin),
            .S0(tstsel),
            .Y(sigout)
          );
      end : icdc_mux
    end : macro_mux
    else begin : rtl_mux
      assign sigout = tstsel ? tstin : sigin;
    end : rtl_mux
  endgenerate

endmodule : miv_rv32_bistmux

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Provides address decoding for the check bits calculated by the ECC block.
// The input to this block is a bit vector, which represents the binary value
// of the address bit.  The output of this block is a bit vector that has a 0
// in every bit except the address bit.
//
//
// PARAMETER DESCRIPTION:
//
// PARITY_WIDTH_MAX       Maximum width of ecc_parity
// MAX_ADDR_WIDTH         Maximum width of address = 2**(ecc_parity-1)
// ECC_PARITY_WIDTH       Width of the parity bus
//                        (This value is set in the ECC block; it is passed to
//                        the address decoder so that the ECC check bits can be
//                        properly decoded.)
//
//
// INPUT PORT DESCRIPTION:
//
// addr_in                Check bit address bus.  The width of this bus is
//                        defined as the actual width of the parity bus in the
//                        ECC, less the MSB (CT).
//
//
// OUTPUT PORT DESCRIPTION:
//
// addr_out               Decoded address bus (every bit is 0 except for the
//                        bit location in the addr_in position)
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bist_decode
  #(
    parameter CHECK_TOTAL_WIDTH = 10,
    parameter MAX_ADDR_WIDTH    = 16,
    parameter ECC_PARITY_WIDTH  = 5
  )
  (
    input  wire logic [CHECK_TOTAL_WIDTH-1:0] addr_in,
    output      logic [MAX_ADDR_WIDTH-1:0]    addr_out
  );
  
  // Implementation
  localparam logic GRND            = 1'b0;
  localparam       DEC_4_WIDTH     = 4;
  localparam       DEC_8_WIDTH     = 8;
  localparam       DEC_16_WIDTH    = 16;
  localparam       DEC_32_WIDTH    = 32;
  localparam       DEC_64_WIDTH    = 64;
  localparam       DEC_128_WIDTH   = 128;
  localparam       SEL_2_WIDTH     = 2;
  localparam       SEL_3_WIDTH     = 3;
  
  logic [DEC_4_WIDTH-1:0]   dec_enb;
  logic [DEC_32_WIDTH-1:0]  dec8enb;
  
  logic [DEC_8_WIDTH-1:0]   dec_enb_8;
  logic [DEC_16_WIDTH-1:0]  dec_enb_16;
  logic [DEC_64_WIDTH-1:0]  dec_enb_64;
  logic [DEC_128_WIDTH-1:0] dec_enb_128;
  
  logic [MAX_ADDR_WIDTH-1:0] addr_out_int;
  
  // Functions for decoder logic
  function automatic logic [3:0] core_bist_dec4 (
    input  logic                   enb,
    input  logic [SEL_2_WIDTH-1:0] sel
  );  
    if ( enb == 1'b0 ) begin
      // Zero-hot decoder
      unique case ( sel )
        2'b00:  core_bist_dec4 = 4'b1110;
        2'b01:  core_bist_dec4 = 4'b1101;
        2'b10:  core_bist_dec4 = 4'b1011;
        2'b11:  core_bist_dec4 = 4'b0111;
        default: core_bist_dec4 = 4'b1111;
      endcase
    end
    else begin
      core_bist_dec4 = 4'b1111;
    end  
  endfunction : core_bist_dec4  
  
  function automatic logic [7:0] core_bist_dec8 (
    input  logic                   enb,
    input  logic [SEL_3_WIDTH-1:0] sel
  );
    if ( enb == 1'b0 ) begin
      unique case ( sel ) 
        3'b000:  core_bist_dec8 = 8'b1111_1110;
        3'b001:  core_bist_dec8 = 8'b1111_1101;
        3'b010:  core_bist_dec8 = 8'b1111_1011;
        3'b011:  core_bist_dec8 = 8'b1111_0111;
        3'b100:  core_bist_dec8 = 8'b1110_1111;
        3'b101:  core_bist_dec8 = 8'b1101_1111;
        3'b110:  core_bist_dec8 = 8'b1011_1111;
        3'b111:  core_bist_dec8 = 8'b0111_1111;
        default: core_bist_dec8 = 8'b1111_1111;
      endcase
    end
    else begin
      core_bist_dec8 = 8'b1111_1111;
    end  
  endfunction : core_bist_dec8
  
  generate
    case ( ECC_PARITY_WIDTH ) 
      3 : 
        begin : case_1 // 2 check bits: C2, C1
          assign addr_out_int[3:0] = core_bist_dec4(GRND, addr_in[1:0]);
        end : case_1
      4 : 
        begin : case_2 // 3 check bits: C4, C2, C1
          assign addr_out_int[7:0] = core_bist_dec8(GRND, addr_in[2:0]);
        end : case_2
      5 :
        begin : case_3 // 4 check bits: C8, C4, C2, C1
          assign dec_enb[0] = addr_in[3];
          assign dec_enb[1] = !addr_in[3];
          
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_3
      6 :
        begin : case_4 // 5 check bits: C16, C8, C4, C2, C1
          assign dec8enb[3:0] = core_bist_dec4(GRND, addr_in[4:3]);
          
          genvar i;
          for ( i = 0; i <= 3; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_4
      7 :
        begin : case_5 // 6 check bits: C32, C16, C8, C4, C2, C1
          assign dec8enb[7:0] = core_bist_dec8(GRND, addr_in[5:3]);
          
          genvar i;
          for ( i = 0; i <= 7; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_5
      8 :
        begin : case_6 // 7 check bits: C64, C32, C16, C8, C4, C2, C1
          assign dec_enb[0] = addr_in[6];
          assign dec_enb[1] = !addr_in[6];
          
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec8_enable_gen
            assign dec8enb[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                         addr_in[5:3]);
          end : dec8_enable_gen
          
          for ( i = 0; i <= 15; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_6
      9 :
        begin : case_7 // 8 check bits: C128, C64, C32, C16, C8, C4, C2, C1
          assign dec_enb[3:0] = core_bist_dec4(GRND, addr_in[7:6]);
          
          genvar i;
          for ( i = 0; i <= 3; i++ ) begin : dec8_enable_gen
            assign dec8enb[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                         addr_in[5:3]);
          end : dec8_enable_gen
          
          for ( i = 0; i <= 31; i++ ) begin : dec8_gen
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec8enb[i], 
                                                              addr_in[2:0]);
          end : dec8_gen
        end : case_7
      10 :
        begin : case_8 // 9 check bits: C256, C128, C64, C32, C16, C8, etc.
          // decode the top 3 address bits
          assign dec_enb_8[7:0] = core_bist_dec8(GRND, addr_in[8:6]);
          
          // decode the middle 3 address bits
          genvar i;
          for ( i = 0; i <= 7; i++ ) begin : middle_8_addr_dec
            assign dec_enb_64[8*i+7:8*i] = core_bist_dec8(dec_enb_8[i], 
                                                            addr_in[5:3]);
          end : middle_8_addr_dec
          
          // decode the bottom 3 address bits
          for ( i = 0; i <= 63; i++ ) begin : bottom_8_addr_dec
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb_64[i], 
                                                              addr_in[2:0]);
          end : bottom_8_addr_dec
        end : case_8
      11 :
        begin : case_9 //10 check bits: C512, C256, C128, C64, C32, C16, etc.
          // decode top address bit
          assign dec_enb[0] = addr_in[9];
          assign dec_enb[1] = !addr_in[9];
          
          // decode address bits 8-6
          genvar i;
          for ( i = 0; i <= 1; i++ ) begin : dec16_enable_gen
            assign dec_enb_16[8*i+7:8*i] = core_bist_dec8(dec_enb[i], 
                                                            addr_in[8:6]);
          end : dec16_enable_gen
          
          // decode address bits 5-3
          for ( i = 0; i <= 15; i++ ) begin : dec128_enable_gen
            assign dec_enb_128[8*i+7:8*i] = core_bist_dec8(dec_enb_16[i], 
                                                             addr_in[5:3]);
          end : dec128_enable_gen
          
          // decode address bits 2-0
          for ( i = 0; i <= 127; i++ ) begin : bottom_8_addr_dec
            assign addr_out_int[8*i+7:8*i] = core_bist_dec8(dec_enb_128[i], 
                                                              addr_in[2:0]);
          end : bottom_8_addr_dec
        end : case_9
    endcase
  endgenerate
  
  // Create the register read signals
  always @(*) begin : gen_addr_out
    for ( int j = 0; j < MAX_ADDR_WIDTH; j++ ) begin
      addr_out[j] = !addr_out_int[j];
    end
  end : gen_addr_out

endmodule : miv_rv32_bist_decode

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Error-correction code (ECC) circuitry can be added to SRAM's to
// prevent random single-cell errors.  The ECC circuitry has the 
// ability to detect and correct single-bit errors in a word that
// is read from memory.  Before the word is written to memory, the
// ECC block will generate a parity word that is unique to the data
// word being written to memory.  The parity word will allow the ECC
// circuitry to detect and possibly correct any bit errors in the
// data word, when it is read back out from memory.  The ECC can 
// detect and correct single-bit errors, and detect (but not correct)
// two-bit errors or any even multiple of bit-errors.
// The ECC block is based on a single-error correction, double-error 
// detection method (Hamming ECC Code), which uses enough parity 
// bits to be able to identify and correct any single-bit errors in
// a word.  This method also allows the ECC to identify two 
// bit-errors.  The ECC block uses even parity.
//
// Parameter Description:
//
// MEMORY_WRITE      Set this bit to '1' if you only want to generate
//                   the circuitry required to generate the parity
//                   bits.
//                   When writing data words to RAM, this is all that's 
//                   required (saves power and gates by not generating
//                   extra logic).
// MEMORY_READ       Set this bit to '1' if you only want to generate 
//                   the circuitry required to generate the check
//                   (syndrome) bits, and correct the data word that 
//                   was read from RAM.
//                   When reading data words from RAM, this is all 
//                   that's equired (saves power and gates by not
//                   generating extra logic).
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
//
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
//
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc
  #(
    parameter BIST_ECC_EMPTY   = 0,
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter MEMORY_WRITE     = 0,
    parameter MEMORY_READ      = 1
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Start the RTL code:

  generate 
    case (BIST_ECC_EMPTY) 
    1 : 
      begin : ecc_empty_generate
        miv_rv32_bist_ecc_empty
          #(
            .DATA_WIDTH(DATA_WIDTH),
            .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH)
          )
          ecc_emtpy
          (
            .data_in,
            .err_multpl,
            .err_detect,
            .data_out,
            .parity_out,
            .check_out
          );
      end : ecc_empty_generate
    default : 
      begin : ecc_generate
        miv_rv32_bist_ecc_core
          #(
            .DATA_WIDTH(DATA_WIDTH),
            .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
            .MEMORY_WRITE(MEMORY_WRITE),
            .MEMORY_READ(MEMORY_READ)
          )
          ecc_core
          (
            .ecc_bypass,
            .data_in,
            .parity_in,
            .err_multpl,
            .err_detect,
            .data_out,
            .parity_out,
            .check_out
          );
      end : ecc_generate
    endcase
  endgenerate

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC core block. Detailed functionality of the ECC block is
// desctibed in miv_rv32_bist_ecc module.
//
// Parameter Description:
// MEMORY_WRITE      Set this bit to '1' if you only want to generate
//                   the circuitry required to generate the parity
//                   bits.
//                   When writing data words to RAM, this is all that's 
//                   required (saves power and gates by not generating
//                   extra logic).
// MEMORY_READ       Set this bit to '1' if you only want to generate 
//                   the circuitry required to generate the check
//                   (syndrome) bits, and correct the data word that 
//                   was read from RAM.
//                   When reading data words from RAM, this is all 
//                   that's equired (saves power and gates by not
//                   generating extra logic).
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_core
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter MEMORY_WRITE     = 0,
    parameter MEMORY_READ      = 1
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Implementation
localparam MAX_DATA_WIDTH   = 1013;
localparam PARITY_WIDTH_MAX = 11;

logic [PARITY_WIDTH_MAX-1:0] parity_1_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_2_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_4_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_8_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_16_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_32_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_64_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_128_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_256_calc;
logic [PARITY_WIDTH_MAX-1:0] parity_512_calc;
logic [ECC_PARITY_WIDTH-1:0] parity_out_output;
logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected_output;
logic [ECC_PARITY_WIDTH-1:0] check_out_output;
logic [DATA_WIDTH - 1:0]     data_out_output;
logic                        err_multpl_output;
logic                        err_detect_output;  

// 'data_in' bus zero padded up to the most significant bit (needed for parity bit 
// calculations)
logic [MAX_DATA_WIDTH-1:0] data_in_zero_padded;  

// Start the RTL code:

  // DATA BUS EXTENSION (ALWAYS GENERATED)
  //
  // Extend the data bus to the maximum data width
  // The Parity Generator Block and the Check Bit Generatory
  // and Error-correction Circuitry use this bus.
  generate
    if(MAX_DATA_WIDTH > DATA_WIDTH) begin : data_bus_extension_gen
      assign data_in_zero_padded[MAX_DATA_WIDTH-1:DATA_WIDTH] = {(MAX_DATA_WIDTH-DATA_WIDTH){1'b0}};
    end : data_bus_extension_gen
  endgenerate

  always @(*) 
  begin : data_bus_extansion
    data_in_zero_padded[DATA_WIDTH-1:0] <= data_in;
  end : data_bus_extansion

  // *********************************
  // Temporary Parity Bit Calculations
  // Always generated
  // *********************************
  // Generate all the intermediate parity bits.  These lengthy XOR
  // calculations are used to calculate both the parity bits
  // (RAM write) and the check bits (RAM read).  For this
  // reason, the logic will always be generated (based on the data
  // bus width).  All the processes used to calculate the temporary
  // parity bits are sensitive to the data_in_zero_padded bus.
  always @(*) 
  begin : parity_calcs_0_process
    parity_1_calc[0] = data_in_zero_padded[0];
    parity_2_calc[0] = data_in_zero_padded[0];
  end : parity_calcs_0_process

  generate
    if (DATA_WIDTH >= 2) begin : parity_calcs_1_generate
      always @(*) 
      begin : parity_calcs_1
        parity_1_calc[1] =   data_in_zero_padded[1] ^ data_in_zero_padded[3];
        parity_2_calc[1] =  ^data_in_zero_padded[3:2];
        parity_4_calc[1] =  ^data_in_zero_padded[3:1];
      end : parity_calcs_1
    end : parity_calcs_1_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : parity_calcs_2_generate
      always @(*) 
      begin : parity_calcs_2
        parity_1_calc[2] =  data_in_zero_padded[4]   ^  data_in_zero_padded[6] ^ 
                            data_in_zero_padded[8]   ^  data_in_zero_padded[10];
        parity_2_calc[2] = ^data_in_zero_padded[6:5] ^ ^data_in_zero_padded[10:9];
        parity_4_calc[2] = ^data_in_zero_padded[10:7];
        parity_8_calc[2] = ^data_in_zero_padded[10:4];
      end : parity_calcs_2
    end : parity_calcs_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : parity_calcs_3_generate
      always @(*) 
      begin : parity_calcs_3
        parity_1_calc[3]  =  data_in_zero_padded[11] ^     data_in_zero_padded[13] ^ 
                             data_in_zero_padded[15] ^     data_in_zero_padded[17] ^ 
                             data_in_zero_padded[19] ^     data_in_zero_padded[21] ^ 
                             data_in_zero_padded[23] ^     data_in_zero_padded[25];
        parity_2_calc[3]  = ^data_in_zero_padded[13:12] ^ ^data_in_zero_padded[17:16] ^
                            ^data_in_zero_padded[21:20] ^ ^data_in_zero_padded[25:24];
        parity_4_calc[3]  = ^data_in_zero_padded[17:14] ^ ^data_in_zero_padded[25:22];
        parity_8_calc[3]  = ^data_in_zero_padded[25:18];
        parity_16_calc[3] = ^data_in_zero_padded[25:11];
      end : parity_calcs_3
    end : parity_calcs_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : parity_calcs_4_generate
      always @(*) 
      begin : parity_calcs_4
        parity_1_calc[4]  =  data_in_zero_padded[26] ^     data_in_zero_padded[28] ^ 
                             data_in_zero_padded[30] ^     data_in_zero_padded[32] ^ 
                             data_in_zero_padded[34] ^     data_in_zero_padded[36] ^ 
                             data_in_zero_padded[38] ^     data_in_zero_padded[40] ^ 
                             data_in_zero_padded[42] ^     data_in_zero_padded[44] ^ 
                             data_in_zero_padded[46] ^     data_in_zero_padded[48] ^ 
                             data_in_zero_padded[50] ^     data_in_zero_padded[52] ^ 
                             data_in_zero_padded[54] ^     data_in_zero_padded[56];
        parity_2_calc[4]  = ^data_in_zero_padded[28:27] ^ ^data_in_zero_padded[32:31] ^  
                            ^data_in_zero_padded[36:35] ^ ^data_in_zero_padded[40:39] ^  
                            ^data_in_zero_padded[44:43] ^ ^data_in_zero_padded[48:47] ^  
                            ^data_in_zero_padded[52:51] ^ ^data_in_zero_padded[56:55];
        parity_4_calc[4]  = ^data_in_zero_padded[32:29] ^ ^data_in_zero_padded[40:37] ^
                            ^data_in_zero_padded[48:45] ^ ^data_in_zero_padded[56:53];
        parity_8_calc[4]  = ^data_in_zero_padded[40:33] ^ ^data_in_zero_padded[56:49];
        parity_16_calc[4] = ^data_in_zero_padded[56:41];
        parity_32_calc[4] = ^data_in_zero_padded[56:26];
      end : parity_calcs_4
    end : parity_calcs_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : parity_calcs_5_generate
        always @(*)
        begin : parity_calcs_5
          parity_1_calc[5]  =  data_in_zero_padded[57]  ^      data_in_zero_padded[59] ^ 
                               data_in_zero_padded[61]  ^      data_in_zero_padded[63] ^ 
                               data_in_zero_padded[65]  ^      data_in_zero_padded[67] ^ 
                               data_in_zero_padded[69]  ^      data_in_zero_padded[71] ^ 
                               data_in_zero_padded[73]  ^      data_in_zero_padded[75] ^ 
                               data_in_zero_padded[77]  ^      data_in_zero_padded[79] ^ 
                               data_in_zero_padded[81]  ^      data_in_zero_padded[83] ^ 
                               data_in_zero_padded[85]  ^      data_in_zero_padded[87] ^ 
                               data_in_zero_padded[89]  ^      data_in_zero_padded[91] ^ 
                               data_in_zero_padded[93]  ^      data_in_zero_padded[95] ^ 
                               data_in_zero_padded[97]  ^      data_in_zero_padded[99] ^ 
                               data_in_zero_padded[101] ^      data_in_zero_padded[103] ^ 
                               data_in_zero_padded[105] ^      data_in_zero_padded[107] ^ 
                               data_in_zero_padded[109] ^      data_in_zero_padded[111] ^ 
                               data_in_zero_padded[113] ^      data_in_zero_padded[115] ^ 
                               data_in_zero_padded[117] ^      data_in_zero_padded[119];
          parity_2_calc[5]  = ^data_in_zero_padded[59:58]   ^ ^data_in_zero_padded[63:62]  ^ 
                              ^data_in_zero_padded[67:66]   ^ ^data_in_zero_padded[71:70]  ^ 
                              ^data_in_zero_padded[75:74]   ^ ^data_in_zero_padded[79:78]  ^ 
                              ^data_in_zero_padded[83:82]   ^ ^data_in_zero_padded[87:86]  ^ 
                              ^data_in_zero_padded[91:90]   ^ ^data_in_zero_padded[95:94]  ^ 
                              ^data_in_zero_padded[99:98]   ^ ^data_in_zero_padded[103:102] ^ 
                              ^data_in_zero_padded[107:106] ^ ^data_in_zero_padded[111:110] ^ 
                              ^data_in_zero_padded[115:114] ^ ^data_in_zero_padded[119:118];
          parity_4_calc[5]  = ^data_in_zero_padded[63:60]   ^ ^data_in_zero_padded[71:68] ^
                              ^data_in_zero_padded[79:76]   ^ ^data_in_zero_padded[87:84] ^
                              ^data_in_zero_padded[95:92]   ^ ^data_in_zero_padded[103:100] ^
                              ^data_in_zero_padded[111:108] ^ ^data_in_zero_padded[119:116];
          parity_8_calc[5]  = ^data_in_zero_padded[71:64]   ^ ^data_in_zero_padded[87:80] ^
                              ^data_in_zero_padded[103:96]  ^ ^data_in_zero_padded[119:112];
          parity_16_calc[5] = ^data_in_zero_padded[87:72]   ^ ^data_in_zero_padded[119:104];
          parity_32_calc[5] = ^data_in_zero_padded[119:88];
          parity_64_calc[5] = ^data_in_zero_padded[119:57];
      end : parity_calcs_5
    end : parity_calcs_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : parity_calcs_6_generate
      always @(*) 
      begin : parity_calcs_6
        parity_1_calc[6]   =  data_in_zero_padded[120] ^      data_in_zero_padded[122] ^ 
                              data_in_zero_padded[124] ^      data_in_zero_padded[126] ^ 
                              data_in_zero_padded[128] ^      data_in_zero_padded[130] ^ 
                              data_in_zero_padded[132] ^      data_in_zero_padded[134] ^ 
                              data_in_zero_padded[136] ^      data_in_zero_padded[138] ^ 
                              data_in_zero_padded[140] ^      data_in_zero_padded[142] ^ 
                              data_in_zero_padded[144] ^      data_in_zero_padded[146] ^ 
                              data_in_zero_padded[148] ^      data_in_zero_padded[150] ^ 
                              data_in_zero_padded[152] ^      data_in_zero_padded[154] ^ 
                              data_in_zero_padded[156] ^      data_in_zero_padded[158] ^ 
                              data_in_zero_padded[160] ^      data_in_zero_padded[162] ^ 
                              data_in_zero_padded[164] ^      data_in_zero_padded[166] ^ 
                              data_in_zero_padded[168] ^      data_in_zero_padded[170] ^ 
                              data_in_zero_padded[172] ^      data_in_zero_padded[174] ^ 
                              data_in_zero_padded[176] ^      data_in_zero_padded[178] ^ 
                              data_in_zero_padded[180] ^      data_in_zero_padded[182] ^ 
                              data_in_zero_padded[184] ^      data_in_zero_padded[186] ^ 
                              data_in_zero_padded[188] ^      data_in_zero_padded[190] ^ 
                              data_in_zero_padded[192] ^      data_in_zero_padded[194] ^ 
                              data_in_zero_padded[196] ^      data_in_zero_padded[198] ^ 
                              data_in_zero_padded[200] ^      data_in_zero_padded[202] ^ 
                              data_in_zero_padded[204] ^      data_in_zero_padded[206] ^ 
                              data_in_zero_padded[208] ^      data_in_zero_padded[210] ^ 
                              data_in_zero_padded[212] ^      data_in_zero_padded[214] ^ 
                              data_in_zero_padded[216] ^      data_in_zero_padded[218] ^ 
                              data_in_zero_padded[220] ^      data_in_zero_padded[222] ^ 
                              data_in_zero_padded[224] ^      data_in_zero_padded[226] ^ 
                              data_in_zero_padded[228] ^      data_in_zero_padded[230] ^ 
                              data_in_zero_padded[232] ^      data_in_zero_padded[234] ^ 
                              data_in_zero_padded[236] ^      data_in_zero_padded[238] ^ 
                              data_in_zero_padded[240] ^      data_in_zero_padded[242] ^ 
                              data_in_zero_padded[244] ^      data_in_zero_padded[246];
        parity_2_calc[6]   = ^data_in_zero_padded[122:121] ^ ^data_in_zero_padded[126:125] ^
                             ^data_in_zero_padded[130:129] ^ ^data_in_zero_padded[134:133] ^
                             ^data_in_zero_padded[138:137] ^ ^data_in_zero_padded[142:141] ^
                             ^data_in_zero_padded[146:145] ^ ^data_in_zero_padded[150:149] ^
                             ^data_in_zero_padded[154:153] ^ ^data_in_zero_padded[158:157] ^
                             ^data_in_zero_padded[162:161] ^ ^data_in_zero_padded[166:165] ^
                             ^data_in_zero_padded[170:169] ^ ^data_in_zero_padded[174:173] ^
                             ^data_in_zero_padded[178:177] ^ ^data_in_zero_padded[182:181] ^
                             ^data_in_zero_padded[186:185] ^ ^data_in_zero_padded[190:189] ^
                             ^data_in_zero_padded[194:193] ^ ^data_in_zero_padded[198:197] ^
                             ^data_in_zero_padded[202:201] ^ ^data_in_zero_padded[206:205] ^
                             ^data_in_zero_padded[210:209] ^ ^data_in_zero_padded[214:213] ^
                             ^data_in_zero_padded[218:217] ^ ^data_in_zero_padded[222:221] ^
                             ^data_in_zero_padded[226:225] ^ ^data_in_zero_padded[230:229] ^
                             ^data_in_zero_padded[234:233] ^ ^data_in_zero_padded[238:237] ^
                             ^data_in_zero_padded[242:241] ^ ^data_in_zero_padded[246:245];
        parity_4_calc[6]   = ^data_in_zero_padded[126:123] ^ ^data_in_zero_padded[134:131] ^
                             ^data_in_zero_padded[142:139] ^ ^data_in_zero_padded[150:147] ^
                             ^data_in_zero_padded[158:155] ^ ^data_in_zero_padded[166:163] ^
                             ^data_in_zero_padded[174:171] ^ ^data_in_zero_padded[182:179] ^
                             ^data_in_zero_padded[190:187] ^ ^data_in_zero_padded[198:195] ^
                             ^data_in_zero_padded[206:203] ^ ^data_in_zero_padded[214:211] ^
                             ^data_in_zero_padded[222:219] ^ ^data_in_zero_padded[230:227] ^
                             ^data_in_zero_padded[238:235] ^ ^data_in_zero_padded[246:243];
        parity_8_calc[6]   = ^data_in_zero_padded[134:127] ^ ^data_in_zero_padded[150:143] ^
                             ^data_in_zero_padded[166:159] ^ ^data_in_zero_padded[182:175] ^
                             ^data_in_zero_padded[198:191] ^ ^data_in_zero_padded[214:207] ^
                             ^data_in_zero_padded[230:223] ^ ^data_in_zero_padded[246:239];
        parity_16_calc[6]  = ^data_in_zero_padded[150:135] ^ ^data_in_zero_padded[182:167] ^
                             ^data_in_zero_padded[214:199] ^ ^data_in_zero_padded[246:231];
        parity_32_calc[6]  = ^data_in_zero_padded[182:151] ^ ^data_in_zero_padded[246:215];
        parity_64_calc[6]  = ^data_in_zero_padded[246:183];
        parity_128_calc[6] = ^data_in_zero_padded[246:120];
      end : parity_calcs_6
    end : parity_calcs_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : parity_calcs_7_generate
      always @(*) 
      begin : parity_calcs_7
        parity_1_calc[7]   =  data_in_zero_padded[247] ^      data_in_zero_padded[249] ^ 
                              data_in_zero_padded[251] ^      data_in_zero_padded[253] ^ 
                              data_in_zero_padded[255] ^      data_in_zero_padded[257] ^ 
                              data_in_zero_padded[259] ^      data_in_zero_padded[261] ^ 
                              data_in_zero_padded[263] ^      data_in_zero_padded[265] ^ 
                              data_in_zero_padded[267] ^      data_in_zero_padded[269] ^ 
                              data_in_zero_padded[271] ^      data_in_zero_padded[273] ^ 
                              data_in_zero_padded[275] ^      data_in_zero_padded[277] ^ 
                              data_in_zero_padded[279] ^      data_in_zero_padded[281] ^ 
                              data_in_zero_padded[283] ^      data_in_zero_padded[285] ^ 
                              data_in_zero_padded[287] ^      data_in_zero_padded[289] ^ 
                              data_in_zero_padded[291] ^      data_in_zero_padded[293] ^ 
                              data_in_zero_padded[295] ^      data_in_zero_padded[297] ^ 
                              data_in_zero_padded[299] ^      data_in_zero_padded[301] ^ 
                              data_in_zero_padded[303] ^      data_in_zero_padded[305] ^ 
                              data_in_zero_padded[307] ^      data_in_zero_padded[309] ^ 
                              data_in_zero_padded[311] ^      data_in_zero_padded[313] ^ 
                              data_in_zero_padded[315] ^      data_in_zero_padded[317] ^ 
                              data_in_zero_padded[319] ^      data_in_zero_padded[321] ^ 
                              data_in_zero_padded[323] ^      data_in_zero_padded[325] ^ 
                              data_in_zero_padded[327] ^      data_in_zero_padded[329] ^ 
                              data_in_zero_padded[331] ^      data_in_zero_padded[333] ^ 
                              data_in_zero_padded[335] ^      data_in_zero_padded[337] ^ 
                              data_in_zero_padded[339] ^      data_in_zero_padded[341] ^ 
                              data_in_zero_padded[343] ^      data_in_zero_padded[345] ^ 
                              data_in_zero_padded[347] ^      data_in_zero_padded[349] ^ 
                              data_in_zero_padded[351] ^      data_in_zero_padded[353] ^ 
                              data_in_zero_padded[355] ^      data_in_zero_padded[357] ^ 
                              data_in_zero_padded[359] ^      data_in_zero_padded[361] ^ 
                              data_in_zero_padded[363] ^      data_in_zero_padded[365] ^ 
                              data_in_zero_padded[367] ^      data_in_zero_padded[369] ^ 
                              data_in_zero_padded[371] ^      data_in_zero_padded[373] ^ 
                              data_in_zero_padded[375] ^      data_in_zero_padded[377] ^ 
                              data_in_zero_padded[379] ^      data_in_zero_padded[381] ^ 
                              data_in_zero_padded[383] ^      data_in_zero_padded[385] ^ 
                              data_in_zero_padded[387] ^      data_in_zero_padded[389] ^ 
                              data_in_zero_padded[391] ^      data_in_zero_padded[393] ^ 
                              data_in_zero_padded[395] ^      data_in_zero_padded[397] ^ 
                              data_in_zero_padded[399] ^      data_in_zero_padded[401] ^ 
                              data_in_zero_padded[403] ^      data_in_zero_padded[405] ^ 
                              data_in_zero_padded[407] ^      data_in_zero_padded[409] ^ 
                              data_in_zero_padded[411] ^      data_in_zero_padded[413] ^ 
                              data_in_zero_padded[415] ^      data_in_zero_padded[417] ^ 
                              data_in_zero_padded[419] ^      data_in_zero_padded[421] ^ 
                              data_in_zero_padded[423] ^      data_in_zero_padded[425] ^ 
                              data_in_zero_padded[427] ^      data_in_zero_padded[429] ^ 
                              data_in_zero_padded[431] ^      data_in_zero_padded[433] ^ 
                              data_in_zero_padded[435] ^      data_in_zero_padded[437] ^ 
                              data_in_zero_padded[439] ^      data_in_zero_padded[441] ^ 
                              data_in_zero_padded[443] ^      data_in_zero_padded[445] ^ 
                              data_in_zero_padded[447] ^      data_in_zero_padded[449] ^ 
                              data_in_zero_padded[451] ^      data_in_zero_padded[453] ^ 
                              data_in_zero_padded[455] ^      data_in_zero_padded[457] ^ 
                              data_in_zero_padded[459] ^      data_in_zero_padded[461] ^ 
                              data_in_zero_padded[463] ^      data_in_zero_padded[465] ^ 
                              data_in_zero_padded[467] ^      data_in_zero_padded[469] ^ 
                              data_in_zero_padded[471] ^      data_in_zero_padded[473] ^ 
                              data_in_zero_padded[475] ^      data_in_zero_padded[477] ^ 
                              data_in_zero_padded[479] ^      data_in_zero_padded[481] ^ 
                              data_in_zero_padded[483] ^      data_in_zero_padded[485] ^ 
                              data_in_zero_padded[487] ^      data_in_zero_padded[489] ^ 
                              data_in_zero_padded[491] ^      data_in_zero_padded[493] ^ 
                              data_in_zero_padded[495] ^      data_in_zero_padded[497] ^ 
                              data_in_zero_padded[499] ^      data_in_zero_padded[501]; 
        parity_2_calc[7]   = ^data_in_zero_padded[249:248] ^ ^data_in_zero_padded[253:252] ^
                             ^data_in_zero_padded[257:256] ^ ^data_in_zero_padded[261:260] ^
                             ^data_in_zero_padded[265:264] ^ ^data_in_zero_padded[269:268] ^
                             ^data_in_zero_padded[273:272] ^ ^data_in_zero_padded[277:276] ^
                             ^data_in_zero_padded[281:280] ^ ^data_in_zero_padded[285:284] ^
                             ^data_in_zero_padded[289:288] ^ ^data_in_zero_padded[293:292] ^
                             ^data_in_zero_padded[297:296] ^ ^data_in_zero_padded[301:300] ^
                             ^data_in_zero_padded[305:304] ^ ^data_in_zero_padded[309:308] ^
                             ^data_in_zero_padded[313:312] ^ ^data_in_zero_padded[317:316] ^
                             ^data_in_zero_padded[321:320] ^ ^data_in_zero_padded[325:324] ^
                             ^data_in_zero_padded[329:328] ^ ^data_in_zero_padded[333:332] ^
                             ^data_in_zero_padded[337:336] ^ ^data_in_zero_padded[341:340] ^
                             ^data_in_zero_padded[345:344] ^ ^data_in_zero_padded[349:348] ^
                             ^data_in_zero_padded[353:352] ^ ^data_in_zero_padded[357:356] ^
                             ^data_in_zero_padded[361:360] ^ ^data_in_zero_padded[365:364] ^
                             ^data_in_zero_padded[369:368] ^ ^data_in_zero_padded[373:372] ^
                             ^data_in_zero_padded[377:376] ^ ^data_in_zero_padded[381:380] ^
                             ^data_in_zero_padded[385:384] ^ ^data_in_zero_padded[389:388] ^
                             ^data_in_zero_padded[393:392] ^ ^data_in_zero_padded[397:396] ^
                             ^data_in_zero_padded[401:400] ^ ^data_in_zero_padded[405:404] ^
                             ^data_in_zero_padded[409:408] ^ ^data_in_zero_padded[413:412] ^
                             ^data_in_zero_padded[417:416] ^ ^data_in_zero_padded[421:420] ^
                             ^data_in_zero_padded[425:424] ^ ^data_in_zero_padded[429:428] ^
                             ^data_in_zero_padded[433:432] ^ ^data_in_zero_padded[437:436] ^
                             ^data_in_zero_padded[441:440] ^ ^data_in_zero_padded[445:444] ^
                             ^data_in_zero_padded[449:448] ^ ^data_in_zero_padded[453:452] ^
                             ^data_in_zero_padded[457:456] ^ ^data_in_zero_padded[461:460] ^
                             ^data_in_zero_padded[465:464] ^ ^data_in_zero_padded[469:468] ^
                             ^data_in_zero_padded[473:472] ^ ^data_in_zero_padded[477:476] ^
                             ^data_in_zero_padded[481:480] ^ ^data_in_zero_padded[485:484] ^
                             ^data_in_zero_padded[489:488] ^ ^data_in_zero_padded[493:492] ^
                             ^data_in_zero_padded[497:496] ^ ^data_in_zero_padded[501:500];
        parity_4_calc[7]   = ^data_in_zero_padded[253:250] ^ ^data_in_zero_padded[261:258] ^
                             ^data_in_zero_padded[269:266] ^ ^data_in_zero_padded[277:274] ^
                             ^data_in_zero_padded[285:282] ^ ^data_in_zero_padded[293:290] ^
                             ^data_in_zero_padded[301:298] ^ ^data_in_zero_padded[309:306] ^
                             ^data_in_zero_padded[317:314] ^ ^data_in_zero_padded[325:322] ^
                             ^data_in_zero_padded[333:330] ^ ^data_in_zero_padded[341:338] ^
                             ^data_in_zero_padded[349:346] ^ ^data_in_zero_padded[357:354]  ^
                             ^data_in_zero_padded[365:362] ^ ^data_in_zero_padded[373:370] ^
                             ^data_in_zero_padded[381:378] ^ ^data_in_zero_padded[389:386] ^
                             ^data_in_zero_padded[397:394] ^ ^data_in_zero_padded[405:402] ^
                             ^data_in_zero_padded[413:410] ^ ^data_in_zero_padded[421:418] ^
                             ^data_in_zero_padded[429:426] ^ ^data_in_zero_padded[437:434] ^
                             ^data_in_zero_padded[445:442] ^ ^data_in_zero_padded[453:450] ^
                             ^data_in_zero_padded[461:458] ^ ^data_in_zero_padded[469:466] ^
                             ^data_in_zero_padded[477:474] ^ ^data_in_zero_padded[485:482] ^
                             ^data_in_zero_padded[493:490] ^ ^data_in_zero_padded[501:498];
        parity_8_calc[7]   = ^data_in_zero_padded[261:254] ^ ^data_in_zero_padded[277:270] ^
                             ^data_in_zero_padded[293:286] ^ ^data_in_zero_padded[309:302] ^
                             ^data_in_zero_padded[325:318] ^ ^data_in_zero_padded[341:334] ^
                             ^data_in_zero_padded[357:350] ^ ^data_in_zero_padded[373:366] ^
                             ^data_in_zero_padded[389:382] ^ ^data_in_zero_padded[405:398] ^
                             ^data_in_zero_padded[421:414] ^ ^data_in_zero_padded[437:430] ^
                             ^data_in_zero_padded[453:446] ^ ^data_in_zero_padded[469:462] ^
                             ^data_in_zero_padded[485:478] ^ ^data_in_zero_padded[501:494];
        parity_16_calc[7]  = ^data_in_zero_padded[277:262] ^ ^data_in_zero_padded[309:294] ^
                             ^data_in_zero_padded[341:326] ^ ^data_in_zero_padded[373:358] ^
                             ^data_in_zero_padded[405:390] ^ ^data_in_zero_padded[437:422] ^
                             ^data_in_zero_padded[469:454] ^ ^data_in_zero_padded[501:486];
        parity_32_calc[7]  = ^data_in_zero_padded[309:278] ^ ^data_in_zero_padded[373:342] ^
                             ^data_in_zero_padded[437:406] ^ ^data_in_zero_padded[501:470];
        parity_64_calc[7]  = ^data_in_zero_padded[373:310] ^ ^data_in_zero_padded[501:438];
        parity_128_calc[7] = ^data_in_zero_padded[501:374];
        parity_256_calc[7] = ^data_in_zero_padded[501:247];
      end : parity_calcs_7
    end : parity_calcs_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : parity_calcs_8_generate
      always @(*) 
      begin : parity_calcs_8
      parity_1_calc[8]   =  data_in_zero_padded[502]  ^     	data_in_zero_padded[504] ^ 
                            data_in_zero_padded[506]  ^     	data_in_zero_padded[508] ^ 
                            data_in_zero_padded[510]  ^     	data_in_zero_padded[512] ^ 
                            data_in_zero_padded[514]  ^     	data_in_zero_padded[516] ^ 
                            data_in_zero_padded[518]  ^     	data_in_zero_padded[520] ^ 
                            data_in_zero_padded[522]  ^     	data_in_zero_padded[524] ^ 
                            data_in_zero_padded[526]  ^     	data_in_zero_padded[528] ^ 
                            data_in_zero_padded[530]  ^     	data_in_zero_padded[532] ^ 
                            data_in_zero_padded[534]  ^     	data_in_zero_padded[536] ^ 
                            data_in_zero_padded[538]  ^     	data_in_zero_padded[540] ^ 
                            data_in_zero_padded[542]  ^     	data_in_zero_padded[544] ^ 
                            data_in_zero_padded[546]  ^     	data_in_zero_padded[548] ^ 
                            data_in_zero_padded[550]  ^     	data_in_zero_padded[552] ^ 
                            data_in_zero_padded[554]  ^     	data_in_zero_padded[556] ^ 
                            data_in_zero_padded[558]  ^     	data_in_zero_padded[560] ^ 
                            data_in_zero_padded[562]  ^     	data_in_zero_padded[564] ^ 
                            data_in_zero_padded[566]  ^     	data_in_zero_padded[568] ^ 
                            data_in_zero_padded[570]  ^     	data_in_zero_padded[572] ^ 
                            data_in_zero_padded[574]  ^     	data_in_zero_padded[576] ^ 
                            data_in_zero_padded[578]  ^     	data_in_zero_padded[580] ^ 
                            data_in_zero_padded[582]  ^     	data_in_zero_padded[584] ^ 
                            data_in_zero_padded[586]  ^     	data_in_zero_padded[588] ^ 
                            data_in_zero_padded[590]  ^     	data_in_zero_padded[592] ^ 
                            data_in_zero_padded[594]  ^     	data_in_zero_padded[596] ^ 
                            data_in_zero_padded[598]  ^     	data_in_zero_padded[600] ^ 
                            data_in_zero_padded[602]  ^     	data_in_zero_padded[604] ^ 
                            data_in_zero_padded[606]  ^     	data_in_zero_padded[608] ^ 
                            data_in_zero_padded[610]  ^     	data_in_zero_padded[612] ^ 
                            data_in_zero_padded[614]  ^     	data_in_zero_padded[616] ^ 
                            data_in_zero_padded[618]  ^     	data_in_zero_padded[620] ^ 
                            data_in_zero_padded[622]  ^     	data_in_zero_padded[624] ^ 
                            data_in_zero_padded[626]  ^     	data_in_zero_padded[628] ^ 
                            data_in_zero_padded[630]  ^     	data_in_zero_padded[632] ^ 
                            data_in_zero_padded[634]  ^     	data_in_zero_padded[636] ^ 
                            data_in_zero_padded[638]  ^     	data_in_zero_padded[640] ^ 
                            data_in_zero_padded[642]  ^     	data_in_zero_padded[644] ^ 
                            data_in_zero_padded[646]  ^     	data_in_zero_padded[648] ^ 
                            data_in_zero_padded[650]  ^     	data_in_zero_padded[652] ^ 
                            data_in_zero_padded[654]  ^     	data_in_zero_padded[656] ^ 
                            data_in_zero_padded[658]  ^     	data_in_zero_padded[660] ^ 
                            data_in_zero_padded[662]  ^     	data_in_zero_padded[664] ^ 
                            data_in_zero_padded[666]  ^     	data_in_zero_padded[668] ^ 
                            data_in_zero_padded[670]  ^     	data_in_zero_padded[672] ^ 
                            data_in_zero_padded[674]  ^     	data_in_zero_padded[676] ^ 
                            data_in_zero_padded[678]  ^     	data_in_zero_padded[680] ^ 
                            data_in_zero_padded[682]  ^     	data_in_zero_padded[684] ^ 
                            data_in_zero_padded[686]  ^     	data_in_zero_padded[688] ^ 
                            data_in_zero_padded[690]  ^     	data_in_zero_padded[692] ^ 
                            data_in_zero_padded[694]  ^     	data_in_zero_padded[696] ^ 
                            data_in_zero_padded[698]  ^     	data_in_zero_padded[700] ^ 
                            data_in_zero_padded[702]  ^     	data_in_zero_padded[704] ^ 
                            data_in_zero_padded[706]  ^     	data_in_zero_padded[708] ^ 
                            data_in_zero_padded[710]  ^     	data_in_zero_padded[712] ^ 
                            data_in_zero_padded[714]  ^     	data_in_zero_padded[716] ^ 
                            data_in_zero_padded[718]  ^     	data_in_zero_padded[720] ^ 
                            data_in_zero_padded[722]  ^     	data_in_zero_padded[724] ^ 
                            data_in_zero_padded[726]  ^     	data_in_zero_padded[728] ^ 
                            data_in_zero_padded[730]  ^     	data_in_zero_padded[732] ^ 
                            data_in_zero_padded[734]  ^     	data_in_zero_padded[736] ^ 
                            data_in_zero_padded[738]  ^     	data_in_zero_padded[740] ^ 
                            data_in_zero_padded[742]  ^     	data_in_zero_padded[744] ^ 
                            data_in_zero_padded[746]  ^     	data_in_zero_padded[748] ^ 
                            data_in_zero_padded[750]  ^     	data_in_zero_padded[752] ^ 
                            data_in_zero_padded[754]  ^     	data_in_zero_padded[756] ^ 
                            data_in_zero_padded[758]  ^     	data_in_zero_padded[760] ^ 
                            data_in_zero_padded[762]  ^     	data_in_zero_padded[764] ^ 
                            data_in_zero_padded[766]  ^     	data_in_zero_padded[768] ^ 
                            data_in_zero_padded[770]  ^     	data_in_zero_padded[772] ^ 
                            data_in_zero_padded[774]  ^     	data_in_zero_padded[776] ^ 
                            data_in_zero_padded[778]  ^     	data_in_zero_padded[780] ^ 
                            data_in_zero_padded[782]  ^     	data_in_zero_padded[784] ^ 
                            data_in_zero_padded[786]  ^     	data_in_zero_padded[788] ^ 
                            data_in_zero_padded[790]  ^     	data_in_zero_padded[792] ^ 
                            data_in_zero_padded[794]  ^     	data_in_zero_padded[796] ^ 
                            data_in_zero_padded[798]  ^     	data_in_zero_padded[800] ^ 
                            data_in_zero_padded[802]  ^     	data_in_zero_padded[804] ^ 
                            data_in_zero_padded[806]  ^     	data_in_zero_padded[808] ^ 
                            data_in_zero_padded[810]  ^     	data_in_zero_padded[812] ^ 
                            data_in_zero_padded[814]  ^     	data_in_zero_padded[816] ^ 
                            data_in_zero_padded[818]  ^     	data_in_zero_padded[820] ^ 
                            data_in_zero_padded[822]  ^     	data_in_zero_padded[824] ^ 
                            data_in_zero_padded[826]  ^     	data_in_zero_padded[828] ^ 
                            data_in_zero_padded[830]  ^     	data_in_zero_padded[832] ^ 
                            data_in_zero_padded[834]  ^     	data_in_zero_padded[836] ^ 
                            data_in_zero_padded[838]  ^     	data_in_zero_padded[840] ^ 
                            data_in_zero_padded[842]  ^     	data_in_zero_padded[844] ^ 
                            data_in_zero_padded[846]  ^     	data_in_zero_padded[848] ^ 
                            data_in_zero_padded[850]  ^     	data_in_zero_padded[852] ^ 
                            data_in_zero_padded[854]  ^     	data_in_zero_padded[856] ^ 
                            data_in_zero_padded[858]  ^     	data_in_zero_padded[860] ^ 
                            data_in_zero_padded[862]  ^     	data_in_zero_padded[864] ^ 
                            data_in_zero_padded[866]  ^     	data_in_zero_padded[868] ^ 
                            data_in_zero_padded[870]  ^     	data_in_zero_padded[872] ^ 
                            data_in_zero_padded[874]  ^     	data_in_zero_padded[876] ^ 
                            data_in_zero_padded[878]  ^     	data_in_zero_padded[880] ^ 
                            data_in_zero_padded[882]  ^     	data_in_zero_padded[884] ^ 
                            data_in_zero_padded[886]  ^     	data_in_zero_padded[888] ^ 
                            data_in_zero_padded[890]  ^     	data_in_zero_padded[892] ^ 
                            data_in_zero_padded[894]  ^     	data_in_zero_padded[896] ^ 
                            data_in_zero_padded[898]  ^     	data_in_zero_padded[900] ^ 
                            data_in_zero_padded[902]  ^     	data_in_zero_padded[904] ^ 
                            data_in_zero_padded[906]  ^     	data_in_zero_padded[908] ^ 
                            data_in_zero_padded[910]  ^     	data_in_zero_padded[912] ^ 
                            data_in_zero_padded[914]  ^     	data_in_zero_padded[916] ^ 
                            data_in_zero_padded[918]  ^     	data_in_zero_padded[920] ^ 
                            data_in_zero_padded[922]  ^     	data_in_zero_padded[924] ^ 
                            data_in_zero_padded[926]  ^     	data_in_zero_padded[928] ^ 
                            data_in_zero_padded[930]  ^     	data_in_zero_padded[932] ^ 
                            data_in_zero_padded[934]  ^     	data_in_zero_padded[936] ^ 
                            data_in_zero_padded[938]  ^     	data_in_zero_padded[940] ^ 
                            data_in_zero_padded[942]  ^     	data_in_zero_padded[944] ^ 
                            data_in_zero_padded[946]  ^     	data_in_zero_padded[948] ^ 
                            data_in_zero_padded[950]  ^     	data_in_zero_padded[952] ^ 
                            data_in_zero_padded[954]  ^     	data_in_zero_padded[956] ^ 
                            data_in_zero_padded[958]  ^     	data_in_zero_padded[960] ^ 
                            data_in_zero_padded[962]  ^     	data_in_zero_padded[964] ^ 
                            data_in_zero_padded[966]  ^     	data_in_zero_padded[968] ^ 
                            data_in_zero_padded[970]  ^     	data_in_zero_padded[972] ^ 
                            data_in_zero_padded[974]  ^     	data_in_zero_padded[976] ^ 
                            data_in_zero_padded[978]  ^     	data_in_zero_padded[980] ^ 
                            data_in_zero_padded[982]  ^     	data_in_zero_padded[984] ^ 
                            data_in_zero_padded[986]  ^     	data_in_zero_padded[988] ^ 
                            data_in_zero_padded[990]  ^     	data_in_zero_padded[992] ^ 
                            data_in_zero_padded[994]  ^     	data_in_zero_padded[996] ^ 
                            data_in_zero_padded[998]  ^     	data_in_zero_padded[1000] ^ 
                            data_in_zero_padded[1002] ^       data_in_zero_padded[1004] ^ 
                            data_in_zero_padded[1006] ^       data_in_zero_padded[1008] ^ 
                            data_in_zero_padded[1010] ^       data_in_zero_padded[1012];
      parity_2_calc[8]   = ^data_in_zero_padded[504:503]   ^ ^data_in_zero_padded[508:507] ^
                           ^data_in_zero_padded[512:511]   ^ ^data_in_zero_padded[516:515] ^
                           ^data_in_zero_padded[520:519]   ^ ^data_in_zero_padded[524:523] ^
                           ^data_in_zero_padded[528:527]   ^ ^data_in_zero_padded[532:531] ^
                           ^data_in_zero_padded[536:535]   ^ ^data_in_zero_padded[540:539] ^
                           ^data_in_zero_padded[544:543]   ^ ^data_in_zero_padded[548:547] ^
                           ^data_in_zero_padded[552:551]   ^ ^data_in_zero_padded[556:555] ^
                           ^data_in_zero_padded[560:559]   ^ ^data_in_zero_padded[564:563] ^
                           ^data_in_zero_padded[568:567]   ^ ^data_in_zero_padded[572:571] ^
                           ^data_in_zero_padded[576:575]   ^ ^data_in_zero_padded[580:579] ^
                           ^data_in_zero_padded[584:583]   ^ ^data_in_zero_padded[588:587] ^
                           ^data_in_zero_padded[592:591]   ^ ^data_in_zero_padded[596:595] ^
                           ^data_in_zero_padded[600:599]   ^ ^data_in_zero_padded[604:603] ^
                           ^data_in_zero_padded[608:607]   ^ ^data_in_zero_padded[612:611] ^
                           ^data_in_zero_padded[616:615]   ^ ^data_in_zero_padded[620:619] ^
                           ^data_in_zero_padded[624:623]   ^ ^data_in_zero_padded[628:627] ^
                           ^data_in_zero_padded[632:631]   ^ ^data_in_zero_padded[636:635] ^
                           ^data_in_zero_padded[640:639]   ^ ^data_in_zero_padded[644:643] ^
                           ^data_in_zero_padded[648:647]   ^ ^data_in_zero_padded[652:651] ^
                           ^data_in_zero_padded[656:655]   ^ ^data_in_zero_padded[660:659] ^
                           ^data_in_zero_padded[664:663]   ^ ^data_in_zero_padded[668:667] ^
                           ^data_in_zero_padded[672:671]   ^ ^data_in_zero_padded[676:675] ^
                           ^data_in_zero_padded[680:679]   ^ ^data_in_zero_padded[684:683] ^
                           ^data_in_zero_padded[688:687]   ^ ^data_in_zero_padded[692:691] ^
                           ^data_in_zero_padded[696:695]   ^ ^data_in_zero_padded[700:699] ^
                           ^data_in_zero_padded[704:703]   ^ ^data_in_zero_padded[708:707] ^
                           ^data_in_zero_padded[712:711]   ^ ^data_in_zero_padded[716:715] ^
                           ^data_in_zero_padded[720:719]   ^ ^data_in_zero_padded[724:723] ^
                           ^data_in_zero_padded[728:727]   ^ ^data_in_zero_padded[732:731] ^
                           ^data_in_zero_padded[736:735]   ^ ^data_in_zero_padded[740:739] ^
                           ^data_in_zero_padded[744:743]   ^ ^data_in_zero_padded[748:747] ^
                           ^data_in_zero_padded[752:751]   ^ ^data_in_zero_padded[756:755] ^
                           ^data_in_zero_padded[760:759]   ^ ^data_in_zero_padded[764:763] ^
                           ^data_in_zero_padded[768:767]   ^ ^data_in_zero_padded[772:771] ^
                           ^data_in_zero_padded[776:775]   ^ ^data_in_zero_padded[780:779] ^
                           ^data_in_zero_padded[784:783]   ^ ^data_in_zero_padded[788:787] ^
                           ^data_in_zero_padded[792:791]   ^ ^data_in_zero_padded[796:795] ^
                           ^data_in_zero_padded[800:799]   ^ ^data_in_zero_padded[804:803] ^
                           ^data_in_zero_padded[808:807]   ^ ^data_in_zero_padded[812:811] ^
                           ^data_in_zero_padded[816:815]   ^ ^data_in_zero_padded[820:819] ^
                           ^data_in_zero_padded[824:823]   ^ ^data_in_zero_padded[828:827] ^
                           ^data_in_zero_padded[832:831]   ^ ^data_in_zero_padded[836:835] ^
                           ^data_in_zero_padded[840:839]   ^ ^data_in_zero_padded[844:843] ^
                           ^data_in_zero_padded[848:847]   ^ ^data_in_zero_padded[852:851] ^
                           ^data_in_zero_padded[856:855]   ^ ^data_in_zero_padded[860:859] ^
                           ^data_in_zero_padded[864:863]   ^ ^data_in_zero_padded[868:867] ^
                           ^data_in_zero_padded[872:871]   ^ ^data_in_zero_padded[876:875] ^
                           ^data_in_zero_padded[880:879]   ^ ^data_in_zero_padded[884:883] ^
                           ^data_in_zero_padded[888:887]   ^ ^data_in_zero_padded[892:891] ^
                           ^data_in_zero_padded[896:895]   ^ ^data_in_zero_padded[900:899] ^
                           ^data_in_zero_padded[904:903]   ^ ^data_in_zero_padded[908:907] ^
                           ^data_in_zero_padded[912:911]   ^ ^data_in_zero_padded[916:915] ^
                           ^data_in_zero_padded[920:919]   ^ ^data_in_zero_padded[924:923] ^
                           ^data_in_zero_padded[928:927]   ^ ^data_in_zero_padded[932:931] ^
                           ^data_in_zero_padded[936:935]   ^ ^data_in_zero_padded[940:939] ^
                           ^data_in_zero_padded[944:943]   ^ ^data_in_zero_padded[948:947] ^
                           ^data_in_zero_padded[952:951]   ^ ^data_in_zero_padded[956:955] ^
                           ^data_in_zero_padded[960:959]   ^ ^data_in_zero_padded[964:963] ^
                           ^data_in_zero_padded[968:967]   ^ ^data_in_zero_padded[972:971] ^
                           ^data_in_zero_padded[976:975]   ^ ^data_in_zero_padded[980:979] ^
                           ^data_in_zero_padded[984:983]   ^ ^data_in_zero_padded[988:987] ^
                           ^data_in_zero_padded[992:991]   ^ ^data_in_zero_padded[996:995] ^
                           ^data_in_zero_padded[1000:999]  ^ ^data_in_zero_padded[1004:1003] ^ 
                           ^data_in_zero_padded[1008:1007] ^ ^data_in_zero_padded[1012:1011];
      parity_4_calc[8]   = ^data_in_zero_padded[508:505]   ^ ^data_in_zero_padded[516:513] ^
                           ^data_in_zero_padded[524:521]   ^ ^data_in_zero_padded[532:529] ^
                           ^data_in_zero_padded[540:537]   ^ ^data_in_zero_padded[548:545] ^
                           ^data_in_zero_padded[556:553]   ^ ^data_in_zero_padded[564:561] ^
                           ^data_in_zero_padded[572:569]   ^ ^data_in_zero_padded[580:577] ^
                           ^data_in_zero_padded[588:585]   ^ ^data_in_zero_padded[596:593] ^
                           ^data_in_zero_padded[604:601]   ^ ^data_in_zero_padded[612:609] ^
                           ^data_in_zero_padded[620:617]   ^ ^data_in_zero_padded[628:625] ^
                           ^data_in_zero_padded[636:633]   ^ ^data_in_zero_padded[644:641] ^
                           ^data_in_zero_padded[652:649]   ^ ^data_in_zero_padded[660:657] ^
                           ^data_in_zero_padded[668:665]   ^ ^data_in_zero_padded[676:673] ^
                           ^data_in_zero_padded[684:681]   ^ ^data_in_zero_padded[692:689] ^
                           ^data_in_zero_padded[700:697]   ^ ^data_in_zero_padded[708:705] ^
                           ^data_in_zero_padded[716:713]   ^ ^data_in_zero_padded[724:721] ^
                           ^data_in_zero_padded[732:729]   ^ ^data_in_zero_padded[740:737] ^
                           ^data_in_zero_padded[748:745]   ^ ^data_in_zero_padded[756:753] ^
                           ^data_in_zero_padded[764:761]   ^ ^data_in_zero_padded[772:769] ^
                           ^data_in_zero_padded[780:777]   ^ ^data_in_zero_padded[788:785] ^
                           ^data_in_zero_padded[796:793]   ^ ^data_in_zero_padded[804:801] ^
                           ^data_in_zero_padded[812:809]   ^ ^data_in_zero_padded[820:817] ^
                           ^data_in_zero_padded[828:825]   ^ ^data_in_zero_padded[836:833] ^
                           ^data_in_zero_padded[844:841]   ^ ^data_in_zero_padded[852:849] ^
                           ^data_in_zero_padded[860:857]   ^ ^data_in_zero_padded[868:865] ^
                           ^data_in_zero_padded[876:873]   ^ ^data_in_zero_padded[884:881] ^
                           ^data_in_zero_padded[892:889]   ^ ^data_in_zero_padded[900:897] ^
                           ^data_in_zero_padded[908:905]   ^ ^data_in_zero_padded[916:913] ^
                           ^data_in_zero_padded[924:921]   ^ ^data_in_zero_padded[932:929] ^
                           ^data_in_zero_padded[940:937]   ^ ^data_in_zero_padded[948:945] ^
                           ^data_in_zero_padded[956:953]   ^ ^data_in_zero_padded[964:961] ^
                           ^data_in_zero_padded[972:969]   ^ ^data_in_zero_padded[980:977] ^
                           ^data_in_zero_padded[988:985]   ^ ^data_in_zero_padded[996:993] ^
                           ^data_in_zero_padded[1004:1001] ^ ^data_in_zero_padded[1012:1009];
      parity_8_calc[8]   = ^data_in_zero_padded[516:509]   ^ ^data_in_zero_padded[532:525] ^
                           ^data_in_zero_padded[548:541]   ^ ^data_in_zero_padded[564:557] ^
                           ^data_in_zero_padded[580:573]   ^ ^data_in_zero_padded[596:589] ^
                           ^data_in_zero_padded[612:605]   ^ ^data_in_zero_padded[628:621] ^
                           ^data_in_zero_padded[644:637]   ^ ^data_in_zero_padded[660:653] ^
                           ^data_in_zero_padded[676:669]   ^ ^data_in_zero_padded[692:685] ^
                           ^data_in_zero_padded[708:701]   ^ ^data_in_zero_padded[724:717] ^
                           ^data_in_zero_padded[740:733]   ^ ^data_in_zero_padded[756:749] ^
                           ^data_in_zero_padded[772:765]   ^ ^data_in_zero_padded[788:781] ^
                           ^data_in_zero_padded[804:797]   ^ ^data_in_zero_padded[820:813] ^
                           ^data_in_zero_padded[836:829]   ^ ^data_in_zero_padded[852:845] ^
                           ^data_in_zero_padded[868:861]   ^ ^data_in_zero_padded[884:877] ^
                           ^data_in_zero_padded[900:893]   ^ ^data_in_zero_padded[916:909] ^
                           ^data_in_zero_padded[932:925]   ^ ^data_in_zero_padded[948:941] ^
                           ^data_in_zero_padded[964:957]   ^ ^data_in_zero_padded[980:973] ^
                           ^data_in_zero_padded[996:989]   ^ ^data_in_zero_padded[1012:1005];
      parity_16_calc[8]  = ^data_in_zero_padded[532:517]   ^ ^data_in_zero_padded[564:549] ^
                           ^data_in_zero_padded[596:581]   ^ ^data_in_zero_padded[628:613] ^
                           ^data_in_zero_padded[660:645]   ^ ^data_in_zero_padded[692:677] ^
                           ^data_in_zero_padded[724:709]   ^ ^data_in_zero_padded[756:741] ^
                           ^data_in_zero_padded[788:773]   ^ ^data_in_zero_padded[820:805] ^
                           ^data_in_zero_padded[852:837]   ^ ^data_in_zero_padded[884:869] ^
                           ^data_in_zero_padded[916:901]   ^ ^data_in_zero_padded[948:933] ^
                           ^data_in_zero_padded[980:965]   ^ ^data_in_zero_padded[1012:997];
      parity_32_calc[8]  = ^data_in_zero_padded[564:533]   ^ ^data_in_zero_padded[628:597] ^
                           ^data_in_zero_padded[692:661]   ^ ^data_in_zero_padded[756:725] ^
                           ^data_in_zero_padded[820:789]   ^ ^data_in_zero_padded[884:853] ^
                           ^data_in_zero_padded[948:917]   ^ ^data_in_zero_padded[1012:981];
      parity_64_calc[8]  = ^data_in_zero_padded[628:565]   ^ ^data_in_zero_padded[756:693] ^
                           ^data_in_zero_padded[884:821]   ^ ^data_in_zero_padded[1012:949];
      parity_128_calc[8] = ^data_in_zero_padded[756:629]   ^ ^data_in_zero_padded[1012:885];
      parity_256_calc[8] = ^data_in_zero_padded[1012:757];
      parity_512_calc[8] = ^data_in_zero_padded[1012:502];
      end : parity_calcs_8
    end : parity_calcs_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 3) begin : parity_zero_padded_0_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_0
        parity_1_calc[PARITY_WIDTH_MAX-1:1]   = {(PARITY_WIDTH_MAX-1){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:1]   = {(PARITY_WIDTH_MAX-1){1'b0}};
        parity_4_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_0
    end : parity_zero_padded_0_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : parity_zero_padded_1_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_1
        parity_1_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_1
    end : parity_zero_padded_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : parity_zero_padded_2_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_2
        parity_1_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_2
    end : parity_zero_padded_2_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 6) begin : parity_zero_padded_3_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_3
        parity_1_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:4]  = {(PARITY_WIDTH_MAX-4){1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_3
    end : parity_zero_padded_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : parity_zero_padded_4_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_4
        parity_1_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_4
    end : parity_zero_padded_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : parity_zero_padded_5_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_5
        parity_1_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_5
    end : parity_zero_padded_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : parity_zero_padded_6_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_6
        parity_1_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_16_calc[2:0]                   = {4{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:7] = {(PARITY_WIDTH_MAX-7){1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_6
    end : parity_zero_padded_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : parity_zero_padded_7_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_7
        parity_1_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_256_calc[6:0]                  = {7{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : parity_zero_padded_7
    end : parity_zero_padded_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : parity_zero_padded_8_generate
      always @(data_in_zero_padded) 
      begin : parity_zero_padded_8
        parity_1_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_2_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_4_calc[0]                      = 1'b 0;
        parity_4_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_8_calc[1:0]                    = {2{1'b0}};
        parity_8_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_16_calc[2:0]                   = {3{1'b0}};
        parity_16_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_32_calc[3:0]                   = {4{1'b0}};
        parity_32_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_64_calc[4:0]                   = {5{1'b0}};
        parity_64_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_128_calc[5:0]                  = {6{1'b0}};
        parity_128_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_256_calc[6:0]                  = {7{1'b0}};
        parity_256_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        parity_512_calc[7:0]                  = {8{1'b0}};
        parity_512_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
      end : parity_zero_padded_8
    end : parity_zero_padded_8_generate
  endgenerate

  // *************************************************
  // Parity Generator Block
  // Only generate the parity generator circuitry when
  // performing a RAM write
  // *************************************************
  generate 
    if (MEMORY_WRITE == 1) begin : ram_write_generate
      miv_rv32_bist_ecc_write
        #(
          .DATA_WIDTH(DATA_WIDTH),
          .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
          .PARITY_WIDTH_MAX(PARITY_WIDTH_MAX),
          .MAX_DATA_WIDTH(MAX_DATA_WIDTH)
        )
        ecc_wirte
        (
          .parity_1_calc,
          .parity_2_calc,
          .parity_4_calc,
          .parity_8_calc,
          .parity_16_calc,
          .parity_32_calc,
          .parity_64_calc,
          .parity_128_calc,
          .parity_256_calc,
          .parity_512_calc,
          .data_in_zero_padded,
          .parity_out_output
        );
    end : ram_write_generate
  endgenerate

  // *************************************************
  // Check Bit Generator & Error-correction Circuitry
  // Only generate the parity generator circuitry when
  // performing a RAM read
  // *************************************************
  
  generate 
    if (MEMORY_READ == 1) begin : ram_read_generate
      miv_rv32_bist_ecc_read
        #(
          .DATA_WIDTH(DATA_WIDTH),
          .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH),
          .PARITY_WIDTH_MAX(PARITY_WIDTH_MAX),
          .MAX_DATA_WIDTH(MAX_DATA_WIDTH)
        )
        ecc_read
        (
          .ecc_bypass,
          .data_in,
          .parity_in,
          .parity_1_calc,
          .parity_2_calc,
          .parity_4_calc,
          .parity_8_calc,
          .parity_16_calc,
          .parity_32_calc,
          .parity_64_calc,
          .parity_128_calc,
          .parity_256_calc,
          .parity_512_calc,
          .data_in_zero_padded, 
          .parity_out_corrected_output,
          .check_out_output,
          .data_out_output,
          .err_multpl_output,
          .err_detect_output
        );
    end : ram_read_generate
  endgenerate

  // Assign appropriate signals to the output ports, based on the values chosen
  // for the read & write circuitry generics
  //
  // By default, all signals that are assigned to the output ports are initialized
  // to all 0's.  The output signals are assigned as follows:
  //
  // MEMORY_READ = '1':
  //
  //   parity_out_output  : assigned the parity bits
  //
  // MEMORY_WRITE = '1'
  //
  //   check_out_output   : assigned the check bits
  //   err_multpl_output  : assigned the multiple error detection flag
  //   err_detect_output  : assigned the error detection flag
  //   data_out_output    : assigned either the corrected data, or original data
  //                        (depending on the value of ecc_bypass)
  //
  // All un-used inputs must be connected to un-used outputs.
  // When this block is used at a higher level, the un-used ports
  // will be removed anyway.
  //
  // Three possible cases:
  //  1) write = 1, read = 0
  //
  //  un-used inputs:  parity_in and ecc_bypass
  //  un-used outputs: data_out, check_out, err_multpl,
  //                   and err_detect must
  //
  //  2) write = 0, read = 1
  //
  //  un-used inputs:  none
  //  un-used outputs: parity_out
  //
  //  3) write = 1, read = 1
  //
  //  un-used inputs:  none
  //  un-used outputs: none
  //
  // Case 1)
  generate 
    if ((MEMORY_WRITE == 1 && MEMORY_READ == 0)) begin : assign_all_outputs_1_generate
      
      // Connect the un-used inputs to the un-used outputs
      assign check_out  = parity_in;
      assign err_multpl = ecc_bypass;
      assign err_detect = ecc_bypass;
      assign data_out   = data_in;
      
      // Connect used outputs
      assign parity_out = parity_out_output;
          
      // No un-used outputs

    end : assign_all_outputs_1_generate
  endgenerate

  // Case 2)
  generate 
    if ((MEMORY_WRITE == 0 && MEMORY_READ == 1)) begin : assign_all_outputs_2_generate

      // No un-used inputs
      
      // Connect used outputs
      assign check_out  = check_out_output;
      assign data_out   = data_out_output;
      assign err_multpl = err_multpl_output;
      assign err_detect = err_detect_output;

      // Connect the corrected parity bits
      assign parity_out = parity_out_corrected_output;

    end : assign_all_outputs_2_generate
  endgenerate

  // Case 3)
  generate 
    if ((MEMORY_WRITE == 1 && MEMORY_READ == 1)) begin : assign_all_outputs_3_generate

      // No un-used inputs
      
      // Connect used outputs
      assign parity_out = parity_out_output;
      assign check_out  = check_out_output;
      assign err_multpl = err_multpl_output;
      assign err_detect = err_detect_output;
      assign data_out   = data_out_output;

      // No un-used outputs
      
    end : assign_all_outputs_3_generate
  endgenerate

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// Empty ECC module
//
// Parameter Descriptions:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_empty
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5
  )
  (
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    output      logic                        err_multpl,
    output      logic                        err_detect,
    output      logic [DATA_WIDTH-1:0]       data_out,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out
  );

// Start the RTL code:

      assign err_multpl = 1'b 0;
      assign err_detect = 1'b 0;
      assign data_out   = data_in;
      assign parity_out = {ECC_PARITY_WIDTH{1'b0}};
      assign check_out  = {ECC_PARITY_WIDTH{1'b0}};

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC read side module
//
// Parameter Description:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_read
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter PARITY_WIDTH_MAX = 11,
    parameter MAX_DATA_WIDTH   = 1013
  )
  (
    input  wire logic                        ecc_bypass,
    input  wire logic [DATA_WIDTH-1:0]       data_in,
    input  wire logic [ECC_PARITY_WIDTH-1:0] parity_in,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_1_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_2_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_4_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_8_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_16_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_32_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_64_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_128_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_256_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_512_calc,
    input  wire logic [MAX_DATA_WIDTH-1:0]   data_in_zero_padded, 
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected_output,
    output      logic [ECC_PARITY_WIDTH-1:0] check_out_output,
    output      logic [DATA_WIDTH - 1:0]     data_out_output,
    output      logic                        err_multpl_output,
    output      logic                        err_detect_output  
  );

// Implementation
localparam MAX_ADDR_WIDTH    = 1024;  
localparam MAX_TEMP_WIDTH    =  2 ** (ECC_PARITY_WIDTH-1);
localparam CHECK_TOTAL_WIDTH =  PARITY_WIDTH_MAX-1;
localparam ECC_FLAG_WIDTH    =  3;

logic [PARITY_WIDTH_MAX-1:0]  check_1_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_2_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_4_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_8_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_16_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_32_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_64_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_128_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_256_calc;
logic [PARITY_WIDTH_MAX-1:0]  check_512_calc;
logic [CHECK_TOTAL_WIDTH-1:0] check_total;
logic                         ct_check_bit;

// Signal used to determine if a single or multiple bit error occurred.
logic check_bits_all_zero;  

// 'data_in_zero_padded' bus assembled with the 'parity_in' bus.
// This bus is the data input (zero padded) mixed with the parity bits, to form
// the parity + data word (according to the Hamming SEC-DED ECC code).  Mixing
// the data input and parity bits together, allows one to address a single-bit
// error in the data word directly (and then correct it).
logic [MAX_TEMP_WIDTH-1:0] data_plus_parity;  

// Bus used to index into the specific data bit in error.  Used in the RAM Read
// circuitry.  The addr_index is all 0's, except for a '1' in the bit position
// where there is an error (in the 'data_plus_parity' bus).  Since the ECC 
// refers to the first bit position as bit one (not bit zero), the addr_index must
// be left-shifted by one bit.  The resulting bus is addr_index_corrected.
logic [MAX_TEMP_WIDTH-1:0] addr_index;
logic [MAX_TEMP_WIDTH-1:0] addr_index_corrected;
logic                      addr_index0_and_ct;  

// Bus used to store the corrected data output (the data_plus_parity after
// the problematic bit has been corrected).
logic [MAX_TEMP_WIDTH-1:0] data_plus_parity_corrected;  

// Bus used to re-assemble the 'data_plus_parity_corrected' bus onto.  This bus will
// then be output on the data_out bus, during a RAM read (provided ecc_bypass = '0').
logic [DATA_WIDTH-1:0] data_out_corrected;  

// Bus used to re-assemble the 'data_plus_parity_corrected' bus onto.  This bus will
// then be output on the parity_out bus, during a RAM read.
logic [ECC_PARITY_WIDTH-1:0] parity_out_corrected;  

// Start the RTL code:
  
  // Generate the individual check bits (excluding CT -- check total)
  // Generate all the intermediate check bits.
  // The same results that were used in calculating
  // the parity bits are used here.  The only difference
  // is that in some cases, a parity_in() bit may be
  // used.

  always @(*) begin : check_calcs_0_process
    check_1_calc[0] = parity_in[0] ^ parity_1_calc[0];
    check_2_calc[0] = parity_in[1] ^ parity_2_calc[0];
  end : check_calcs_0_process

  generate 
    if (DATA_WIDTH >= 2) begin : check_calcs_1_generate
      always @(*) begin : check_calcs_1_process
        check_1_calc[1] = parity_1_calc[1];
        check_2_calc[1] = parity_2_calc[1];
        check_4_calc[1] = parity_in[2] ^ parity_4_calc[1];
      end : check_calcs_1_process
    end : check_calcs_1_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : check_calcs_2_generate
      always @(*) begin : check_calcs_2_process
        check_1_calc[2] = parity_1_calc[2];
        check_2_calc[2] = parity_2_calc[2];
        check_4_calc[2] = parity_4_calc[2];
        check_8_calc[2] = parity_in[3] ^ parity_8_calc[2];
      end : check_calcs_2_process
    end : check_calcs_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : check_calcs_3_generate
      always @(*) begin : check_calcs_3_process
        check_1_calc[3]  = parity_1_calc[3];
        check_2_calc[3]  = parity_2_calc[3];
        check_4_calc[3]  = parity_4_calc[3];
        check_8_calc[3]  = parity_8_calc[3];
        check_16_calc[3] = parity_in[4] ^ parity_16_calc[3];
      end : check_calcs_3_process
    end : check_calcs_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : check_calcs_4_generate
      always @(*) begin : check_calcs_4_process
        check_1_calc[4]  = parity_1_calc[4];
        check_2_calc[4]  = parity_2_calc[4];
        check_4_calc[4]  = parity_4_calc[4];
        check_8_calc[4]  = parity_8_calc[4];
        check_16_calc[4] = parity_16_calc[4];
        check_32_calc[4] = parity_in[5] ^ parity_32_calc[4];
      end : check_calcs_4_process
    end : check_calcs_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : check_calcs_5_generate
      always @(*)  begin : check_calcs_5_process
        check_1_calc[5]  = parity_1_calc[5];
        check_2_calc[5]  = parity_2_calc[5];
        check_4_calc[5]  = parity_4_calc[5];
        check_8_calc[5]  = parity_8_calc[5];
        check_16_calc[5] = parity_16_calc[5];
        check_32_calc[5] = parity_32_calc[5];
        check_64_calc[5] = parity_in[6] ^ parity_64_calc[5];
      end : check_calcs_5_process
    end : check_calcs_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : check_calcs_6_generate
      always @(*) begin : check_calcs_6_process
        check_1_calc[6]   = parity_1_calc[6];
        check_2_calc[6]   = parity_2_calc[6];
        check_4_calc[6]   = parity_4_calc[6];
        check_8_calc[6]   = parity_8_calc[6];
        check_16_calc[6]  = parity_16_calc[6];
        check_32_calc[6]  = parity_32_calc[6];
        check_64_calc[6]  = parity_64_calc[6];
        check_128_calc[6] = parity_in[7] ^ parity_128_calc[6];
      end : check_calcs_6_process
    end : check_calcs_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : check_calcs_7_generate
      always @(*) begin : check_calcs_7_process
        check_1_calc[7]   = parity_1_calc[7];
        check_2_calc[7]   = parity_2_calc[7];
        check_4_calc[7]   = parity_4_calc[7];
        check_8_calc[7]   = parity_8_calc[7];
        check_16_calc[7]  = parity_16_calc[7];
        check_32_calc[7]  = parity_32_calc[7];
        check_64_calc[7]  = parity_64_calc[7];
        check_128_calc[7] = parity_128_calc[7];
        check_256_calc[7] = parity_in[8] ^ parity_256_calc[7];
      end : check_calcs_7_process
    end : check_calcs_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : check_calcs_8_generate
      always @(*) begin : check_calcs_8_process
        check_1_calc[8]   = parity_1_calc[8];
        check_2_calc[8]   = parity_2_calc[8];
        check_4_calc[8]   = parity_4_calc[8];
        check_8_calc[8]   = parity_8_calc[8];
        check_16_calc[8]  = parity_16_calc[8];
        check_32_calc[8]  = parity_32_calc[8];
        check_64_calc[8]  = parity_64_calc[8];
        check_128_calc[8] = parity_128_calc[8];
        check_256_calc[8] = parity_256_calc[8];
        check_512_calc[8] = parity_in[9] ^ parity_512_calc[8];
      end : check_calcs_8_process
    end : check_calcs_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 3) begin : check_zero_padded_0_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc) 
      begin : check_zero_padded_0_process
        check_1_calc[PARITY_WIDTH_MAX-1:1]   = {PARITY_WIDTH_MAX{1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:1]   = {PARITY_WIDTH_MAX{1'b0}};
        check_4_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_0_process
    end : check_zero_padded_0_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : check_zero_padded_1_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc)
      begin : check_zero_padded_1_process
        check_1_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:2]   = {(PARITY_WIDTH_MAX-2){1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:0]   = {PARITY_WIDTH_MAX{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_1_process
    end : check_zero_padded_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : check_zero_padded_2_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, parity_8_calc)
      begin : check_zero_padded_2_process
        check_1_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:3]   = {(PARITY_WIDTH_MAX-3){1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_2_process
    end : check_zero_padded_2_generate
  endgenerate

  generate if (ECC_PARITY_WIDTH == 6) begin : check_zero_padded_3_generate
    always@(parity_in, parity_1_calc, parity_2_calc,
            parity_4_calc, parity_8_calc, parity_16_calc) 
    begin : check_zero_padded_3_process
        check_1_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:4]   = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:4]  = {(PARITY_WIDTH_MAX-4){1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_3_process
    end : check_zero_padded_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : check_zero_padded_4_generate
      always@(parity_in, parity_1_calc, parity_2_calc,
              parity_4_calc, parity_8_calc, parity_16_calc, parity_32_calc)
      begin : check_zero_padded_4_process
        check_1_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:5]   = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:5]  = {(PARITY_WIDTH_MAX-5){1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:0]  = {PARITY_WIDTH_MAX{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_4_process
    end : check_zero_padded_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : check_zero_padded_5_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc)
      begin : check_zero_padded_5_process
        check_1_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:6]   = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:6]  = {(PARITY_WIDTH_MAX-6){1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_5_process
    end : check_zero_padded_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : check_zero_padded_6_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc)
      begin : check_zero_padded_6_process
        check_1_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:7]   = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:7]  = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:7] = {(PARITY_WIDTH_MAX-7){1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_6_process
    end : check_zero_padded_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : check_zero_padded_7_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc, parity_256_calc)
      begin : check_zero_padded_7_process
        check_1_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:8]   = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:8]  = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_256_calc[6:0]                  = {7{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:8] = {(PARITY_WIDTH_MAX-8){1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:0] = {PARITY_WIDTH_MAX{1'b0}};
      end : check_zero_padded_7_process
    end : check_zero_padded_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : check_zero_padded_8_generate
      always@(parity_in, parity_1_calc, parity_2_calc, parity_4_calc, 
              parity_8_calc, parity_16_calc, parity_32_calc, parity_64_calc, 
              parity_128_calc, parity_256_calc, parity_512_calc)
      begin : check_zero_padded_8_process
        check_1_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_2_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_4_calc[0]                      = 1'b 0;
        check_4_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_8_calc[1:0]                    = {2{1'b0}};
        check_8_calc[PARITY_WIDTH_MAX-1:9]   = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_16_calc[2:0]                   = {3{1'b0}};
        check_16_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_32_calc[3:0]                   = {4{1'b0}};
        check_32_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_64_calc[4:0]                   = {5{1'b0}};
        check_64_calc[PARITY_WIDTH_MAX-1:9]  = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_128_calc[5:0]                  = {6{1'b0}};
        check_128_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_256_calc[6:0]                  = {7{1'b0}};
        check_256_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
        check_512_calc[7:0]                  = {8{1'b0}};
        check_512_calc[PARITY_WIDTH_MAX-1:9] = {(PARITY_WIDTH_MAX-9){1'b0}};
      end : check_zero_padded_8_process
    end : check_zero_padded_8_generate
  endgenerate

  // Calculate the total check bits, excluding check total (CT)
  always @(*) begin : calc_check_out_bits_process

    check_total[0] = ^check_1_calc;
    check_total[1] = ^check_2_calc;
    check_total[2] = ^check_4_calc;
    check_total[3] = ^check_8_calc;
    check_total[4] = ^check_16_calc;
    check_total[5] = ^check_32_calc;
    check_total[6] = ^check_64_calc;
    check_total[7] = ^check_128_calc;
    check_total[8] = ^check_256_calc;
    check_total[9] = ^check_512_calc;

  end : calc_check_out_bits_process

  // Generate the check total (CT) bit
  //
  // The total check bit is the XOR of every data bit, and
  // every parity bit.  Since this will take the longest time
  // to calculate, it's in its own process (sensitive to changes
  // on parity_in and data_in_zero_padded).

  always @(*) begin : gen_ct

    // XOR every true data bit and every true parity bit to create check total bit
    ct_check_bit = (^parity_in) ^ (^data_in_zero_padded[DATA_WIDTH-1:0]);

  end : gen_ct

  // Assign the check bits to the check_out_output bus
  //
  // Now assign the total check bits, including CT, to
  // the correct check_out bits.  This is dependant upon
  // how many check bits are required (as CT always takes
  // the last bit position), therefore separate generate
  // statements are required.

  always @(*) begin : check_out_assignment_process

    check_out_output[ECC_PARITY_WIDTH-2:0] = check_total[ECC_PARITY_WIDTH-2:0];
    check_out_output[ECC_PARITY_WIDTH-1]   = ct_check_bit;

  end : check_out_assignment_process

  // Determine if the check bits (excluding CT) are all zeros.
  always @(*) begin : check_bits_all_zero_process

    // If all the check bits are '0', check_bits_all_zero = '0',
    // otherwise check_bits_all_zero = '1'.
    // This signal must be initialized to '0' -- default is to
    // assume there are no errors
    
    check_bits_all_zero = |check_total;

  end : check_bits_all_zero_process

  // Determine the value of the err_detect and err_multpl output
  // ports. 
  
  always @(*) begin : determine_err_conditions_process
    // err_flag_selector is a temporary signal, used to determine
    // what values to assign to err_detect and err_multpl
    // check_bits_all_zero = '0' indicates that all of the check
    // bits are 0.  This means the data word read contains
    // no error (regardless of the value of CT).
    // check_bits_all_zero = '1' indicates that at least one check
    // bit is zero.  In this case, if CT = 1, there is a single
    // bit error (or odd number of bit errors).  Data correction
    // should take place.  If CT = 0, there is a double-bit (or
    // even multiple of bit errors), and no error correction should
    // take place.
    // if ecc_bypass is active ('1') err_detect and err_multpl output
    // should report error ("11").
    // err_flag_selector(2) = check_bits_all_zero
    // err_flag_selector(1) = ct_check_bit
    // err_flag_selector(0) = ecc_bypass
    logic [ECC_FLAG_WIDTH-1:0] err_flag_selector;

    err_flag_selector = {check_bits_all_zero,ct_check_bit,ecc_bypass};
    case(err_flag_selector)
    3'b 100 : begin
      // double-bit error
      err_multpl_output = 1'b 1;
      err_detect_output = 1'b 1;
    end
    3'b 110 : begin
      // single-bit error
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 1;
    end
    3'b 000 : begin
      // check bits are all zero's (no errors)
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 0;
    end
    3'b 010 : begin
      // check bits are all zero's, check total is 1
      // odd number of error
      err_multpl_output = 1'b 0;
      err_detect_output = 1'b 1;
    end
    default : begin
      // Unknown input or ecc_bypass, generate a double bit error
      err_multpl_output = 1'b 1;
      err_detect_output = 1'b 1;
    end
    endcase
  end : determine_err_conditions_process

  // Fix the input data, if there is an error. 
  // Assemble a temporary bus, with data_in and parity_in
  // bits.  This bus is required to fix bit errors.
  //
  // Note (superceded): The PT bit is not included in this bus; we
  //       don't need it to fix any single-bit errors.
  // NEW Note2: The PT bit is now included! It is needed for SFM team to output 
  //       corrected parity bits on ECC read side
  
  always @(*) begin : assemble_bus_1_process
    data_plus_parity[0] = parity_in[0]; // P1
    data_plus_parity[1] = parity_in[1]; // P2
    data_plus_parity[2] = data_in_zero_padded[0]; // D0
  end : assemble_bus_1_process

  generate 
    if (DATA_WIDTH >= 2) begin : assemble_bus_2_generate
      always @(*) begin : assemble_bus_2_process
        data_plus_parity[3]   = parity_in[2]; // P4
        data_plus_parity[6:4] = data_in_zero_padded[3:1]; // D3-D1
      end : assemble_bus_2_process
    end : assemble_bus_2_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 5) begin : assemble_bus_3_generate
      always @(*) begin : assemble_bus_3_process
        data_plus_parity[7] = parity_in[3]; // P8
        data_plus_parity[14:8] = data_in_zero_padded[10:4]; // D10-D4
      end : assemble_bus_3_process
    end : assemble_bus_3_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 12) begin : assemble_bus_4_generate
      always @(*) begin : assemble_bus_4_process
        data_plus_parity[15] = parity_in[4]; // P16
        data_plus_parity[30:16] = data_in_zero_padded[25:11]; // D25-D11
      end : assemble_bus_4_process
    end : assemble_bus_4_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 27) begin : assemble_bus_5_generate
      always @(*) begin : assemble_bus_5_process
        data_plus_parity[31] = parity_in[5]; // P32
        data_plus_parity[62:32] = data_in_zero_padded[56:26]; // D56-D26
      end : assemble_bus_5_process
    end : assemble_bus_5_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 58) begin : assemble_bus_6_generate
      always @(*) begin  : assemble_bus_6_process
        data_plus_parity[63] = parity_in[6]; // P64
        data_plus_parity[126:64] = data_in_zero_padded[119:57]; // D119-D57
      end : assemble_bus_6_process
    end : assemble_bus_6_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 121) begin : assemble_bus_7_generate
      always @(*) begin : assemble_bus_7_process
        data_plus_parity[127] = parity_in[7]; // P128
        data_plus_parity[254:128] = data_in_zero_padded[246:120]; // D246-D120
      end : assemble_bus_7_process
    end : assemble_bus_7_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 248) begin : assemble_bus_8_generate
      always @(*) begin : assemble_bus_8_process
        data_plus_parity[255] = parity_in[8]; // P256
        data_plus_parity[510:256] = data_in_zero_padded[501:247]; // D247-D501
      end : assemble_bus_8_process
    end : assemble_bus_8_generate
  endgenerate

  generate 
    if (DATA_WIDTH >= 503) begin : assemble_bus_9_generate
      always @(*) begin : assemble_bus_9_process
        data_plus_parity[511] = parity_in[9]; // P512
        data_plus_parity[1022:512] = data_in_zero_padded[1012:502]; // D-D
      end : assemble_bus_9_process
    end : assemble_bus_9_generate
  endgenerate

  always @(*) begin : assemble_bus_pt_process
    data_plus_parity[MAX_TEMP_WIDTH-1] = parity_in[ECC_PARITY_WIDTH-1]; // PT
    //   data_plus_parity(MAX_TEMP_WIDTH-1) = '0'; -- PT
  end : assemble_bus_pt_process

  // Generate the bit address index into the data_plus_parity bus
  miv_rv32_bist_decode 
    #(
      .CHECK_TOTAL_WIDTH(CHECK_TOTAL_WIDTH),
      .MAX_ADDR_WIDTH(MAX_TEMP_WIDTH),
      .ECC_PARITY_WIDTH(ECC_PARITY_WIDTH)
    )
    addr_dec
    (
      .addr_in(check_total),
      .addr_out(addr_index)
    );

  // The address bus returned references the first bit position
  // as position '0'.  The ECC block uses bit position '1'.
  // The address index bus must be shifted left by 1 bit.
  
  always @(*) begin : left_shift_addr_index_process
    addr_index0_and_ct = addr_index[0] & ct_check_bit;
    //   addr_index_corrected( MAX_TEMP_WIDTH-1 DOWNTO 0 ) = 
    //     '0' & addr_index( MAX_TEMP_WIDTH-1 DOWNTO 1);
    addr_index_corrected[MAX_TEMP_WIDTH - 1:0] = 
      {addr_index0_and_ct,addr_index[MAX_TEMP_WIDTH - 1:1]};
  end : left_shift_addr_index_process

  // Correct the bit error
  always @(*) begin : data_in_correction_process
    for (int i = 0; i < MAX_TEMP_WIDTH; i++) begin : data_in_correction_loop 
        data_plus_parity_corrected[i] = data_plus_parity[i] ^ addr_index_corrected[i];
    end : data_in_correction_loop
  end : data_in_correction_process

  // Dis-assemble the temporary corrected data bus.
  //
  // When re-creating the corrected output data bus,
  // need to filter out the parity bit locations (as
  // the parity bits were included in the originally
  // created temporary data bus).
  
  generate 
    if (ECC_PARITY_WIDTH == 3) begin : data_out_1_generate
      always @(*) begin : data_out_1_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH-1)];
      end : data_out_1_process
    end : data_out_1_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 4) begin : data_out_2_generate
      always @(*) begin : data_out_2_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3), and offset by 3 for P1,
        // P2, and P4
        data_out_corrected[DATA_WIDTH - 1:1] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 3:4];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_2_process
    end : data_out_2_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 5) begin : data_out_3_generate
      always @(*) begin : data_out_3_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0) 
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7), and offset by 4 for P1, P2,
        // P4, and P8
        data_out_corrected[DATA_WIDTH - 1:4] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 4:8];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_3_process
    end : data_out_3_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 6) begin : data_out_4_generate
      always @(*) begin : data_out_4_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15), and offset by 5 for P1,
        // P2, P4, P8, and P16
        data_out_corrected[DATA_WIDTH - 1:11] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 5:16];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_4_process
    end : data_out_4_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 7) begin : data_out_5_generate
      always @(*) begin : data_out_5_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31), and offset by 6 for P1,
        // P2, P4, P8, P16, and P32
        data_out_corrected[DATA_WIDTH - 1:26] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 6:32];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_5_process
    end : data_out_5_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 8) begin : data_out_6_generate
      always @(*) begin : data_out_6_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63), and offset by 7 for P1,
        // P2, P4, P8, P16, P32, and P64
        data_out_corrected[DATA_WIDTH - 1:57] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 7:64];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_6_process
    end : data_out_6_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 9) begin : data_out_7_generate
      always @(*) begin : data_out_7_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P64 (skip data_plus_parity_corrected(127), and offset by 8 for P1,
        // P2, P4, P8, P16, P32, P64, and P128
        data_out_corrected[DATA_WIDTH - 1:120] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 8:128];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_7_process
    end : data_out_7_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 10) begin : data_out_8_generate
      always @(*) begin : data_out_8_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P128 (skip data_plus_parity_corrected(127)
        data_out_corrected[246:120] = data_plus_parity_corrected[254:128];

        // Filter out P256 (skip data_plus_parity_corrected(255), and offset by 9 for P1,
        // P2, P4, P8, P16, P32, P64, P128, and P256
        data_out_corrected[DATA_WIDTH - 1:247] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 9:256];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include P256
        parity_out_corrected[8] = data_plus_parity_corrected[255];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_8_process
    end : data_out_8_generate
  endgenerate

  generate 
    if (ECC_PARITY_WIDTH == 11) begin : data_out_9_generate
      always @(*) begin : data_out_9_process
        // Filter out P1 and P2 (skip data_plus_parity_corrected(1 DOWNTO 0)
        data_out_corrected[0] = data_plus_parity_corrected[2];

        // Filter out P4 (skip data_plus_parity_corrected(3)
        data_out_corrected[3:1] = data_plus_parity_corrected[6:4];

        // Filter out P8 (skip data_plus_parity_corrected(7)
        data_out_corrected[10:4] = data_plus_parity_corrected[14:8];

        // Filter out P16 (skip data_plus_parity_corrected(15)
        data_out_corrected[25:11] = data_plus_parity_corrected[30:16];

        // Filter out P32 (skip data_plus_parity_corrected(31)
        data_out_corrected[56:26] = data_plus_parity_corrected[62:32];

        // Filter out P64 (skip data_plus_parity_corrected(63)
        data_out_corrected[119:57] = data_plus_parity_corrected[126:64];

        // Filter out P128 (skip data_plus_parity_corrected(127)
        data_out_corrected[246:120] = data_plus_parity_corrected[254:128];

        // Filter out P256 (skip data_plus_parity_corrected(255)
        data_out_corrected[501:247] = data_plus_parity_corrected[510:256];

        // Filter out P512 (skip data_plus_parity_corrected(511), and offset by 10 for P1,
        // P2, P4, P8, P16, P32, P64, P128, P256, and P512
        data_out_corrected[DATA_WIDTH - 1:502] = 
          data_plus_parity_corrected[((DATA_WIDTH - 1)) + 10:512];

        // Include P1 and P2
        parity_out_corrected[1:0] = data_plus_parity_corrected[1:0];
        // Include P4
        parity_out_corrected[2] = data_plus_parity_corrected[3];
        // Include P8
        parity_out_corrected[3] = data_plus_parity_corrected[7];
        // Include P16
        parity_out_corrected[4] = data_plus_parity_corrected[15];
        // Include P32
        parity_out_corrected[5] = data_plus_parity_corrected[31];
        // Include P64
        parity_out_corrected[6] = data_plus_parity_corrected[63];
        // Include P128
        parity_out_corrected[7] = data_plus_parity_corrected[127];
        // Include P256
        parity_out_corrected[8] = data_plus_parity_corrected[255];
        // Include P512
        parity_out_corrected[9] = data_plus_parity_corrected[511];
        // Include PT
        parity_out_corrected[(ECC_PARITY_WIDTH - 1)] = 
          data_plus_parity_corrected[(MAX_TEMP_WIDTH - 1)];
      end : data_out_9_process
    end : data_out_9_generate
  endgenerate

  // Assign either data_out_corrected or data_in to data_out, based on
  // the value of ecc_bypass
  
  always @(*) begin : data_out_assignment_process
    if(ecc_bypass == 1'b 1) begin
      data_out_output             = data_in;
      parity_out_corrected_output = parity_in;
    end
    else begin
      data_out_output             = data_out_corrected;
      parity_out_corrected_output = parity_out_corrected;
    end
  end : data_out_assignment_process

  // pragma translate_off
  always @(ecc_bypass) begin
    assert(ecc_bypass != 1'b1) 
    else begin
      $display( "ECC is bypassed. This mode is used for device test only.");
      $warning;
    end
  end
  // pragma translate_on
  
  // Finished the parity bit generator logic.
  
endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Function:
// ECC write side module
//
// Parameter Description:
// DATA_WIDTH        The width of the data bus.
// ECC_PARITY_WIDTH  The width of the parity bit bus.
//                   The value of parity_width is dependant upon 
//                   DATA_WIDTH. 
//                   The table below shows the value of parity_width, 
//                   based on the value of DATA_WIDTH:
//                   DATA_WIDTH         parity_width
//                   ===============================
//                       1                   3
//                      2-4                  4
//                      5-11                 5
//                     12-26                 6
//                     27-57                 7
//                     58-120                8
//                    121-247                9
//                    248-502               10
//                    503-1013              11 
//
// Input Port Descriptions:
// ecc_bypass                Allows the ECC correction circuitry to 
//                           be bypassed (active high signal).
// data_in [DATA_WIDTH]      Data word being written to or read from 
//                           memory.
// parity_in [parity_width]  Input for parity bits when performing a
//                           memory read.
//
// Output Port Descriptions:
// parity_out [parity_width]  During a memory write, outputs the
//                            parity bits for that word.  During a
//                            memory read, outputs the corrected parity bits
// check_out [parity_width]   During a memory read, outputs the
//                            check (syndrome) bits.  During a
//                            memory write, outputs all 0's.
// data_out [DATA_WIDTH]      During a memory read, contains either
//                            the corrected or original data.
//                            During a memory write, contains
//                            all 0's.
// err_detect                 Indicates that an error has been
//                            detected.
// err_multpl                 Indicates whether there was an even
//                            number of bit errors
//                            (err_multpl = '1').  If there were no
//                            errors, or an odd number of errors,
//                            err_multpl = '0'.

`default_nettype none

module miv_rv32_bist_ecc_write
  #(
    parameter DATA_WIDTH       = 8,
    parameter ECC_PARITY_WIDTH = 5,
    parameter PARITY_WIDTH_MAX = 11,
    parameter MAX_DATA_WIDTH   = 1013
  )
  (
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_1_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_2_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_4_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_8_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_16_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_32_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_64_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_128_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_256_calc,
    input  wire logic [PARITY_WIDTH_MAX-1:0] parity_512_calc,
    input  wire logic [MAX_DATA_WIDTH-1:0]   data_in_zero_padded,
    output      logic [ECC_PARITY_WIDTH-1:0] parity_out_output
  );

localparam    PARITY_TOTAL_WIDTH = PARITY_WIDTH_MAX-1;

logic [PARITY_TOTAL_WIDTH-1:0] parity_total;
logic                          pt_parity_bit;

// Start the RTL code:

  // Final Parity Bit Calculations (Excluding the PT parity bit)
  // Now generate the output parity bits, excluding the parity
  // total (PT) bit.  The PT bit must be calculated in a
  // separate process, sensitive to the individual parity bit
  // totals.
  // All the output parity bits will be the same, regardless
  // of how many parity bits are required for the RAM word
  // being written.
  always @(*) begin : calc_parity_output_bits_process

    parity_total[0] = ^parity_1_calc;
    parity_total[1] = ^parity_2_calc;
    parity_total[2] = ^parity_4_calc;
    parity_total[3] = ^parity_8_calc;
    parity_total[4] = ^parity_16_calc;
    parity_total[5] = ^parity_32_calc;
    parity_total[6] = ^parity_64_calc;
    parity_total[7] = ^parity_128_calc;
    parity_total[8] = ^parity_256_calc;
    parity_total[9] = ^parity_512_calc;
    
  end : calc_parity_output_bits_process

  // PT (Parity Total) bit calculation
  //
  // Now generate the total parity (PT) bit.  This calculation
  // requires a process that is sensitive to the individual
  // parity bit totals, as well as the data_in_zero_padded vector.

  always @(*) begin : calc_parity_total_bit_process
    // PT is the XOR of ALL parity bits (parity_total[X]),
    // as well as ALL the true data bits
    // (data_in_zero_padded[DATA_WIDTH-1 DOWNTO 0])
    //
    // XOR all the parity total bits

    pt_parity_bit = (^data_in_zero_padded[DATA_WIDTH-1:0]) ^ (^parity_total);

  end : calc_parity_total_bit_process

  // Assign the parity bits to the parity_out_output signal bus
  //
  // Now assign the total parity bits, including PT, to
  // the correct parity_out bits.  This is dependant upon
  // how many parity bits are required (as PT always takes
  // the last bit position).  For this reason, separate generate
  // statements are required.
  
  always @(*) begin : parity_out_assignment_process
    for (int i = 0; i < ECC_PARITY_WIDTH-1; i++) begin
      parity_out_output[i] = parity_total[i];
    end
    parity_out_output[ECC_PARITY_WIDTH-1] = pt_parity_bit;
  end : parity_out_assignment_process

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// FUNCTION:
// inject error in sys data.
// 1) err_inject = "00"
//     no error is injected
// 2) err_inject = "01"
//     one bit error is injected on bit 0
// 3) err_inject = "10"
//     one bit error is injected on bit 1
// 4) err_inject = "11"
//     two bits error is injected on bit 1 and 0 
// GENERIC PORT DESCRIPTION:
// DATA_WIDTH     RAM data width
// INPUT PORT DESCRIPTION:
// err_inject     error injection bus
// data_in        data input
// OUTPUT PORT DESCRIPTION:
// data_out       data output
// CONNECTIVITY DEFINITION

`default_nettype none

module miv_rv32_bist_err_inject
  #(
    parameter ERR_WIDTH  = 2,
    parameter DATA_WIDTH = 8
  )
  (
    input  wire logic [ERR_WIDTH-1:0]  err_inject,
    input  wire logic [DATA_WIDTH-1:0] data_in,
    output      logic [DATA_WIDTH-1:0] data_out
  );

// IMPLEMENTATION

  always @(*) begin : data_err
    logic [ERR_WIDTH-1:0] data_out_val;

    for (int i=0; i <= ERR_WIDTH - 1; i++) begin 
      if(err_inject[i] != 1'b 1) begin
        data_out_val[i] = data_in[i];
      end
      else begin
        data_out_val[i] =  ~data_in[i];
      end
    end
    data_out[ERR_WIDTH-1:0] = data_out_val;
  end : data_err

  generate 
    if (DATA_WIDTH > ERR_WIDTH) begin : no_data_err
      assign data_out[DATA_WIDTH - 1:ERR_WIDTH] = data_in[DATA_WIDTH - 1:ERR_WIDTH];
    end : no_data_err
  endgenerate

  // pragma translate_off
  always @(err_inject) begin
    assert(|err_inject != 1'b1)
    else begin
      $display("RAM Err Injection is activated");
      $info;
    end
  end
  // pragma translate_on
// END OF CODE

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// Contains pipeline flip flops if needed, otherwise data bus passes through
// module
//
//
// PARAMETER DESCRIPTION:
//
// DATA_WIDTH             number of data bits per word
// DATA_INIT              FF reset value
// DATA_PIPELINE          use pipelining or not
//
//
// INPUT PORT DESCRIPTION:
//
// din                    RAM read data
// clk                    RAM clock
// rstb                   system reset (active low)
// enable                 RAM enable
//
//
// OUTPUT PORT DESCRIPTION:
//
// dout                   RAM data to ECC wrapper
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_bist_pipeline

  #(
    parameter DATA_WIDTH      = 8,
    parameter DATA_INIT       = 0,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline DATA_PIPELINE 
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF
  )
  (
    input  wire logic                  clk,
    input  wire logic                  rstb,
    input  wire logic                  enable,    
    input  wire logic [DATA_WIDTH-1:0] din,
    
    output      logic [DATA_WIDTH-1:0] dout
  );
  
  import miv_rv32_bist_shared_pkg::*;
  
  generate   
    case ( DATA_PIPELINE ) 
      BIST_PIPELINE_ON : 
 
        begin : gen_pipeline
          always_ff @(posedge clk or negedge rstb)
          begin : pipeline_ff
            if ( rstb != 1'b1 ) begin
              if ( DATA_INIT == 0 ) begin
                dout <= {DATA_WIDTH{1'b0}};
              end
              else begin
                dout <= {DATA_WIDTH{1'b1}};
              end
            end
            else begin
              if ( enable == 1'b1 ) begin
                dout <= din;
              end
            end
          end : pipeline_ff
        end : gen_pipeline
      
      BIST_PIPELINE_OFF :
 
        begin : no_pipeline
          assign dout = din;
        end : no_pipeline

    endcase    
  endgenerate

endmodule : miv_rv32_bist_pipeline

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// RAM and BIST bist_template which can be used to drop in and replace a RAM
// instance.
//
// PARAMETER DESCRIPTION:
//
// RAM_DEPTH           Number of words in the RAM (<= 2^ADDR_WIDTH) 
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops (ls)
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops (ds and sd)
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
// BWE_RAM             Indicates if this is bwe ram
// RAM_INIT_GEN        Indicates if ram init is generated
//
// INPUT PORT DESCRIPTION:
//
// rstb                System reset (active low). 
// clk                 RAM clock.
// lp1                 Light sleep mode input
// lp2                 Deep sleep mode input
// lp3                 Shut down mode input
// addr[]              RAM read/write address.
// ceb                 RAM cell enable (active low).
// web                 RAM write enable (active low).
// wemb[]              RAM write enable mask (active low).
// din[]               RAM write data. 
// ram_dout            Data output from ram
// pg_override         Override low power mode
// ram_init_enable     Enable for RAM initialization
//
// OUTPUT PORT DESCRIPTION:
//
// dout[]              RAM read data.
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM
// ram_din[]           Data input to RAM
// ram_init_busy       RAM initialization busy signal

`default_nettype none

module miv_rv32_bist_template_dual_behav
  #(
    parameter RAM_DEPTH       = 16,
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter BIST_ADDR_WIDTH = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS     = 1,
    parameter NUM_LP2_PINS     = 1,
    parameter NUM_LP3_PINS     = 1,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false BWE_RAM
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_bist_shared_pkg::BIST_TRUE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_INIT_GEN
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF

  )
  (
    input  wire logic                       arstb,
    input  wire logic                       aclk,
    input  wire logic                       brstb,
    input  wire logic                       bclk,
    // user ram interface
    input  wire logic [ADDR_WIDTH-1:0]      aaddr,
    input  wire logic                       aceb,
    input  wire logic                       aweb,
    input  wire logic [DATA_WIDTH-1:0]      awemb,
    input  wire logic [DATA_WIDTH-1:0]      adin,
    output      logic [DATA_WIDTH-1:0]      adout,
    input  wire logic [ADDR_WIDTH-1:0]      baddr,
    input  wire logic                       bceb,
    input  wire logic                       bweb,
    input  wire logic [DATA_WIDTH-1:0]      bwemb,
    input  wire logic [DATA_WIDTH-1:0]      bdin,
    output      logic [DATA_WIDTH-1:0]      bdout,
    // internal ram interfac
    output      logic                       ram_aceb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic                       ram_aweb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
    output      logic [DATA_WIDTH-1:0]      ram_adin,
    input  wire logic [DATA_WIDTH-1:0]      ram_adout,
    output      logic                       ram_bceb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic                       ram_bweb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
    output      logic [DATA_WIDTH-1:0]      ram_bdin,
    input  wire logic [DATA_WIDTH-1:0]      ram_bdout,
    // low power interface
    input  wire logic                       pg_clk,
    input  wire logic                       pg_rstb,
    input  wire logic                       pg_override,
    input  wire logic [NUM_LP1_PINS-1:0]     lp1,
    input  wire logic [NUM_LP2_PINS-1:0]     lp2,
    input  wire logic [NUM_LP3_PINS-1:0]     lp3,
    output      logic [LOW_POWER_WIDTH-1:0] low_power,
    // ram init interface
    input  wire logic                       ram_init_enable,
    output      logic                       ram_init_busy_a,
    output      logic                       ram_init_busy_b
  );

  import miv_rv32_bist_shared_pkg::*;

  // LOCAL PARAMETER
  localparam logic           POWR = 1'b1;
  localparam t_bist_pipeline BWE_PIPELINE = 
                           (BWE_RAM == BIST_TRUE && INPUT_PIPELINE == BIST_PIPELINE_ON) ? 
                           BIST_PIPELINE_ON : BIST_PIPELINE_OFF;

  // INTERNAL SIGNALS
  logic                   ram_init_clear_q;
  logic [ADDR_WIDTH-1:0]  ram_init_aaddr;
  logic                   ram_init_start_b;
  logic [DATA_WIDTH-1:0]  sys_adin;
  logic [DATA_WIDTH-1:0]  sys_adout;
  logic [ADDR_WIDTH-1:0]  sys_aaddr;
  logic                   sys_aceb;
  logic                   sys_aweb;
  logic [DATA_WIDTH-1:0]  sys_awemb;
  logic [DATA_WIDTH-1:0]  sys_bdin;
  logic [DATA_WIDTH-1:0]  sys_bdout;
  logic [ADDR_WIDTH-1:0]  sys_baddr;
  logic                   sys_bceb;
  logic                   sys_bweb;
  logic [DATA_WIDTH-1:0]  sys_bwemb;
  logic [NUM_LP1_PINS-1:0] sys_lp1;
  logic [NUM_LP2_PINS-1:0] sys_lp2;
  logic [NUM_LP3_PINS-1:0] sys_lp3;
  logic                   a_input_pl_data_enable;
  logic                   a_input_pl_ctrl_enable;
  logic                   a_output_pl_data_enable;
  logic                   b_input_pl_data_enable;
  logic                   b_input_pl_ctrl_enable;
  logic                   b_output_pl_data_enable;
  logic                   input_pl_pg_enable;
  logic                   sys_aceb_fpga;
  logic                   sys_bceb_fpga;
  logic [DATA_WIDTH-1:0]  sys_adout_fpga;
  logic [DATA_WIDTH-1:0]  sys_bdout_fpga;
  logic                   sys_awemb_and;
  logic                   sys_bwemb_and;

  assign sys_awemb_and = &sys_awemb;
  assign sys_bwemb_and = &sys_bwemb;

  // Pipeline enable logic
  miv_rv32_bistdual_pl_enable
    #(
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    pl_enable_inst
    (
      .arstb,
      .aclk,
      .aceb,
      .aweb,
      .a_input_pl_data_enable,
      .a_input_pl_ctrl_enable,
      .a_output_pl_data_enable,
      .brstb,
      .bclk,
      .bceb,
      .bweb,
      .b_input_pl_data_enable,
      .b_input_pl_ctrl_enable,
      .b_output_pl_data_enable,
      .input_pl_pg_enable
     );

  // RAM Control wrapper
  miv_rv32_bistdual_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .RTL_MUX(RTL_MUX),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS)
    )
    ctrl_inst
    (
      .ram_init_busy_a,
      .ram_init_busy_b,
      .ram_init_start_b,
      .ram_init_clear_q,
      .ram_init_aaddr,
      .sys_aceb(sys_aceb_fpga),
      .sys_aweb,
      .sys_awemb,
      .sys_aaddr,
      .ram_aceb,
      .ram_aweb,
      .ram_awemb,
      .ram_aaddr,
      .sys_bceb(sys_bceb_fpga),
      .sys_bweb,
      .sys_bwemb,
      .sys_baddr,
      .ram_bceb,
      .ram_bweb,
      .ram_bwemb,
      .ram_baddr,
      .sys_lp1,
      .sys_lp2,
      .sys_lp3,
      .pg_override,
      .low_power
    );

  // RAM Data Analyzer
  miv_rv32_bistdualdata_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .RTL_MUX(RTL_MUX)
    )
    check_inst
    (
      .ram_init_busy_a,
      .sys_adin,
      .sys_adout,
      .ram_adin,
      .ram_adout,
      .ram_init_busy_b,
      .sys_bdin,
      .sys_bdout,
      .ram_bdin,
      .ram_bdout
    );

  // RAM initialization block
  miv_rv32_bistdual_ram_init 
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .RAM_DEPTH(RAM_DEPTH),
      .ADDR_WIDTH(ADDR_WIDTH)
    )
    ram_init_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .brstb(brstb),
      .bclk(bclk),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ram_init_start_b(ram_init_start_b),
      .ram_init_clear_q(ram_init_clear_q),
      .ram_init_aaddr(ram_init_aaddr)
    );

  // FPGA compaticle logic
  miv_rv32_bistdual_ram_stabilizer 
    #(
      .RAM_STABILIZER(RAM_STABILIZER),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH)
    )
    ram_stabilizer_enable_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(sys_aaddr),
      .aceb_in(sys_aceb),
      .aceb_out(sys_aceb_fpga),
      .aweb(sys_aweb),
      .awemb_and(sys_awemb_and),
      .adin(sys_adin),
      .adout_in(sys_adout),
      .adout_out(sys_adout_fpga),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(sys_baddr),
      .bceb_in(sys_bceb),
      .bceb_out(sys_bceb_fpga),
      .bweb(sys_bweb),
      .bwemb_and(sys_bwemb_and),
      .bdin(sys_bdin),
      .bdout_in(sys_bdout),
      .bdout_out(sys_bdout_fpga)
    );

  // INPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aceb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(POWR),
      .din(aceb),
      .dout(sys_aceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    awemb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(awemb),
      .dout(sys_awemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aweb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aweb),
      .dout(sys_aweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE))
    aaddr_pipeline_inst(
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aaddr),
      .dout(sys_aaddr));

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    adin_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_data_enable),
      .din(adin),
      .dout(sys_adin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bceb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(POWR),
      .din(bceb),
      .dout(sys_bceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    bwemb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bwemb),
      .dout(sys_bwemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bweb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bweb),
      .dout(sys_bweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    baddr_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(baddr),
      .dout(sys_baddr)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bdin_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_data_enable),
      .din(bdin),
      .dout(sys_bdin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP1_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LS)
    )
    lp1_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp1),
      .dout(sys_lp1)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP2_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp2_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp2),
      .dout(sys_lp2)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP3_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp3_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp3),
      .dout(sys_lp3)
    );

  // OUTPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    adout_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_output_pl_data_enable),
      .din(sys_adout_fpga),
      .dout(adout)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    bdout_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_output_pl_data_enable),
      .din(sys_bdout_fpga),
      .dout(bdout)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

module miv_rv32_ram_dport_reg(data0,data1,waddr0, waddr1,we0,we1,clk,q0,q1);
    parameter d_width = 32;
    parameter addr_width = 32;
    parameter mem_depth = 65536;

    input [d_width-1:0] data0, data1;
    input [addr_width-1:0] waddr0, waddr1;
    input we0, we1, clk;

    output [d_width-1:0] q0;
    output [d_width-1:0] q1;

    reg [d_width-1:0] mem [mem_depth:0];
    reg [addr_width-1:0] reg_waddr0, reg_waddr1;

    wire [d_width-1:0] q0, q1;

    assign q0 = mem[reg_waddr0];
    assign q1 = mem[reg_waddr1];

    always @(posedge clk) begin 
        if (we0)
            mem[waddr0] <= data0;
        if (we1) 
            mem[waddr1] <= data1;
        reg_waddr0 <= waddr0;
        reg_waddr1 <= waddr1;
    end 
endmodule

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none

module miv_rv32_dpr_hqa_dual_storage_bistw_behav
  #(
    parameter DATA_WIDTH       = 16,
    parameter ADDR_WIDTH       = 4,
    parameter RAM_DEPTH        = 65536
  )
  (
    input  wire logic                  ecc_bypass,
    input  wire logic [2-1:0]          ram_err_inject,
    output      logic [2-1:0]          ecc_aerr,
    output      logic [2-1:0]          ecc_berr,
    output      logic [2-1:0]          ecc_aerr_int,
    output      logic [2-1:0]          ecc_berr_int,

    input  wire logic                  pg_override,
    input  wire logic                  lp1,


    input  wire logic [DATA_WIDTH-1:0] adin,
    input  wire logic [DATA_WIDTH-1:0] bdin,
    output      logic [DATA_WIDTH-1:0] adout,
    output      logic [DATA_WIDTH-1:0] bdout,
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aceb,
    input  wire logic                  aweb,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bceb,
    input  wire logic                  bweb
  );

  // IMPLEMENTATION 

  import miv_rv32_bist_shared_pkg::*;

  localparam PARITY_WIDTH      = parity_num(DATA_WIDTH);
  localparam logic             GRND              = 1'b0;
  localparam                   BISTW_WIDTH       = PARITY_WIDTH + DATA_WIDTH;
  localparam                   LOW_POWER_WIDTH   = 4;
  localparam                   NUM_LP1_PINS      = 1;
  localparam                   NUM_LP2_PINS      = 1;
  localparam                   NUM_LP3_PINS      = 1;
  localparam t_bist_true_false LP1_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP2_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP3_ACTIVE_LOW    = BIST_FALSE;
  localparam t_bist_true_false FUNC_CLKS_SYNC    = BIST_TRUE;
  localparam t_bist_true_false RAM_STABILIZER    = BIST_FALSE;
  localparam t_bist_true_false BWE_RAM           = BIST_FALSE;
  localparam t_bist_true_false RAM_INIT_GEN      = BIST_FALSE;
  localparam t_bist_true_false RTL_MUX           = BIST_TRUE;
  localparam t_bist_pipeline   INPUT_PIPELINE    = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LS = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LP = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   OUTPUT_PIPELINE   = BIST_PIPELINE_OFF;

  logic [BISTW_WIDTH-1:0]     bistw_adin_all;
  logic [BISTW_WIDTH-1:0]     bistw_adout_all;
  logic [BISTW_WIDTH-1:0]     bistw_awemb;
  logic [BISTW_WIDTH-1:0]     bistw_bdin_all;
  logic [BISTW_WIDTH-1:0]     bistw_bdout_all;
  logic [BISTW_WIDTH-1:0]     bistw_bwemb;
  logic [ADDR_WIDTH-1:0]      ram_aaddr;
  logic                       ram_aceb;
  logic [BISTW_WIDTH-1:0]     ram_awemb;
  logic                       ram_aweb;
  logic [BISTW_WIDTH-1:0]     ram_adin;
  logic [BISTW_WIDTH-1:0]     ram_adout;
  logic [ADDR_WIDTH-1:0]      ram_baddr;
  logic                       ram_bceb;
  logic [BISTW_WIDTH-1:0]     ram_bwemb;
  logic                       ram_bweb;
  logic [BISTW_WIDTH-1:0]     ram_bdin;
  logic [BISTW_WIDTH-1:0]     ram_bdout;
  logic [LOW_POWER_WIDTH-1:0] low_power;
  logic                 lp2;
  logic                 lp3;
  logic                 ram_init_enable;
  logic                 ram_init_busy_a;
  logic                 ram_init_busy_b;
  logic                 pg_rstb;
  logic                 pg_clk;
  logic                 awemb_and;
  logic                 bwemb_and;
  logic                 bist_ramscanb;
  logic                 bistb;
  logic [PARITY_WIDTH-1:0] bistw_apin;
  logic [PARITY_WIDTH-1:0] bistw_bpin;
  logic [DATA_WIDTH-1:0] bistw_adin;
  logic [DATA_WIDTH-1:0] bistw_bdin;
  logic [PARITY_WIDTH-1:0] bistw_apout;
  logic [PARITY_WIDTH-1:0] bistw_bpout;
  logic [DATA_WIDTH-1:0] bistw_adout;
  logic [DATA_WIDTH-1:0] bistw_bdout;

  assign ram_init_enable = 1'b0;
  assign pg_rstb         = 1'b0;
  assign pg_clk          = 1'b0;
  assign bist_ramscanb   = 1'b1;
  assign bistb           = 1'b1;
  assign awemb_and       = 1'b0;
  assign bwemb_and       = 1'b0;
  assign bistw_awemb     = {BISTW_WIDTH{1'b0}};
  assign bistw_bwemb     = {BISTW_WIDTH{1'b0}};
  assign lp2             = 1'b0;
  assign lp3             = 1'b0;
  assign bistw_adin_all  = {bistw_apin, bistw_adin};
  assign bistw_bdin_all  = {bistw_bpin, bistw_bdin};
  assign {bistw_apout, bistw_adout} = bistw_adout_all;
  assign {bistw_bpout, bistw_bdout} = bistw_bdout_all;

  // ECC wrapper
  miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(aweb),
      .awemb_and(awemb_and),
      .sys_adin(adin),
      .bistw_adout(bistw_adout),
      .bistw_apout(bistw_apout),
      .sys_adout(adout),
      .bistw_adin(bistw_adin),
      .bistw_apin(bistw_apin),
      .ecc_aerr(ecc_aerr),
      .ecc_aerr_int(ecc_aerr_int),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(bweb),
      .bwemb_and(bwemb_and),
      .sys_bdin(bdin),
      .bistw_bdout(bistw_bdout),
      .bistw_bpout(bistw_bpout),
      .sys_bdout(bdout),
      .bistw_bdin(bistw_bdin),
      .bistw_bpin(bistw_bpin),
      .ecc_berr(ecc_berr),
      .ecc_berr_int(ecc_berr_int)
    );


  // RAM wrapper
  //miv_rv32_dpr_behav_ramw_arm28
    //#(
      //.DATA_WIDTH(BISTW_WIDTH),
      //.ADDR_WIDTH(ADDR_WIDTH),
      //.RAM_DEPTH(RAM_DEPTH),
      //.LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      //.NUM_LP1_PINS(NUM_LP1_PINS),
      //.NUM_LP2_PINS(NUM_LP2_PINS),
      //.NUM_LP3_PINS(NUM_LP3_PINS)
    //)
    //ram_inst
    //(
      //.aclk(aclk),
      //.aaddr(ram_aaddr),
      //.aceb(ram_aceb),
      //.aweb(ram_aweb),
      //.awemb(ram_awemb),
      //.adin(ram_adin),
      //.adout(ram_adout),
      //.bclk(bclk),
      //.baddr(ram_baddr),
      //.bceb(ram_bceb),
      //.bweb(ram_bweb),
      //.bwemb(ram_bwemb),
      //.bdin(ram_bdin),
      //.bdout(ram_bdout),
      //.low_power(low_power)
    //);


  miv_rv32_ram_dport_reg
    #(
      .d_width(BISTW_WIDTH),
      .addr_width(ADDR_WIDTH-6),
      .mem_depth(RAM_DEPTH)
    )
    ram_inst
    (
      .clk(aclk),
      .waddr0(ram_aaddr[ADDR_WIDTH-5:2]),
      .we0(ram_aweb),
      .data0(ram_adin),
      .q0(ram_adout),
      .waddr1(ram_baddr[ADDR_WIDTH-5:2]),
      .we1(ram_bweb),
      .data1(ram_bdin),
      .q1(ram_bdout)
    );



 // BIST wrapper
  miv_rv32_bist_template_dual_behav
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(aweb),
      .awemb(bistw_awemb),
      .adin(bistw_adin_all),
      .adout(bistw_adout_all),
      .ram_aaddr(ram_aaddr),
      .ram_aceb(ram_aceb),
      .ram_aweb(ram_aweb),
      .ram_awemb(ram_awemb),
      .ram_adin(ram_adin),
      .ram_adout(ram_adout),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(bweb),
      .bwemb(bistw_bwemb),
      .bdin(bistw_bdin_all),
      .bdout(bistw_bdout_all),
      .ram_baddr(ram_baddr),
      .ram_bceb(ram_bceb),
      .ram_bweb(ram_bweb),
      .ram_bwemb(ram_bwemb),
      .ram_bdin(ram_bdin),
      .ram_bdout(ram_bdout),
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(low_power),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none
`undef RAM_BIST_VIEW_BEHAV
`undef RAM_BIST_VIEW
`define RAM_BIST_VIEW_BEHAV

`ifdef RAM_BIST_VIEW_BEHAV
`define RAM_BIST_VIEW 1
`elsif RAM_BIST_VIEW_FPGA
`define RAM_BIST_VIEW 2
`elsif RAM_BIST_VIEW_DFT
`define RAM_BIST_VIEW 3
`else
`define RAM_BIST_VIEW 0
`endif

module miv_rv32_dpr_hqa_dual_storage_rbcw
  #(
    parameter RAM_DEPTH            = 65536 ,
    parameter ADDR_WIDTH           = 28   ,
    parameter DATA_WIDTH           = 32  ,
    parameter PMC_RAM_BIST_VIEW    = `RAM_BIST_VIEW
  )
  (
    input  wire logic                    arstb,
    input  wire logic                    aclk,
    input  wire logic [ADDR_WIDTH-1:0]   aaddr,
    input  wire logic                    aceb,
    input  wire logic                    aweb,
    input  wire logic                    brstb,
    input  wire logic                    bclk,
    input  wire logic [ADDR_WIDTH-1:0]   baddr,
    input  wire logic                    bceb,
    input  wire logic                    bweb,
    input  wire logic                    ret1n,
    input  wire logic                    pg_override,
    input  wire logic                    ecc_bypass,
    input  wire logic [2-1:0]            ram_err_inject,
    input  wire logic [DATA_WIDTH-1:0]   adin,
    output      logic [DATA_WIDTH-1:0]   adout,
    input  wire logic [DATA_WIDTH-1:0]   bdin,
    output      logic [DATA_WIDTH-1:0]   bdout,
    output      logic [2-1:0]            ecc_aerr,
    output      logic [2-1:0]            ecc_aerr_int,
    output      logic [2-1:0]            ecc_berr,
    output      logic [2-1:0]            ecc_berr_int
  );

  // IMPLEMENTATION
  import miv_rv32_bist_seq_pkg::*;

  typedef enum {
    ASIC  = 0,
    BEHAV = 1,
    FPGA  = 2,
    DFT   = 3
  } t_bist_view;

  logic [BISTCTL_WIDTH-1:0]  bistctl;
  logic            scanb;
  logic            bist_scanb;
  logic            bist_ramscanb;
  logic            bistrstb;
  logic            bistclk;
  logic            scan_en;
  logic            scan_en_o;
  logic            ram_iddq_en;
  logic            fll_clk;

  assign bistctl              = {1'b1,{BISTCTL_WIDTH-1{1'b0}}};
  assign scanb                = 1'b1;
  assign bist_scanb           = 1'b1;
  assign bist_ramscanb        = 1'b1;
  assign fll_clk              = 1'b1;
  assign bistrstb             = 1'b0;
  assign bistclk              = 1'b0;
  assign scan_en              = 1'b0;
  assign scan_en_o            = 1'b0;
  assign ram_iddq_en          = 1'b0;

  generate
    case (PMC_RAM_BIST_VIEW)
      ASIC :
        begin : asic_gen
          miv_rv32_dpr256x32_hqa_dual_storage_bistw
            miv_rv32_dpr256x32_hqa_dual_storage_bistw_inst
            (
              .scanb(scanb),
              .bist_scanb(bist_scanb),
              .bist_ramscanb(bist_ramscanb),
              .scan_en(scan_en),
              .scan_en_o(scan_en_o),
              .ram_iddq_en(ram_iddq_en),
              .bistrstb(bistrstb),
              .bistclk(bistclk),
              .bistctl(bistctl),
              .fll_clk(fll_clk),
              .bistackecc(),
              .bistackmult(),
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : asic_gen
      BEHAV :
        begin : behav_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_behav
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_behav_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : behav_gen
      FPGA :
        begin : fpga_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_fpga
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_fpga_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : fpga_gen
      DFT :
        begin : dft_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_dft
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_dft_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(aweb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(bweb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(adin),
              .adout(adout),
              .bdin(bdin),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : dft_gen
      default :
        begin : default_gen
          // Instantiates non-existing module to fail elaboration when no VIEW is sepcified
          // for behaviour RBCW (prep 283434)
          // pragma translate_off
          \RAM_BIST_ERROR:ASIC_view_does_not_exist_in_miv_rv32_dpr_hqa_dual_storage_rbcw See_ICDC_KB_1481_for_details
          ();
          // pragma translate_on

          // Abort synthesis if AISC view is not available.
          // cadence script_begin
            // puts "PMC Error: Couldn't find RAM BIST ASIC view."
            // puts "PMC Error: Please run do_gen_bist.prl and create ASIC VIEW."
            // puts "PMC Error: quitting RC."
            // ::dc::exit_old
          // cadence script_end

          // pragma translate_off
          // if specified VIEW is not implemented, the simulation
          // prints error message and exits with fatal error.
          initial begin
            assert(0)
            else begin
              $display("ERROR : %s is not a valid VIEW", PMC_RAM_BIST_VIEW);
              $fatal;
            end
          end
          // pragma translate_on
        end : default_gen
    endcase
  endgenerate

  // pragma translate_off
  task gen_audit_report;
    input integer ram_num;
    begin : audit_task
      string  file_name;
      integer f_handle;
      string  selected_view;
      case (PMC_RAM_BIST_VIEW)
        ASIC :
          begin : asic_view_sel
            selected_view = "ASIC";
          end : asic_view_sel
        BEHAV :
          begin : behav_view_sel
            selected_view = "BEHAV";
          end : behav_view_sel
        FPGA :
          begin : fpga_view_sel
            selected_view = "FPGA";
          end : fpga_view_sel
        default :
          begin : default_view_sel
            selected_view = "WRONG_VIEW";
          end : default_view_sel
      endcase
      //file_name = $sformatf("../scripts/ram_bist/audit_logs/miv_rv32_dpr_hqa_dual_storage_rbcw%0d", ram_num);
      //f_handle = $fopen (file_name, "w+");
      $fdisplay (f_handle, "design:module_name:miv_rv32_dpr_hqa_dual_storage_rbcw");
      $fdisplay (f_handle, "design:instance_path:%m");
      $fdisplay (f_handle, "design:PMC_RAM_BIST_VIEW:%s", selected_view);
      $fdisplay (f_handle, "design:available_view:ASIC BEHAV FPGA DFT");
      $fdisplay (f_handle, "design:DATA_WIDTH:32");
      $fdisplay (f_handle, "design:RAM_DEPTH:256");
      $fdisplay (f_handle, "design:ADDR_WIDTH:8");
      $fdisplay (f_handle, "parameter:DATA_WIDTH:%1d", DATA_WIDTH);
      $fdisplay (f_handle, "parameter:ADDR_WIDTH:%1d", ADDR_WIDTH);
      $fdisplay (f_handle, "parameter:RAM_DEPTH:%1d", RAM_DEPTH);
      $fdisplay (f_handle, "bist_arg:01_mark_number:pm88_60_250");
      $fdisplay (f_handle, "bist_arg:02_ram_suffix:hqa_dual_storage");
      $fdisplay (f_handle, "bist_arg:03_ram_type:dpr");
      $fdisplay (f_handle, "bist_arg:04_ram_size:256x32");
      $fdisplay (f_handle, "bist_arg:05_addr_split:no_addr_split");
      $fdisplay (f_handle, "bist_arg:06_data_split:no_data_split");
      $fdisplay (f_handle, "bist_arg:07_func_clks:func_clks_sync");
      $fdisplay (f_handle, "bist_arg:08_bist_clks:a_sync_b_sync");
      $fdisplay (f_handle, "bist_arg:09_bypass_ff:bypass_all_off");
      $fdisplay (f_handle, "bist_arg:10_ram_err_check:ecc_on");
      $fdisplay (f_handle, "bist_arg:11_input_pipeline:input_pipeline_off");
      $fdisplay (f_handle, "bist_arg:12_output_pipeline:output_pipeline_off");
      $fdisplay (f_handle, "bist_arg:13_ram_init:false");
      $fdisplay (f_handle, "bist_arg:14_fpga_ecc:false");
      $fdisplay (f_handle, "bist_arg:15_rtl_mux:false");
      $fdisplay (f_handle, "bist_arg:16_stabilizer:false");
      $fdisplay (f_handle, "bist_arg:17_bit_write_en:false");
      $fdisplay (f_handle, "bist_arg:18_number_of_rbcw:20");
      $fclose (f_handle);
    end : audit_task
  endtask
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// RAM and BIST bist_template which can be used to drop in and replace a RAM
// instance.
//
// PARAMETER DESCRIPTION:
//
// RAM_DEPTH           Number of words in the RAM (<= 2^ADDR_WIDTH) 
// ADDR_WIDTH          Number of address bits.
// DATA_WIDTH          Number of data bits per word.
// LOW_POWER_WIDTH     Number of low_power bus bits.
// INPUT_PIPELINE      Indicates if input Pipeline flops are used or not
// INPUT_PIPELINE_LS   Indicates if input Pipeline flops for low power flops (ls)
// INPUT_PIPELINE_LP   Indicates if input Pipeline flops for low power flops (ds and sd)
//                     (ds and sd )are used or not
// OUTPUT_PIPELINE     Indicates if output Pipeline flops are used or not
// BWE_RAM             Indicates if this is bwe ram
// RAM_INIT_GEN        Indicates if ram init is generated
//
// INPUT PORT DESCRIPTION:
//
// rstb                System reset (active low). 
// clk                 RAM clock.
// lp1                 Light sleep mode input
// lp2                 Deep sleep mode input
// lp3                 Shut down mode input
// addr[]              RAM read/write address.
// ceb                 RAM cell enable (active low).
// web                 RAM write enable (active low).
// wemb[]              RAM write enable mask (active low).
// din[]               RAM write data. 
// ram_dout            Data output from ram
// pg_override         Override low power mode
// ram_init_enable     Enable for RAM initialization
//
// OUTPUT PORT DESCRIPTION:
//
// dout[]              RAM read data.
// low_power[]         Low power bus
// ram_addr[]          Address to RAM
// ram_ceb             Cell enable to RAM
// ram_web             Write enable to RAM
// ram_wemb[]          Write enable mask to RAM
// ram_din[]           Data input to RAM
// ram_init_busy       RAM initialization busy signal

`default_nettype none

module miv_rv32_gpr_ecc_bist_template
  #(
    parameter RAM_DEPTH       = 16,
    parameter DATA_WIDTH      = 8,
    parameter ADDR_WIDTH      = 4,
    parameter BIST_ADDR_WIDTH = 4,
    parameter LOW_POWER_WIDTH = 4,
    parameter NUM_LP1_PINS     = 1,
    parameter NUM_LP2_PINS     = 1,
    parameter NUM_LP3_PINS     = 1,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false FUNC_CLKS_SYNC
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_STABILIZER
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false BWE_RAM
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RTL_MUX
                              = miv_rv32_bist_shared_pkg::BIST_TRUE,
    parameter miv_rv32_bist_shared_pkg::t_bist_true_false RAM_INIT_GEN
                              = miv_rv32_bist_shared_pkg::BIST_FALSE,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LS
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline INPUT_PIPELINE_LP
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF,
    parameter miv_rv32_bist_shared_pkg::t_bist_pipeline OUTPUT_PIPELINE
                              = miv_rv32_bist_shared_pkg::BIST_PIPELINE_OFF

  )
  (
    input  wire logic                       arstb,
    input  wire logic                       aclk,
    input  wire logic                       brstb,
    input  wire logic                       bclk,
    // user ram interface
    input  wire logic [ADDR_WIDTH-1:0]      aaddr,
    input  wire logic                       aceb,
    input  wire logic                       aweb,
    input  wire logic [DATA_WIDTH-1:0]      awemb,
    input  wire logic [DATA_WIDTH-1:0]      adin,
    output      logic [DATA_WIDTH-1:0]      adout,
    input  wire logic [ADDR_WIDTH-1:0]      baddr,
    input  wire logic                       bceb,
    input  wire logic                       bweb,
    input  wire logic [DATA_WIDTH-1:0]      bwemb,
    input  wire logic [DATA_WIDTH-1:0]      bdin,
    output      logic [DATA_WIDTH-1:0]      bdout,
    // internal ram interfac
    output      logic                       ram_aceb,
    output      logic [DATA_WIDTH-1:0]      ram_awemb,
    output      logic                       ram_aweb,
    output      logic [ADDR_WIDTH-1:0]      ram_aaddr,
    output      logic [DATA_WIDTH-1:0]      ram_adin,
    input  wire logic [DATA_WIDTH-1:0]      ram_adout,
    output      logic                       ram_bceb,
    output      logic [DATA_WIDTH-1:0]      ram_bwemb,
    output      logic                       ram_bweb,
    output      logic [ADDR_WIDTH-1:0]      ram_baddr,
    output      logic [DATA_WIDTH-1:0]      ram_bdin,
    input  wire logic [DATA_WIDTH-1:0]      ram_bdout,
    // low power interface
    input  wire logic                       pg_clk,
    input  wire logic                       pg_rstb,
    input  wire logic                       pg_override,
    input  wire logic [NUM_LP1_PINS-1:0]     lp1,
    input  wire logic [NUM_LP2_PINS-1:0]     lp2,
    input  wire logic [NUM_LP3_PINS-1:0]     lp3,
    output      logic [LOW_POWER_WIDTH-1:0] low_power,
    // ram init interface
    input  wire logic                       ram_init_enable,
    output      logic                       ram_init_busy_a,
    output      logic                       ram_init_busy_b
  );

  import miv_rv32_bist_shared_pkg::*;

  // LOCAL PARAMETER
  localparam logic           POWR = 1'b1;
  localparam t_bist_pipeline BWE_PIPELINE = 
                           (BWE_RAM == BIST_TRUE && INPUT_PIPELINE == BIST_PIPELINE_ON) ? 
                           BIST_PIPELINE_ON : BIST_PIPELINE_OFF;

  // INTERNAL SIGNALS
  logic                   ram_init_clear_q;
  logic [ADDR_WIDTH-1:0]  ram_init_aaddr;
  logic                   ram_init_start_b;
  logic [DATA_WIDTH-1:0]  sys_adin;
  logic [DATA_WIDTH-1:0]  sys_adout;
  logic [ADDR_WIDTH-1:0]  sys_aaddr;
  logic                   sys_aceb;
  logic                   sys_aweb;
  logic [DATA_WIDTH-1:0]  sys_awemb;
  logic [DATA_WIDTH-1:0]  sys_bdin;
  logic [DATA_WIDTH-1:0]  sys_bdout;
  logic [ADDR_WIDTH-1:0]  sys_baddr;
  logic                   sys_bceb;
  logic                   sys_bweb;
  logic [DATA_WIDTH-1:0]  sys_bwemb;
  logic [NUM_LP1_PINS-1:0] sys_lp1;
  logic [NUM_LP2_PINS-1:0] sys_lp2;
  logic [NUM_LP3_PINS-1:0] sys_lp3;
  logic                   a_input_pl_data_enable;
  logic                   a_input_pl_ctrl_enable;
  logic                   a_output_pl_data_enable;
  logic                   b_input_pl_data_enable;
  logic                   b_input_pl_ctrl_enable;
  logic                   b_output_pl_data_enable;
  logic                   input_pl_pg_enable;
  logic                   sys_aceb_fpga;
  logic                   sys_bceb_fpga;
  logic [DATA_WIDTH-1:0]  sys_adout_fpga;
  logic [DATA_WIDTH-1:0]  sys_bdout_fpga;
  logic                   sys_awemb_and;
  logic                   sys_bwemb_and;

  assign sys_awemb_and = &sys_awemb;
  assign sys_bwemb_and = &sys_bwemb;

  // Pipeline enable logic
  miv_rv32_bistdual_pl_enable
    #(
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    pl_enable_inst
    (
      .arstb,
      .aclk,
      .aceb,
      .aweb,
      .a_input_pl_data_enable,
      .a_input_pl_ctrl_enable,
      .a_output_pl_data_enable,
      .brstb,
      .bclk,
      .bceb,
      .bweb,
      .b_input_pl_data_enable,
      .b_input_pl_ctrl_enable,
      .b_output_pl_data_enable,
      .input_pl_pg_enable
     );

  // RAM Control wrapper
  miv_rv32_bistdual_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .RTL_MUX(RTL_MUX),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS)
    )
    ctrl_inst
    (
      .ram_init_busy_a,
      .ram_init_busy_b,
      .ram_init_start_b,
      .ram_init_clear_q,
      .ram_init_aaddr,
      .sys_aceb(sys_aceb_fpga),
      .sys_aweb,
      .sys_awemb,
      .sys_aaddr,
      .ram_aceb,
      .ram_aweb,
      .ram_awemb,
      .ram_aaddr,
      .sys_bceb(sys_bceb_fpga),
      .sys_bweb,
      .sys_bwemb,
      .sys_baddr,
      .ram_bceb,
      .ram_bweb,
      .ram_bwemb,
      .ram_baddr,
      .sys_lp1,
      .sys_lp2,
      .sys_lp3,
      .pg_override,
      .low_power
    );

  // RAM Data Analyzer
  miv_rv32_bistdualdata_behav
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .RTL_MUX(RTL_MUX)
    )
    check_inst
    (
      .ram_init_busy_a,
      .sys_adin,
      .sys_adout,
      .ram_adin,
      .ram_adout,
      .ram_init_busy_b,
      .sys_bdin,
      .sys_bdout,
      .ram_bdin,
      .ram_bdout
    );

  // RAM initialization block
  miv_rv32_bistdual_ram_init 
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .RAM_DEPTH(RAM_DEPTH),
      .ADDR_WIDTH(ADDR_WIDTH)
    )
    ram_init_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .brstb(brstb),
      .bclk(bclk),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ram_init_start_b(ram_init_start_b),
      .ram_init_clear_q(ram_init_clear_q),
      .ram_init_aaddr(ram_init_aaddr)
    );

  // FPGA compaticle logic
  miv_rv32_bistdual_ram_stabilizer 
    #(
      .RAM_STABILIZER(RAM_STABILIZER),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH)
    )
    ram_stabilizer_enable_inst
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(sys_aaddr),
      .aceb_in(sys_aceb),
      .aceb_out(sys_aceb_fpga),
      .aweb(sys_aweb),
      .awemb_and(sys_awemb_and),
      .adin(sys_adin),
      .adout_in(sys_adout),
      .adout_out(sys_adout_fpga),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(sys_baddr),
      .bceb_in(sys_bceb),
      .bceb_out(sys_bceb_fpga),
      .bweb(sys_bweb),
      .bwemb_and(sys_bwemb_and),
      .bdin(sys_bdin),
      .bdout_in(sys_bdout),
      .bdout_out(sys_bdout_fpga)
    );

  // INPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aceb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(POWR),
      .din(aceb),
      .dout(sys_aceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    awemb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(awemb),
      .dout(sys_awemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    aweb_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aweb),
      .dout(sys_aweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE))
    aaddr_pipeline_inst(
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_ctrl_enable),
      .din(aaddr),
      .dout(sys_aaddr));

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    adin_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_input_pl_data_enable),
      .din(adin),
      .dout(sys_adin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bceb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(POWR),
      .din(bceb),
      .dout(sys_bceb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(BWE_PIPELINE)
    )
    bwemb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bwemb),
      .dout(sys_bwemb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(1),
      .DATA_INIT(1),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bweb_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(bweb),
      .dout(sys_bweb)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(ADDR_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    baddr_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_ctrl_enable),
      .din(baddr),
      .dout(sys_baddr)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE)
    )
    bdin_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_input_pl_data_enable),
      .din(bdin),
      .dout(sys_bdin)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP1_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LS)
    )
    lp1_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp1),
      .dout(sys_lp1)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP2_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp2_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp2),
      .dout(sys_lp2)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(NUM_LP3_PINS),
      .DATA_INIT(0),
      .DATA_PIPELINE(INPUT_PIPELINE_LP)
    )
    lp3_pipeline_inst
    (
      .clk(pg_clk),
      .rstb(pg_rstb),
      .enable(input_pl_pg_enable),
      .din(lp3),
      .dout(sys_lp3)
    );

  // OUTPUT Pipeline Module
  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    adout_pipeline_inst
    (
      .clk(aclk),
      .rstb(arstb),
      .enable(a_output_pl_data_enable),
      .din(sys_adout_fpga),
      .dout(adout)
    );

  miv_rv32_bist_pipeline 
    #(
      .DATA_WIDTH(DATA_WIDTH),
      .DATA_INIT(0),
      .DATA_PIPELINE(OUTPUT_PIPELINE)
    )
    bdout_pipeline_inst
    (
      .clk(bclk),
      .rstb(brstb),
      .enable(b_output_pl_data_enable),
      .din(sys_bdout_fpga),
      .dout(bdout)
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
`default_nettype none
`undef RAM_BIST_VIEW_BEHAV
`undef RAM_BIST_VIEW
`define RAM_BIST_VIEW_BEHAV

`ifdef RAM_BIST_VIEW_BEHAV
`define RAM_BIST_VIEW 1
`elsif RAM_BIST_VIEW_FPGA
`define RAM_BIST_VIEW 2
`elsif RAM_BIST_VIEW_DFT
`define RAM_BIST_VIEW 3
`else
`define RAM_BIST_VIEW 0
`endif

module miv_rv32_gpr_ecc_enc_dec
  #(
    parameter RAM_DEPTH            = 65536 ,
    parameter ADDR_WIDTH           = 28   ,
    parameter DATA_WIDTH           = 32  ,
    parameter PMC_RAM_BIST_VIEW    = `RAM_BIST_VIEW
  )
  (
    input  wire logic                    arstb,
    input  wire logic                    aclk,
    input  wire logic [ADDR_WIDTH-1:0]   aaddr,
    input  wire logic                    aceb,
    input  wire logic                    brstb,
    input  wire logic                    bclk,
    input  wire logic [ADDR_WIDTH-1:0]   baddr,
    input  wire logic                    bceb,
    input  wire logic                    ret1n,
    input  wire logic                    pg_override,
    input  wire logic                    ecc_bypass,
    input  wire logic [2-1:0]            ram_err_inject,
    output  wire logic [DATA_WIDTH-1:0]   adout,
    output  wire logic [DATA_WIDTH-1:0]   bdout,
    output      logic [2-1:0]            ecc_aerr,
    output      logic [2-1:0]            ecc_aerr_int,
    output      logic [2-1:0]            ecc_berr,
    output      logic [2-1:0]            ecc_berr_int,
    input  wire logic [ADDR_WIDTH-1:0]   waddr,
    input  wire logic [DATA_WIDTH-1:0]   wdin,
    input  wire logic                    wen
  );

  // IMPLEMENTATION
  import miv_rv32_bist_seq_pkg::*;

  typedef enum {
    ASIC  = 0,
    BEHAV = 1,
    FPGA  = 2,
    DFT   = 3
  } t_bist_view;

  logic [BISTCTL_WIDTH-1:0]  bistctl;
  logic            scanb;
  logic            bist_scanb;
  logic            bist_ramscanb;
  logic            bistrstb;
  logic            bistclk;
  logic            scan_en;
  logic            scan_en_o;
  logic            ram_iddq_en;
  logic            fll_clk;

  assign bistctl              = {1'b1,{BISTCTL_WIDTH-1{1'b0}}};
  assign scanb                = 1'b1;
  assign bist_scanb           = 1'b1;
  assign bist_ramscanb        = 1'b1;
  assign fll_clk              = 1'b1;
  assign bistrstb             = 1'b0;
  assign bistclk              = 1'b0;
  assign scan_en              = 1'b0;
  assign scan_en_o            = 1'b0;
  assign ram_iddq_en          = 1'b0;

  generate
    case (PMC_RAM_BIST_VIEW)
      ASIC :
        begin : asic_gen
          miv_rv32_dpr256x32_hqa_dual_storage_bistw
            miv_rv32_dpr256x32_hqa_dual_storage_bistw_inst
            (
              .scanb(scanb),
              .bist_scanb(bist_scanb),
              .bist_ramscanb(bist_ramscanb),
              .scan_en(scan_en),
              .scan_en_o(scan_en_o),
              .ram_iddq_en(ram_iddq_en),
              .bistrstb(bistrstb),
              .bistclk(bistclk),
              .bistctl(bistctl),
              .fll_clk(fll_clk),
              .bistackecc(),
              .bistackmult(),
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : asic_gen
      BEHAV :
        begin : behav_gen // using this :)
          miv_rv32_gpr_ecc_enc_dec_bistw_behav
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_behav_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adout(adout),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int),
              .waddr(waddr),
              .wdin(wdin),
              .wen(wen)
            );
        end : behav_gen
      FPGA :
        begin : fpga_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_fpga
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_fpga_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : fpga_gen
      DFT :
        begin : dft_gen
          miv_rv32_dpr_hqa_dual_storage_bistw_dft
            #(
              .ADDR_WIDTH(ADDR_WIDTH),
              .RAM_DEPTH(RAM_DEPTH),
              .DATA_WIDTH(DATA_WIDTH)
            )
            miv_rv32_dpr_hqa_dual_storage_bistw_dft_inst
            (
              .arstb(arstb),
              .aclk(aclk),
              .aaddr(aaddr),
              .aceb(aceb),
              .aweb(0),
              .brstb(brstb),
              .bclk(bclk),
              .baddr(baddr),
              .bceb(bceb),
              .bweb(0),
              .lp1(ret1n),
              .pg_override(pg_override),
              .ecc_bypass(ecc_bypass),
              .ram_err_inject(ram_err_inject),
              .adin(0),
              .adout(adout),
              .bdin(0),
              .bdout(bdout),
              .ecc_aerr(ecc_aerr),
              .ecc_aerr_int(ecc_aerr_int),
              .ecc_berr(ecc_berr),
              .ecc_berr_int(ecc_berr_int)
            );
        end : dft_gen
      default :
        begin : default_gen
          // Instantiates non-existing module to fail elaboration when no VIEW is sepcified
          // for behaviour RBCW (prep 283434)
          // pragma translate_off
          \RAM_BIST_ERROR:ASIC_view_does_not_exist_in_miv_rv32_dpr_hqa_dual_storage_rbcw See_ICDC_KB_1481_for_details
          ();
          // pragma translate_on

          // Abort synthesis if AISC view is not available.
          // cadence script_begin
            // puts "PMC Error: Couldn't find RAM BIST ASIC view."
            // puts "PMC Error: Please run do_gen_bist.prl and create ASIC VIEW."
            // puts "PMC Error: quitting RC."
            // ::dc::exit_old
          // cadence script_end

          // pragma translate_off
          // if specified VIEW is not implemented, the simulation
          // prints error message and exits with fatal error.
          initial begin
            assert(0)
            else begin
              $display("ERROR : %s is not a valid VIEW", PMC_RAM_BIST_VIEW);
              $fatal;
            end
          end
          // pragma translate_on
        end : default_gen
    endcase
  endgenerate

  // pragma translate_off
  task gen_audit_report;
    input integer ram_num;
    begin : audit_task
      string  file_name;
      integer f_handle;
      string  selected_view;
      case (PMC_RAM_BIST_VIEW)
        ASIC :
          begin : asic_view_sel
            selected_view = "ASIC";
          end : asic_view_sel
        BEHAV :
          begin : behav_view_sel
            selected_view = "BEHAV";
          end : behav_view_sel
        FPGA :
          begin : fpga_view_sel
            selected_view = "FPGA";
          end : fpga_view_sel
        default :
          begin : default_view_sel
            selected_view = "WRONG_VIEW";
          end : default_view_sel
      endcase
      //file_name = $sformatf("../scripts/ram_bist/audit_logs/miv_rv32_dpr_hqa_dual_storage_rbcw%0d", ram_num);
      //f_handle = $fopen (file_name, "w+");
      $fdisplay (f_handle, "design:module_name:miv_rv32_dpr_hqa_dual_storage_rbcw");
      $fdisplay (f_handle, "design:instance_path:%m");
      $fdisplay (f_handle, "design:PMC_RAM_BIST_VIEW:%s", selected_view);
      $fdisplay (f_handle, "design:available_view:ASIC BEHAV FPGA DFT");
      $fdisplay (f_handle, "design:DATA_WIDTH:32");
      $fdisplay (f_handle, "design:RAM_DEPTH:256");
      $fdisplay (f_handle, "design:ADDR_WIDTH:8");
      $fdisplay (f_handle, "parameter:DATA_WIDTH:%1d", DATA_WIDTH);
      $fdisplay (f_handle, "parameter:ADDR_WIDTH:%1d", ADDR_WIDTH);
      $fdisplay (f_handle, "parameter:RAM_DEPTH:%1d", RAM_DEPTH);
      $fdisplay (f_handle, "bist_arg:01_mark_number:pm88_60_250");
      $fdisplay (f_handle, "bist_arg:02_ram_suffix:hqa_dual_storage");
      $fdisplay (f_handle, "bist_arg:03_ram_type:dpr");
      $fdisplay (f_handle, "bist_arg:04_ram_size:256x32");
      $fdisplay (f_handle, "bist_arg:05_addr_split:no_addr_split");
      $fdisplay (f_handle, "bist_arg:06_data_split:no_data_split");
      $fdisplay (f_handle, "bist_arg:07_func_clks:func_clks_sync");
      $fdisplay (f_handle, "bist_arg:08_bist_clks:a_sync_b_sync");
      $fdisplay (f_handle, "bist_arg:09_bypass_ff:bypass_all_off");
      $fdisplay (f_handle, "bist_arg:10_ram_err_check:ecc_on");
      $fdisplay (f_handle, "bist_arg:11_input_pipeline:input_pipeline_off");
      $fdisplay (f_handle, "bist_arg:12_output_pipeline:output_pipeline_off");
      $fdisplay (f_handle, "bist_arg:13_ram_init:false");
      $fdisplay (f_handle, "bist_arg:14_fpga_ecc:false");
      $fdisplay (f_handle, "bist_arg:15_rtl_mux:false");
      $fdisplay (f_handle, "bist_arg:16_stabilizer:false");
      $fdisplay (f_handle, "bist_arg:17_bit_write_en:false");
      $fdisplay (f_handle, "bist_arg:18_number_of_rbcw:20");
      $fclose (f_handle);
    end : audit_task
  endtask
  // pragma translate_on


endmodule

// Reset default nettype for 3rd Party IP

`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////
`default_nettype none

module miv_rv32_gpr_ecc_enc_dec_bistw_behav
  #(
    parameter DATA_WIDTH       = 16,
    parameter ADDR_WIDTH       = 4,
    parameter RAM_DEPTH        = 65536
  )
  (
    input  wire logic                  ecc_bypass,
    input  wire logic [2-1:0]          ram_err_inject,
    output      logic [2-1:0]          ecc_aerr,
    output      logic [2-1:0]          ecc_berr,
    output      logic [2-1:0]          ecc_aerr_int,
    output      logic [2-1:0]          ecc_berr_int,

    input  wire logic                  pg_override,
    input  wire logic                  lp1,

    output      logic [DATA_WIDTH-1:0] adout,
    output      logic [DATA_WIDTH-1:0] bdout,
    input  wire logic                  arstb,
    input  wire logic                  aclk,
    input  wire logic [ADDR_WIDTH-1:0] aaddr,
    input  wire logic                  aceb,
    input  wire logic                  brstb,
    input  wire logic                  bclk,
    input  wire logic [ADDR_WIDTH-1:0] baddr,
    input  wire logic                  bceb,
    input  wire logic                  wen,
    input  wire logic [DATA_WIDTH-1:0] wdin,
    input  wire logic [ADDR_WIDTH-1:0] waddr
  );

  // IMPLEMENTATION 

  import miv_rv32_bist_shared_pkg::*;

  localparam PARITY_WIDTH      = parity_num(DATA_WIDTH);
  localparam logic             GRND              = 1'b0;
  localparam                   BISTW_WIDTH       = PARITY_WIDTH + DATA_WIDTH;
  localparam                   LOW_POWER_WIDTH   = 4;
  localparam                   NUM_LP1_PINS      = 1;
  localparam                   NUM_LP2_PINS      = 1;
  localparam                   NUM_LP3_PINS      = 1;
  localparam t_bist_true_false LP1_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP2_ACTIVE_LOW    = BIST_TRUE;
  localparam t_bist_true_false LP3_ACTIVE_LOW    = BIST_FALSE;
  localparam t_bist_true_false FUNC_CLKS_SYNC    = BIST_TRUE;
  localparam t_bist_true_false RAM_STABILIZER    = BIST_FALSE;
  localparam t_bist_true_false BWE_RAM           = BIST_FALSE;
  localparam t_bist_true_false RAM_INIT_GEN      = BIST_FALSE;
  localparam t_bist_true_false RTL_MUX           = BIST_TRUE;
  localparam t_bist_pipeline   INPUT_PIPELINE    = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LS = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   INPUT_PIPELINE_LP = BIST_PIPELINE_OFF;
  localparam t_bist_pipeline   OUTPUT_PIPELINE   = BIST_PIPELINE_OFF;

  logic [BISTW_WIDTH-1:0]     bistw_adin_all;
  logic [BISTW_WIDTH-1:0]     bistw_adout_all;
  logic [BISTW_WIDTH-1:0]     bistw_awemb;
  logic [BISTW_WIDTH-1:0]     bistw_bdin_all;
  logic [BISTW_WIDTH-1:0]     bistw_bdout_all;
  logic [BISTW_WIDTH-1:0]     bistw_bwemb;
  logic [ADDR_WIDTH-1:0]      ram_aaddr;
  logic                       ram_aceb;
  logic [BISTW_WIDTH-1:0]     ram_awemb;
  logic                       ram_aweb;
  logic [BISTW_WIDTH-1:0]     ram_adin;
  logic [BISTW_WIDTH-1:0]     ram_adout;
  logic [ADDR_WIDTH-1:0]      ram_baddr;
  logic                       ram_bceb;
  logic [BISTW_WIDTH-1:0]     ram_bwemb;
  logic                       ram_bweb;
  logic [BISTW_WIDTH-1:0]     ram_bdin;
  logic [BISTW_WIDTH-1:0]     ram_bdout;
  logic [LOW_POWER_WIDTH-1:0] low_power;
  logic                 lp2;
  logic                 lp3;
  logic                 ram_init_enable;
  logic                 ram_init_busy_a;
  logic                 ram_init_busy_b;
  logic                 pg_rstb;
  logic                 pg_clk;
  logic                 awemb_and;
  logic                 bwemb_and;
  logic                 bist_ramscanb;
  logic                 bistb;
  logic [PARITY_WIDTH-1:0] bistw_apin;
  logic [PARITY_WIDTH-1:0] bistw_bpin;
  logic [DATA_WIDTH-1:0] bistw_adin;
  logic [DATA_WIDTH-1:0] bistw_bdin;
  logic [PARITY_WIDTH-1:0] bistw_apout;
  logic [PARITY_WIDTH-1:0] bistw_bpout;
  logic [DATA_WIDTH-1:0] bistw_adout;
  logic [DATA_WIDTH-1:0] bistw_bdout;
  logic [BISTW_WIDTH-1:0]     ram_wdin;
  logic      ram_web;
  logic [ADDR_WIDTH-1:0]      ram_waddr;

  assign ram_init_enable = 1'b0;
  assign pg_rstb         = 1'b0;
  assign pg_clk          = 1'b0;
  assign bist_ramscanb   = 1'b1;
  assign bistb           = 1'b1;
  assign awemb_and       = 1'b0;
  assign bwemb_and       = 1'b0;
  assign bistw_awemb     = 1'b0;
  assign bistw_bwemb     = 1'b0;
  assign lp2             = 1'b0;
  assign lp3             = 1'b0;
  assign bistw_adin_all  = {bistw_apin, bistw_adin};
  assign bistw_bdin_all  = {bistw_bpin, bistw_bdin};
  assign {bistw_apout, bistw_adout} = bistw_adout_all;
  assign {bistw_bpout, bistw_bdout} = bistw_bdout_all;

  // ECC wrapper
  miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_dec_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(1'b0),
      .awemb_and(1'b0),
      .sys_adin({DATA_WIDTH{1'b0}}), // write data in
      .bistw_adout(bistw_adout), // data out
      .bistw_apout(bistw_apout), // parity out
      .sys_adout(adout),
      .bistw_adin(), // write data port a
      .bistw_apin(), // write parity port a
      .ecc_aerr(ecc_aerr),
      .ecc_aerr_int(ecc_aerr_int),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(1'b0),
      .bwemb_and(1'b0),
      .sys_bdin({DATA_WIDTH{1'b0}}), // write data in
      .bistw_bdout(bistw_bdout),
      .bistw_bpout(bistw_bpout),
      .sys_bdout(bdout),
      .bistw_bdin(), // write data port b
      .bistw_bpin(), // write parity port b
      .ecc_berr(ecc_berr),
      .ecc_berr_int(ecc_berr_int)
    );
    
    miv_rv32_bistdual_eccw
    #(
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .ADDR_WIDTH(ADDR_WIDTH),
      .DATA_WIDTH(DATA_WIDTH),
      .PARITY_WIDTH(PARITY_WIDTH),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    ecc_enc_inst
    (
      .bistb(bistb),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b),
      .ecc_bypass(ecc_bypass),
      .ram_err_inject(ram_err_inject),
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(waddr),
      .aceb(aceb),
      .aweb(wen),
      .awemb_and(awemb_and),
      .sys_adin(wdin),
      .bistw_adout({DATA_WIDTH{1'b0}}),
      .bistw_apout({PARITY_WIDTH{1'b0}}),
      .sys_adout(),
      .bistw_adin(bistw_adin),
      .bistw_apin(bistw_apin),
      .ecc_aerr(),
      .ecc_aerr_int(),
      .brstb(1'b0),
      .bclk(1'b0),
      .baddr({ADDR_WIDTH{1'b0}}),
      .bceb(1'b0),
      .bweb(1'b0),
      .bwemb_and(1'b0),
      .sys_bdin(0),
      .bistw_bdout({DATA_WIDTH{1'b0}}),
      .bistw_bpout({PARITY_WIDTH{1'b0}}),
      .sys_bdout(),
      .bistw_bdin(),
      .bistw_bpin(),
      .ecc_berr(),
      .ecc_berr_int()
    );


  // RAM wrapper
  //miv_rv32_dpr_behav_ramw_arm28
    //#(
      //.DATA_WIDTH(BISTW_WIDTH),
      //.ADDR_WIDTH(ADDR_WIDTH),
      //.RAM_DEPTH(RAM_DEPTH),
      //.LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      //.NUM_LP1_PINS(NUM_LP1_PINS),
      //.NUM_LP2_PINS(NUM_LP2_PINS),
      //.NUM_LP3_PINS(NUM_LP3_PINS)
    //)
    //ram_inst
    //(
      //.aclk(aclk),
      //.aaddr(ram_aaddr),
      //.aceb(ram_aceb),
      //.aweb(ram_aweb),
      //.awemb(ram_awemb),
      //.adin(ram_adin),
      //.adout(ram_adout),
      //.bclk(bclk),
      //.baddr(ram_baddr),
      //.bceb(ram_bceb),
      //.bweb(ram_bweb),
      //.bwemb(ram_bwemb),
      //.bdin(ram_bdin),
      //.bdout(ram_bdout),
      //.low_power(low_power)
    //);

/*
  miv_rv32_ram_dport_reg
    #(
      .d_width(BISTW_WIDTH),
      .addr_width(ADDR_WIDTH),
      .mem_depth(RAM_DEPTH)
    )
    ram_inst
    (
      .clk(aclk),
      .waddr0(ram_waddr),
      .we0(ram_web),
      .data0(ram_wdin),
      .q0(ram_adout),
      .waddr1(ram_),
      .we1(0),
      .data1(0),
      .q1(ram_bdout)
    );
  */  
  
    miv_rv32_gpr_ram_array
  //******************************************************************
  // Parameter description
  #(
    .mem_depth                     (32),
    .addr_width_gpr                (ADDR_WIDTH),
    .d_width                       (BISTW_WIDTH)
   )
  u_gpr_0
  //******************************************************************
  // Signal description
  (
        // Inputs
        .clk           ( aclk ),
        .raddr0          ( ram_aaddr ),
        .raddr1          ( ram_baddr ),
        .waddr0        ( ram_waddr ),
        .waddr1         ({ADDR_WIDTH{1'b0}}),
        .we0           ( ram_web ),
        .we1           ( 1'b0 ),
        .data0           ( ram_wdin ),
        .data1           ( {BISTW_WIDTH{1'b0}} ),
        // Outputs
        .q0          ( ram_adout ),
        .q1          ( ram_bdout )
        );



 // BIST wrapper
  miv_rv32_gpr_ecc_bist_template
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst_dec
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(aaddr),
      .aceb(aceb),
      .aweb(1'b0),
      .awemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}), 
      .adin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .adout(bistw_adout_all),
      .ram_aaddr(ram_aaddr),
      .ram_aceb(ram_aceb),
      .ram_aweb(),
      .ram_awemb(),
      .ram_adin(),
      .ram_adout(ram_adout),
      .brstb(brstb),
      .bclk(bclk),
      .baddr(baddr),
      .bceb(bceb),
      .bweb(1'b0),
      .bwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdout(bistw_bdout_all),
      .ram_baddr(ram_baddr),
      .ram_bceb(ram_bceb),
      .ram_bweb(),
      .ram_bwemb(),
      .ram_bdin(),
      .ram_bdout(ram_bdout),
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(low_power),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(ram_init_busy_a),
      .ram_init_busy_b(ram_init_busy_b)
    );
    
     // BIST wrapper
  miv_rv32_gpr_ecc_bist_template
    #(
      .RAM_DEPTH(RAM_DEPTH),
      .DATA_WIDTH(BISTW_WIDTH),
      .ADDR_WIDTH(ADDR_WIDTH),
      .LOW_POWER_WIDTH(LOW_POWER_WIDTH),
      .NUM_LP1_PINS(NUM_LP1_PINS),
      .NUM_LP2_PINS(NUM_LP2_PINS),
      .NUM_LP3_PINS(NUM_LP3_PINS),
      .FUNC_CLKS_SYNC(FUNC_CLKS_SYNC),
      .RAM_STABILIZER(RAM_STABILIZER),
      .BWE_RAM(BWE_RAM),
      .RTL_MUX(RTL_MUX),
      .RAM_INIT_GEN(RAM_INIT_GEN),
      .INPUT_PIPELINE(INPUT_PIPELINE),
      .INPUT_PIPELINE_LS(INPUT_PIPELINE_LS),
      .INPUT_PIPELINE_LP(INPUT_PIPELINE_LP),
      .OUTPUT_PIPELINE(OUTPUT_PIPELINE)
    )
    dual_inst_enc
    (
      .arstb(arstb),
      .aclk(aclk),
      .aaddr(waddr),
      .aceb(aceb),
      .aweb(wen),
      .awemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .adin(bistw_adin_all),
      .adout(),
      .ram_aaddr(ram_waddr),
      .ram_aceb(),
      .ram_aweb(ram_web),
      .ram_awemb(),
      .ram_adin(ram_wdin),
      .ram_adout(),
      .brstb(1'b0),
      .bclk(1'b0),
      .baddr({ADDR_WIDTH{1'b0}}),
      .bceb(1'b0),
      .bweb(1'b0),
      .bwemb({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdin({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .bdout(),
      .ram_baddr(),
      .ram_bceb(),
      .ram_bweb(),
      .ram_bwemb(),
      .ram_bdin(),
      .ram_bdout({(DATA_WIDTH + PARITY_WIDTH){1'b0}}),
      .pg_clk(pg_clk),
      .pg_rstb(pg_rstb),
      .pg_override(pg_override),
      .lp1(lp1),
      .lp2(lp2),
      .lp3(lp3),
      .low_power(),
      .ram_init_enable(ram_init_enable),
      .ram_init_busy_a(),
      .ram_init_busy_b()
    );

endmodule

// Reset default nettype for 3rd Party IP
`default_nettype wire

// Copyright (c) 2020, Microchip Corporation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL MICROCHIP CORPORATIONM BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// APACHE LICENSE
// Copyright (c) 2020, Microchip Corporation 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// SVN Revision Information:
// SVN $Revision: $
// SVN $Date: $
//
// Resolved SARs
// SAR      Date     Who   Description
//
// Notes:
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:
//
// 1) This module defines the behavioural model of the PMC logic mux.
//    It can be used only for RTL simulation and formal verification.
//    It is a hard macro, so during synthesis this block is not going to be
//    synthesized.
//    The schematic is as follows:
//    
//                    +-----+
//              a >---|0    |
//                    | Mux |----->y     
//              b >---|1    |
//                    +--+--+
//                       |
//                 s0 >--+
//
// 2) output_delay_ps is declared at instantiation in ps.  This value is then
//    converted to ns to comply with the local timescale directive.
//
//
// PARAMETER DESCRIPTION:
//
// output_delay_ps          delay of the input to output signals, 
//                          expressed in ps
//
//
// INPUT PORT DESCRIPTION:
//
// a                    data input
// b                    data input
// s0                   select signal (selects a when 0)
//
//
// OUTPUT PORT DESCRIPTION:
//
// y                   mux output
//
//
// NOTES:
// 
// 1. If this file is changed in any way by the user, the module name must be
//    changed to prevent simulation mismatches with other designs at device
//    integration.
//
////////////////////////////////////////////////////////////////////////////////

`default_nettype none
`timescale 1 ns / 1 ps

module miv_rv32_logic_mux_behav_v2
  #(
    parameter output_delay_ps = 0 // changed to lowercase as per CAD_PREP 97943
                                  // must remain lowercase to support legacy RTL
                                  // and match case in /home/liblib files
  )
  (
    input  wire logic a,
    input  wire logic b,
    input  wire logic s0,
    
    output wire  y  //changed to wire as per CAD_PREP 96834
  );
  
  // LOCAL PARAMETERS
  // convert ps to ns
  localparam OUTPUT_DELAY_TIME = output_delay_ps * 0.001;
  
  // Following dc_script_begin dc_script_end pragmas are used to prevent DC
  // from reading this model
  // synopsys dc_script_begin
  // echo "Error: You cannot read miv_rv32_logic_mux_behav_v2 into dc_shell"
  // exit
  // synopsys dc_script_end
  
  // FUNCTIONS
  function automatic logic muxoutput
  (
    input  logic a_input,
    input  logic b_input,
    input  logic s0_select
  );
    unique case ( s0_select )
      1'b0    : muxoutput = a_input; // a select
      1'b1    : muxoutput = b_input; // b select
      default : muxoutput = 1'bX;
    endcase 
  endfunction : muxoutput
  
  assign
    // synopsys translate_off
    #OUTPUT_DELAY_TIME
    // synopsys translate_on
    y = muxoutput(a, b, s0);
  
endmodule : miv_rv32_logic_mux_behav_v2

// Reset default nettype for 3rd Party IP
`default_nettype wire

